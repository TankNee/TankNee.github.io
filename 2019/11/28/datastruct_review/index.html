<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="数据结构入门？这一篇就够了"><meta name="keywords" content="操作,地址,类型,length,列表,node,字符,算法,函数,节点,int,temp,变量,查找,arr"><meta name="author" content="TankNee"><meta name="copyright" content="TankNee"><title>数据结构入门？这一篇就够了 | 归舟棹远</title><link rel="shortcut icon" href="https://img.tanknee.cn/blogpicbed/2020/06/2020060186bc451656937.png"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#算法分析"><span class="toc-number">1.</span> <span class="toc-text">算法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#运行时间的计算分析"><span class="toc-number">1.1.</span> <span class="toc-text">运行时间的计算分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#求解算法时间复杂度的步骤"><span class="toc-number">1.1.1.</span> <span class="toc-text">求解算法时间复杂度的步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#复杂度函数的运算规则"><span class="toc-number">1.1.2.</span> <span class="toc-text">复杂度函数的运算规则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#抽象数据类型ADT"><span class="toc-number">2.</span> <span class="toc-text">抽象数据类型ADT</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#表"><span class="toc-number">2.1.</span> <span class="toc-text">表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#顺序表"><span class="toc-number">2.1.1.</span> <span class="toc-text">顺序表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#链表"><span class="toc-number">2.1.2.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#循环链表"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">循环链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#双向链表"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">双向链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#双向循环链表"><span class="toc-number">2.1.2.3.</span> <span class="toc-text">双向循环链表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈"><span class="toc-number">2.2.</span> <span class="toc-text">栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#队列"><span class="toc-number">2.3.</span> <span class="toc-text">队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#树"><span class="toc-number">3.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树"><span class="toc-number">3.1.</span> <span class="toc-text">二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉查找树"><span class="toc-number">3.2.</span> <span class="toc-text">二叉查找树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AVL树"><span class="toc-number">3.3.</span> <span class="toc-text">AVL树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#伸展树"><span class="toc-number">3.4.</span> <span class="toc-text">伸展树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-树"><span class="toc-number">3.5.</span> <span class="toc-text">B-树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用阶数来定义B-树："><span class="toc-number">3.5.1.</span> <span class="toc-text">用阶数来定义B-树：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#树的遍历"><span class="toc-number">3.6.</span> <span class="toc-text">树的遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#散列"><span class="toc-number">4.</span> <span class="toc-text">散列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#散列的定义"><span class="toc-number">4.1.</span> <span class="toc-text">散列的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解决散列冲突问题"><span class="toc-number">4.2.</span> <span class="toc-text">解决散列冲突问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#分离链接法"><span class="toc-number">4.2.1.</span> <span class="toc-text">分离链接法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#开放定址法"><span class="toc-number">4.2.2.</span> <span class="toc-text">开放定址法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#线性探测法"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">线性探测法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#平方探测法"><span class="toc-number">4.2.2.2.</span> <span class="toc-text">平方探测法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#优先队列-堆"><span class="toc-number">5.</span> <span class="toc-text">优先队列-堆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉堆"><span class="toc-number">5.1.</span> <span class="toc-text">二叉堆</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#二叉堆的构造"><span class="toc-number">5.1.1.</span> <span class="toc-text">二叉堆的构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二叉堆的插入算法"><span class="toc-number">5.1.2.</span> <span class="toc-text">二叉堆的插入算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#排序"><span class="toc-number">6.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#插入排序"><span class="toc-number">6.1.</span> <span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#希尔排序"><span class="toc-number">6.2.</span> <span class="toc-text">希尔排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#堆排序"><span class="toc-number">6.3.</span> <span class="toc-text">堆排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#归并排序"><span class="toc-number">6.4.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#快速排序"><span class="toc-number">6.5.</span> <span class="toc-text">快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#桶式排序"><span class="toc-number">6.6.</span> <span class="toc-text">桶式排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java实现"><span class="toc-number">6.6.1.</span> <span class="toc-text">Java实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C语言实现："><span class="toc-number">6.6.2.</span> <span class="toc-text">C语言实现：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#外部排序"><span class="toc-number">6.7.</span> <span class="toc-text">外部排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#排序分析"><span class="toc-number">6.8.</span> <span class="toc-text">排序分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#图论算法"><span class="toc-number">7.</span> <span class="toc-text">图论算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#图的表示"><span class="toc-number">7.1.</span> <span class="toc-text">图的表示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#前者是用二维数组来实现图："><span class="toc-number">7.1.1.</span> <span class="toc-text">前者是用二维数组来实现图：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#后者是用链表的方式来实现图："><span class="toc-number">7.1.2.</span> <span class="toc-text">后者是用链表的方式来实现图：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拓扑排序"><span class="toc-number">7.2.</span> <span class="toc-text">拓扑排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最短路径"><span class="toc-number">7.3.</span> <span class="toc-text">最短路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#图的搜索方法"><span class="toc-number">7.3.1.</span> <span class="toc-text">图的搜索方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dijkstra算法"><span class="toc-number">7.3.2.</span> <span class="toc-text">Dijkstra算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最小生成树"><span class="toc-number">7.4.</span> <span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Prim算法"><span class="toc-number">7.4.1.</span> <span class="toc-text">Prim算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Kruskal算法"><span class="toc-number">7.4.2.</span> <span class="toc-text">Kruskal算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算法设计技巧"><span class="toc-number">8.</span> <span class="toc-text">算法设计技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#贪婪算法"><span class="toc-number">8.1.</span> <span class="toc-text">贪婪算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#图例"><span class="toc-number">8.1.1.</span> <span class="toc-text">图例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#贪婪算法的应用"><span class="toc-number">8.1.2.</span> <span class="toc-text">贪婪算法的应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Huffman编码"><span class="toc-number">8.1.3.</span> <span class="toc-text">Huffman编码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#编码的比特数："><span class="toc-number">8.1.3.1.</span> <span class="toc-text">编码的比特数：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Huffman算法"><span class="toc-number">8.1.3.2.</span> <span class="toc-text">Huffman算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#示例图："><span class="toc-number">8.1.3.3.</span> <span class="toc-text">示例图：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#代码实现："><span class="toc-number">8.1.3.4.</span> <span class="toc-text">代码实现：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分治算法"><span class="toc-number">8.2.</span> <span class="toc-text">分治算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#应用"><span class="toc-number">8.2.0.1.</span> <span class="toc-text">应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态规划"><span class="toc-number">8.3.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#动态规划的核心思想是"><span class="toc-number">8.3.1.</span> <span class="toc-text">动态规划的核心思想是</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#斐波那契数列动态规划"><span class="toc-number">8.3.2.</span> <span class="toc-text">斐波那契数列动态规划</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#最短编辑距离"><span class="toc-number">8.3.3.</span> <span class="toc-text">最短编辑距离</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#动态规划表的初始化"><span class="toc-number">8.3.3.1.</span> <span class="toc-text">动态规划表的初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#举例"><span class="toc-number">8.3.3.2.</span> <span class="toc-text">举例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#下面是源码"><span class="toc-number">8.3.3.3.</span> <span class="toc-text">下面是源码</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://img.tanknee.cn/blogpicbed/2020/06/2020060186bc451656937.png"></div><div class="author-info__name text-center">TankNee</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/TankNee" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">80</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">174</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">3</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://samool.com" target="_blank" rel="noopener">傻猫网络日志</a><a class="author-info-links__name text-center" href="https://greatxs.com/" target="_blank" rel="noopener">星霜博客</a><a class="author-info-links__name text-center" href="https://blog.irow.top" target="_blank" rel="noopener">锋临博客</a><a class="author-info-links__name text-center" href="https://www.wangray.cn" target="_blank" rel="noopener">Ray's Blog</a><a class="author-info-links__name text-center" href="http://blog.yyqiang.top" target="_blank" rel="noopener">Soulxyzの日常</a><a class="author-info-links__name text-center" href="https://www.xcnte.com" target="_blank" rel="noopener">Xcnte' s Blog</a><a class="author-info-links__name text-center" href="https://aoyun.me/" target="_blank" rel="noopener">张奥运</a><a class="author-info-links__name text-center" href="https://catct.cn/" target="_blank" rel="noopener">猫猫博客</a><a class="author-info-links__name text-center" href="https://www.deathfugue.com" target="_blank" rel="noopener">死亡赋格 Deathfugue</a><a class="author-info-links__name text-center" href="https://449293786.site" target="_blank" rel="noopener">五葉魔法書</a><a class="author-info-links__name text-center" href="https://bk.ilil12138.com" target="_blank" rel="noopener">小白博客</a><a class="author-info-links__name text-center" href="https://www.dxsh.vip" target="_blank" rel="noopener">天谕</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://img.tanknee.cn/img/20191123190408.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">归舟棹远</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a><a class="site-page" href="/links">Links</a><a class="site-page" href="/gallery">Gallery</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">数据结构入门？这一篇就够了</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-11-28</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Code/">Code</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">12.2k</span><span class="post-meta__separator">|</span><span>Reading time: 49 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><h3 id="运行时间的计算分析"><a href="#运行时间的计算分析" class="headerlink" title="运行时间的计算分析"></a>运行时间的计算分析</h3><p>上界：$O(f(N))$</p>
<p>下界：$Ω(g(N))$</p>
<p>准确表达则为：$Θ(h(N))$</p>
<p>也就是说都是一个关于N的函数！</p>
<p>这么做的目的是为了比较两个算法的<strong>相对增长速率</strong></p>
<h4 id="求解算法时间复杂度的步骤"><a href="#求解算法时间复杂度的步骤" class="headerlink" title="求解算法时间复杂度的步骤"></a>求解算法时间复杂度的步骤</h4><ol>
<li>找出算法中的基本语句；</li>
</ol>
<p>　　算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。</p>
<ol start="2">
<li>计算基本语句的执行次数的数量级；</li>
</ol>
<p>　　只需计算基本语句执行次数的数量级，这就意味着只要保证基本语句执行次数的函数中的最高次幂正确即可，可以忽略所有低次幂和最高次幂的系数。这样能够简化算法分析，并且使注意力集中在最重要的一点上：增长率。</p>
<ol start="3">
<li>用大Ο记号表示算法的时间性能。</li>
</ol>
<p>　　将基本语句执行次数的数量级放入大Ο记号中。</p>
<ol start="4">
<li>可以忽略末尾带上的常数项</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求数组中的子序列的和的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxSubsequenceSum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> A[],<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tempSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++)&#123;</span><br><span class="line">        tempSum += A[i];</span><br><span class="line">        <span class="keyword">if</span>(tempSum &gt; maxSum)&#123;</span><br><span class="line">            maxSum = tempSum;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tempSum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            tempSum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="复杂度函数的运算规则"><a href="#复杂度函数的运算规则" class="headerlink" title="复杂度函数的运算规则"></a>复杂度函数的运算规则</h4><img src="https://img.tanknee.cn/img/20191123190408.png"/>

<h2 id="抽象数据类型ADT"><a href="#抽象数据类型ADT" class="headerlink" title="抽象数据类型ADT"></a>抽象数据类型ADT</h2><h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><p>表分为两种，顺序表与链表。其中顺序表要求系统给其分配的内存单元是连续的，因此，顺序表的访问时间可以做到线性时间，第二种是链表，链表不要求连续的内存空间，但其中的每一块都是与其他链表节点耦合的。</p>
<h4 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h4><p>即数组，内存地址连续。</p>
<p>访问时为线性访问，速度较快。插入删除时代价较大，因为需要更改其后所有元素的信息才能维持当前的顺序表。</p>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>在C语言中是通过建立结构体然后存储指针的方式来进行访问的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 邻接表中表的顶点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">VNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> index;          <span class="comment">// 顶点信息</span></span><br><span class="line">    ENode *firstEdge; <span class="comment">// 指向第一条依附该顶点的弧</span></span><br><span class="line">&#125; VNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LGraph</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> vexNum; <span class="comment">// 图的顶点的数目</span></span><br><span class="line">    <span class="keyword">int</span> edgNum; <span class="comment">// 图的边的数目</span></span><br><span class="line">    VNode vexs[MAX];</span><br><span class="line">&#125; LGraph;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="http://git.tanknee.cn/snippets/1" target="_blank" rel="noopener">代码片段</a></p>
</blockquote>
<h5 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h5><h5 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h5><h5 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h5><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>特点：先进后出<code>FILO</code></p>
<p>只需要一个指针就可以利用链表来实现栈的数据结构，在栈中只有栈顶可以出入数据，栈底的数据只有等其他数据都出去了才能被弹出</p>
<p>两个栈操作：<code>PUSH</code> <code>POP</code></p>
<p>实例：使用栈数据结构来实现后缀表达式</p>
<img src="https://img.tanknee.cn/img/20191123165051.png"/>

<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>特点：先进先出<code>FIFO</code></p>
<p>对于队列而言，有两个口可以与外界交换数据，分别是队列头和队列尾部。</p>
<p>只允许在队列尾部入队，在队列头部出队。</p>
<p>两个操作：<code>Enqueue</code> <code>Dequeue</code></p>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><blockquote>
<p><a href="https://tanknee.cn/2019/10/21/524" target="_blank" rel="noopener">之前写的二叉树博客</a></p>
</blockquote>
<blockquote>
<p><a href="D:\OneDrive\文档\博客本地草稿存档\课内\数据结构\DataStruct.md">本地</a></p>
</blockquote>
<h3 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h3><p>AVL树是带有平衡条件的二叉查找树。</p>
<p>平衡条件必须要相对容易保持，而且必须保证树的深度是$O(logN)$，那么在AVL树中，就是保证节点的左右子树的高度之差小于2，即只能为1或者0 。</p>
<p>下面是AVL树插入的C语言实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a,b) (a &gt; b) ? (a) : (b)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AVL树的结构体定义</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVLTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span>   </span><br><span class="line">    <span class="keyword">int</span> data;   <span class="comment">//节点存储的值</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span>; <span class="comment">//当前节点的高度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVLTreeNode</span> *<span class="title">leftChild</span>;</span>  <span class="comment">//左儿子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVLTreeNode</span> *<span class="title">rightChild</span>;</span> <span class="comment">//右儿子</span></span><br><span class="line">&#125;Node,*AVLTree;</span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * @param data 存储的数据</span></span><br><span class="line"><span class="comment"> * @param left 左儿子</span></span><br><span class="line"><span class="comment"> * @param right 右儿子</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Node *<span class="title">createAVLTreeNode</span><span class="params">(<span class="keyword">int</span> data,Node *left,Node *right)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 为这个新的节点开辟内存空间</span></span><br><span class="line">    Node *node;</span><br><span class="line">    <span class="keyword">if</span> (((node = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node))) == <span class="literal">NULL</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为这个node赋初值</span></span><br><span class="line">    node-&gt;data = data;</span><br><span class="line">    <span class="comment">// 空子树的高度为0</span></span><br><span class="line">    node-&gt;<span class="built_in">height</span> = <span class="number">0</span>;</span><br><span class="line">    node-&gt;leftChild = left;</span><br><span class="line">    node-&gt;rightChild = right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取节点的高度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeightOfNode</span><span class="params">(Node *node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (node==<span class="literal">NULL</span>) ? <span class="number">0</span> : node-&gt;<span class="built_in">height</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * LL：左左对应的情况(左单旋转)。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值：旋转后的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Node* <span class="title">leftLeftRotation</span><span class="params">(AVLTree k2)</span></span>&#123;</span><br><span class="line">    AVLTree k1;</span><br><span class="line"></span><br><span class="line">    k1 = k2-&gt;leftChild;</span><br><span class="line">    <span class="comment">// k2与k1的右子树进行互换</span></span><br><span class="line">    k2-&gt;leftChild = k1-&gt;rightChild;</span><br><span class="line">    k1-&gt;rightChild = k2;</span><br><span class="line"></span><br><span class="line">    k2-&gt;<span class="built_in">height</span> = MAX( getHeightOfNode(k2-&gt;leftChild), getHeightOfNode(k2-&gt;rightChild)) + <span class="number">1</span>;</span><br><span class="line">    k1-&gt;<span class="built_in">height</span> = MAX( getHeightOfNode(k1-&gt;leftChild), k2-&gt;<span class="built_in">height</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 旋转完成之后的根节点是k1，即k1上浮了而原本的k2下沉为k1的儿子了</span></span><br><span class="line">    <span class="keyword">return</span> k1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * RR：右右对应的情况(右单旋转)。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值：旋转后的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Node* <span class="title">rightRightRotation</span><span class="params">(AVLTree k2)</span></span>&#123;</span><br><span class="line">    AVLTree k1;</span><br><span class="line"></span><br><span class="line">    k1 = k2-&gt;rightChild;</span><br><span class="line">    <span class="comment">// k2与k1的右子树进行互换</span></span><br><span class="line">    k2-&gt;rightChild = k1-&gt;leftChild;</span><br><span class="line">    k1-&gt;leftChild = k2;</span><br><span class="line"></span><br><span class="line">    k2-&gt;<span class="built_in">height</span> = MAX( getHeightOfNode(k2-&gt;leftChild), getHeightOfNode(k2-&gt;rightChild)) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//此时的k2为k1的左儿子，所以只需要比较k2和k1的右儿子的高度就好了</span></span><br><span class="line">    k1-&gt;<span class="built_in">height</span> = MAX( getHeightOfNode(k1-&gt;rightChild), k2-&gt;<span class="built_in">height</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 旋转完成之后的根节点是k1，即k1上浮了而原本的k2下沉为k1的儿子了</span></span><br><span class="line">    <span class="keyword">return</span> k1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * LR</span></span><br><span class="line"><span class="comment"> * 相当于进行了一次RR旋转一次LL旋转。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Node *<span class="title">leftRightRotation</span><span class="params">(Node *k3)</span></span>&#123;</span><br><span class="line">    <span class="comment">//先对k3的左子树进行RR旋转，再对旋转后的k3进行LL旋转</span></span><br><span class="line">    k3-&gt;leftChild = rightRightRotation(k3-&gt;leftChild);</span><br><span class="line">    <span class="keyword">return</span> leftLeftRotation(k3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * RL</span></span><br><span class="line"><span class="comment"> * 相当于进行了一次LL旋转一次RR旋转。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Node *<span class="title">rightLeftRotation</span><span class="params">(Node *k3)</span></span>&#123;</span><br><span class="line">    <span class="comment">//先对k3的右子树进行LL旋转，再对旋转后的k3进行RR旋转</span></span><br><span class="line">    k3-&gt;rightChild = leftLeftRotation(k3-&gt;rightChild);</span><br><span class="line">    <span class="keyword">return</span> rightRightRotation(k3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入要插入的树</span></span><br><span class="line"><span class="comment"> * 传入要插入的数据</span></span><br><span class="line"><span class="comment"> * 返回更新后的树的根节点</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function">Node *<span class="title">insertIntoAVLTree</span><span class="params">(AVLTree tree,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如果树是一个空树</span></span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">// 那么就建立一个空节点</span></span><br><span class="line">        tree = createAVLTreeNode(data,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 如果创建失败的话</span></span><br><span class="line">        <span class="keyword">if</span> (tree == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Create Node Failed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (data &lt; tree-&gt;data)<span class="comment">//如果要插入的数值比根节点的值要小，那么就插入到其左子树中</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 然后递归调用插入方法，直到找到一个空节点再插入！</span></span><br><span class="line">        tree-&gt;leftChild = insertIntoAVLTree(tree-&gt;leftChild,data);</span><br><span class="line">        <span class="comment">// 由于是插入到左子树中，因此只可能是左子树的高度大于右子树的高度</span></span><br><span class="line">        <span class="keyword">if</span> (getHeightOfNode(tree-&gt;leftChild) - getHeightOfNode(tree-&gt;rightChild) == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果需要插入的值根节点的左子树还要小那么说明插入到了左子树的左侧，那就可以判断此时的不平衡状态为左左LL，调用LL旋转即可</span></span><br><span class="line">            <span class="keyword">if</span> (data &lt; tree-&gt;leftChild-&gt;data)</span><br><span class="line">            &#123;</span><br><span class="line">                tree-&gt;leftChild = leftLeftRotation(tree-&gt;leftChild);</span><br><span class="line">            &#125;<span class="keyword">else</span>   <span class="comment">// 否则就说明大于这个节点的值，插入到在左子树的右儿子上，调用LR旋转</span></span><br><span class="line">            &#123;</span><br><span class="line">                tree-&gt;leftChild = leftRightRotation(tree-&gt;leftChild);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (data &gt; tree-&gt;data)</span><br><span class="line">    &#123;<span class="comment">//如果要插入的数值比根节点的值要大，那么就插入到其由子树中</span></span><br><span class="line">        tree-&gt;rightChild = insertIntoAVLTree(tree-&gt;rightChild,data);</span><br><span class="line">        <span class="keyword">if</span> (getHeightOfNode(tree-&gt;rightChild) - getHeightOfNode(tree-&gt;leftChild) == <span class="number">2</span>)<span class="comment">// 由于插入到右子树中那么就是只有可能右子树的高度大于左子树的高度</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (data &gt; tree-&gt;rightChild-&gt;data)</span><br><span class="line">            &#123;</span><br><span class="line">                tree-&gt;rightChild = rightRightRotation(tree-&gt;rightChild);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                tree-&gt;rightChild = rightLeftRotation(tree-&gt;rightChild);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Don't Insert The Same Node"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新根节点的高度</span></span><br><span class="line">    <span class="keyword">if</span> (((MAX(getHeightOfNode(tree-&gt;leftChild),getHeightOfNode(tree-&gt;rightChild))) == <span class="number">0</span>) &amp;&amp; (tree-&gt;leftChild != <span class="literal">NULL</span> || tree-&gt;rightChild != <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 其子节点全部都是叶子节点</span></span><br><span class="line">        <span class="comment">// 说明两个子树至少存在一个，那么这个根节点的高度就是1</span></span><br><span class="line">        tree-&gt;<span class="built_in">height</span> = <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (tree-&gt;leftChild == <span class="literal">NULL</span> &amp;&amp; tree-&gt;rightChild == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果两个子树都不存在那么说明这个节点就是叶子节点，直接返回就好</span></span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tree-&gt;<span class="built_in">height</span> = (MAX(getHeightOfNode(tree-&gt;leftChild),getHeightOfNode(tree-&gt;rightChild))) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *root = createAVLTreeNode(<span class="number">10</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    Node *left = createAVLTreeNode(<span class="number">6</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    Node *right = createAVLTreeNode(<span class="number">13</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    root-&gt;leftChild = left;</span><br><span class="line">    root-&gt;rightChild = right;</span><br><span class="line">    root = insertIntoAVLTree(root,<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 此时接着插入值为3的节点就会破坏AVL树的平衡条件</span></span><br><span class="line">    root = insertIntoAVLTree(root,<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello world!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="伸展树"><a href="#伸展树" class="headerlink" title="伸展树"></a>伸展树</h3><h3 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h3><p>B-树是为了磁盘存储而设计的一种<strong>多叉树</strong>，是多叉平衡查找树</p>
<h4 id="用阶数来定义B-树："><a href="#用阶数来定义B-树：" class="headerlink" title="用阶数来定义B-树："></a>用阶数来定义B-树：</h4><p>B 树又叫平衡多路查找树。一棵m阶的B 树具有以下性质：</p>
<ol>
<li><p>每个节点的子节点个数为<br>$$<br>M/2 ≤ N ≤ M<br>$$</p>
</li>
<li><p>并且B树的全部叶子节点在同一高度上</p>
</li>
<li><p>根节点至少有两个子树</p>
</li>
<li><p>由$N$ 个子树的节点一定含有$N-1$个关键字</p>
</li>
<li><p><code>Ki (i=1...n)</code>为关键字，且关键字按顺序升序排序<code>K(i-1)&lt; Ki</code>。 </p>
</li>
<li><p><code>Pi</code>为指向子树根的接点，且指针<code>P(i-1)</code>指向子树中所有结点的关键字均小于<code>Ki</code>，但都大于<code>K(i-1)</code>。–指针域的定义</p>
</li>
</ol>
<h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><p>先序遍历，后序遍历。其中的前/后都是儿子节点相对于父节点而言的！</p>
<ul>
<li>先序遍历：对根节点的处理在儿子节点的处理之前</li>
<li>后序遍历：对儿子节点的处理在根节点的处理之前</li>
<li>中序遍历：先遍历左子树再遍历根节点最后遍历右子树。可以生成自然的中缀表达式</li>
</ul>
<p>树中很重要的一个思想就是递归，因为树，树的子节点，等等结构都是相似的，因此同一种规律/算法就可以不断的反复套用。在遍历，插入，增删查改中都会用到递归的思想。</p>
<h2 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h2><h3 id="散列的定义"><a href="#散列的定义" class="headerlink" title="散列的定义"></a>散列的定义</h3><p>散列表的实现被称为<strong>散列</strong>（Hashing）</p>
<p>散列是一种以常熟平均时间执行插入删除查找的技术。但是散列表中的元素之间的排列顺序是随机的，因此是无法通过线性时间来打印散列表</p>
<p><strong>散列函数</strong>：其作用就是将关键字尽可能合适的映射到不同的存储单元中去。</p>
<p>但是毫无疑问，由于存储单元的数目是有限的而关键字的个数是无穷的，在后期的散列分配映射过程中肯定会遇到冲突现象，因此需要解决冲突。</p>
<p>当关键字是整数时，可以通过对单元个数取模来实现散列函数的确定，但是如果散列表的大小为10，而关键字多是以0结尾，那么这种情况下散列分配的结果就不够理想，因此，在设计散列表的大小时应该尽量采用素数大小！</p>
<h3 id="解决散列冲突问题"><a href="#解决散列冲突问题" class="headerlink" title="解决散列冲突问题"></a>解决散列冲突问题</h3><p>如果当一个元素被插入时另一个元素已经存在，即两个元素的散列值相同，那么就会产生一个冲突！</p>
<h4 id="分离链接法"><a href="#分离链接法" class="headerlink" title="分离链接法"></a>分离链接法</h4><p>分离链接法的做法是将散列到同一个散列值的所有元素都保留到一个表中，并且这些表都有表头，如果空间较为局促，那也可以不使用表头</p>
<img src="https://img.tanknee.cn/img/20191123202857.png"/>

<p><strong>填装因子</strong>$λ$为散列表中的元素个数与散列表大小的比值</p>
<ul>
<li>装填因子Load factor $λ$=元素个数<strong>/</strong>哈希表的大小=链表的平均长度</li>
<li>输入规模的大小不用N，而用<em>λ</em></li>
</ul>
<ol>
<li>平均情况分析（<em>λ</em>=O(1),O(1)）<ul>
<li>不成功的查找: <em>λ</em> 次比较（ 1+<em>λ</em> ）</li>
<li>成功查找：1+<em>λ</em>/2（ 1+<em>λ</em> ）</li>
<li>插入：1+<em>λ</em></li>
<li>删除：1+<em>λ</em>/2（ 1+<em>λ</em> ）</li>
</ul>
</li>
<li>最坏情况分析(<em>λ</em>=O(N),所有元素哈希到同一链表，O(N))<ul>
<li>不成功的查找</li>
<li>成功查找</li>
<li>插入</li>
<li>删除</li>
</ul>
</li>
</ol>
<p>分离链接法的一般法则是使得表的大小尽量与预料的元素个数差不多，即尽量让$λ≈1$,是表的大小尽量是一个素数，且各个冲突处理链表尽可能短。</p>
<p>缺点是分离链接法浪费了大量时间在分配内存空间上。</p>
<h4 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h4><p>在开放定址法中，不使用指针，而是用了另一种方式，它在遇到冲突时，选择在散列表中寻找其他没有被使用的单元，直到选中了空单元才停止。<br>$$<br>h_i(X) = (Hash(X)+F(i)) \mod TableSize<br>$$<br>因此开放定址法的空间需求相对分离链接法要更大一般而言$λ≤0.5$。</p>
<h5 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h5><p>在线性探测法中，函数F是i的线性函数，即F的最高次数为1次，典型情况为<br>$$<br>F(i) = i<br>$$<br>这相当于逐个探测每个散列表单元，并且必要时可以返回循环遍历整个散列表直到查到一个可用的空单元。</p>
<img src="https://img.tanknee.cn/img/98142ddfb49eb8bd6e16a0048314a26.jpg"/>

<p>容易看出，如果插入的关键字的散列结果较为接近，那么就会出现一次聚集现象。</p>
<p>如果表有超过一半可以被使用的话，那么线性探测法就是一个较好的办法，然而如果$λ = 0.5$，那么平均插入操作只需要探测2.5次，而对于成功的操作只需要探测1.5次。因此我们在使用线性探测法使应该尽量使填充因子小于0.5！</p>
<h5 id="平方探测法"><a href="#平方探测法" class="headerlink" title="平方探测法"></a>平方探测法</h5><p>该方式是消除线性探测法中一次聚集问题的冲突解决办法。平方探测法的冲突函数是二次函数，其较为主流的选择为<br>$$<br>F(i) = i^2<br>$$<br><img src="https://img.tanknee.cn/img/b8bc2d6c07c5ccf509c04dcf381899e.jpg"/></p>
<p><strong>规律</strong>：使用平方探测法，当表有一半是空的时，并且表的大小为素数，那么我们总能保证此时可以插入一个新的元素。</p>
<p>在开放定址散列表中，标准的删除操作是无法施行的，因为相应的单元可能已经发生了冲突，其元素已经被挪到了其他位置上了。</p>
<h2 id="优先队列-堆"><a href="#优先队列-堆" class="headerlink" title="优先队列-堆"></a>优先队列-堆</h2><p>在传统的队列结构<code>Queue</code>中，各个元素都是没有指定的优先级的，都遵循严格的先入先出原则，但是这样的原则并不是永远都是合适的，当我们遇到了CPU处理事件的类似问题时，就会出现优先级的考虑，优先级相对较高的问题应该更快更早被考虑和解决。</p>
<p>因此为了应对这个需求，我们更不应该直接使用线性结构–数组，因为如果使用数组的话最坏情况可能会达到$O(N)$,也就是需要出队的那个元素在最末尾，我们需要多次比较才能找到那个元素！于是我们应该采用二叉堆。</p>
<h3 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h3><p>二叉堆又有最大堆与最小堆的不同类型。其分别对应了最大优先队列和最小优先队列。</p>
<p>二叉堆是一颗被完全填满的二叉树，但是并不是完全二叉树，它在最底层是有可能存在没有完全放满叶子的情况，因此一颗高度为<code>h</code>的二叉树，它的总结点数应该为：2<sup>h</sup>到2<sup>h+1</sup>-1​</p>
<p>并且如果用数组来存储二叉堆，其根节点与子节点有这样的性质：</p>
<ul>
<li>如果根节点为<code>i</code>，那么它的左儿子的下标就是<code>2*i+1</code>右儿子的下标就是<code>2*i+2</code></li>
<li>下标为<code>length/2 -1</code>的堆元素肯定存在有左儿子</li>
</ul>
<h4 id="二叉堆的构造"><a href="#二叉堆的构造" class="headerlink" title="二叉堆的构造"></a>二叉堆的构造</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapAdjust</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> root,<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 以 root节点为根节点，遍历这个长度为length的数组，判断其是否满足大顶堆的要求，而且我们只需要判断根节点和其两个子节点是否满足就好了，其他的事情交给循环来做</span></span><br><span class="line">       <span class="comment">//这里放一个length是为了保证访问数组的时候不会越界</span></span><br><span class="line">       <span class="keyword">int</span> child;  <span class="comment">// 子节点的值</span></span><br><span class="line">       <span class="keyword">int</span> father; <span class="comment">// 父节点的值</span></span><br><span class="line">       <span class="keyword">for</span>(father = arr[root];<span class="number">2</span>*root+<span class="number">1</span> &lt; length;root = child)&#123;</span><br><span class="line">           <span class="comment">//只要它的左儿子是存在的，那么就开始构造/重构堆</span></span><br><span class="line">           child = <span class="number">2</span>*root+<span class="number">1</span>; <span class="comment">// 以root节点为根节点的左子树的下标</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">// 如果这个根节点的左子树不是这个堆的最后一个元素并且左子树小于右子树。那么就把下标指向右子树</span></span><br><span class="line">           <span class="comment">// 因为小的元素要下沉就必须要跟两个子树中较大的那个进行交换，否则如果跟较小的节点进行交换的话可能还需要交换两次！</span></span><br><span class="line">           <span class="keyword">if</span> (child != length-<span class="number">1</span> &amp;&amp; arr[child] &lt; arr[child+<span class="number">1</span>]) &#123;</span><br><span class="line">               child++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 如果此时的父节点小于子树中的那个较大者，就与之交换！</span></span><br><span class="line">           <span class="keyword">if</span> (father &lt; arr[child]) &#123;</span><br><span class="line">               arr[root] = arr[child]; <span class="comment">// 父节点的原有值已经记录在father这个变量内了！</span></span><br><span class="line">               <span class="comment">//交换之后还需要接着对这个以儿子节点为根节点的子树进行堆判断，也就是进入下一个循环</span></span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="comment">// 说明该节点符合大顶堆的标准，退出for循环</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 由于当前下标为root的节点值可能是废弃的，即已经被交换过，所以这个节点位置的应有值是该移动节点的值，即最初始的父节点</span></span><br><span class="line">       arr[root] = father;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="二叉堆的插入算法"><a href="#二叉堆的插入算法" class="headerlink" title="二叉堆的插入算法"></a>二叉堆的插入算法</h4><img src="https://img.tanknee.cn/img/20191125162336.png"/>

<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 插入排序的主要思想是排过序的前一部分是永远有序的，只需要将当前元素放置到正确位置就好</span></span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++)<span class="comment">//可以选择直接从第一个元素开始</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp = A[i];</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; A[j<span class="number">-1</span>] &gt; temp; j--)<span class="comment">// 第一个j=i的元素是还没有被排序的待排元素！所以要从第i-1个元素开始排序</span></span><br><span class="line">        &#123;</span><br><span class="line">            A[j] = A[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 退出上一个循环的原因要么是找到了该放的正确位置，要么是到了数组的第一位。</span></span><br><span class="line">        <span class="comment">// 但是不管是那种情况，此时j就是正确位置的下标！</span></span><br><span class="line">        A[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="comment">// int A[5] = &#123;7,6,5,9,3&#125;;</span></span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> increment = length/<span class="number">2</span>; increment &gt; <span class="number">0</span>; increment /= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = increment; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = A[i];</span><br><span class="line">            <span class="comment">// 从下标为increment 的元素开始，由于每次的间隔已知，且开头已知，那么由后向前找较为的方便</span></span><br><span class="line">            <span class="comment">// 确保每个元素在这个增量间隔序列中的位置是正确的！</span></span><br><span class="line">            <span class="keyword">for</span> (j = i; j &gt;= increment; j -= increment)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp &lt; A[j - increment])</span><br><span class="line">                &#123;</span><br><span class="line">                    A[j] = A[j - increment];</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            A[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123; <span class="number">50</span>, <span class="number">10</span>, <span class="number">90</span>, <span class="number">30</span>, <span class="number">70</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">60</span>, <span class="number">20</span> &#125;;</span><br><span class="line">		System.out.println(<span class="string">"排序之前："</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			System.out.print(arr[i] + <span class="string">" "</span>);</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">// 堆排序</span></span><br><span class="line">		heapSort(arr);</span><br><span class="line"> </span><br><span class="line">		System.out.println();</span><br><span class="line">		System.out.println(<span class="string">"排序之后："</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			System.out.print(arr[i] + <span class="string">" "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Create a big top heap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length/<span class="number">2</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            heapAdjust(arr, i, arr.length);<span class="comment">//从中间到开头的所有元素都进行堆的标准判断，确保生成一个完整的堆</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将堆顶最大的那个元素和后面的元素进行交换，然后再生成大顶堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 交换堆顶和队列中最后一个元素的值</span></span><br><span class="line">            exchange(arr, <span class="number">0</span>, i);</span><br><span class="line">            <span class="comment">// 判断这个队列是否能构成大顶堆不能的话就调整</span></span><br><span class="line">            <span class="comment">// 这里调整的实质是：只有堆顶一个元素需要调整，因此只需要将堆顶的元素下沉到相应的位置就好了不需要调整太多元素！！</span></span><br><span class="line">            heapAdjust(arr, <span class="number">0</span>, i);<span class="comment">//只排序前i个元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapAdjust</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> root,<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 以 root节点为根节点，遍历这个长度为length的数组，判断其是否满足大顶堆的要求，而且我们只需要判断根节点和其两个子节点是否满足就好了，其他的事情交给循环来做</span></span><br><span class="line">        <span class="comment">//这里放一个length是为了保证访问数组的时候不会越界</span></span><br><span class="line">        <span class="keyword">int</span> child;  <span class="comment">// 子节点的值</span></span><br><span class="line">        <span class="keyword">int</span> father; <span class="comment">// 父节点的值</span></span><br><span class="line">        <span class="keyword">for</span>(father = arr[root];<span class="number">2</span>*root+<span class="number">1</span> &lt; length;root = child)&#123;</span><br><span class="line">            <span class="comment">//只要它的左儿子是存在的，那么就开始构造/重构堆</span></span><br><span class="line">            child = <span class="number">2</span>*root+<span class="number">1</span>; <span class="comment">// 以root节点为根节点的左子树的下标</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果这个根节点的左子树不是这个堆的最后一个元素并且左子树小于右子树。那么就把下标指向右子树</span></span><br><span class="line">            <span class="comment">// 因为小的元素要下沉就必须要跟两个子树中较大的那个进行交换，否则如果跟较小的节点进行交换的话可能还需要交换两次！</span></span><br><span class="line">            <span class="keyword">if</span> (child != length-<span class="number">1</span> &amp;&amp; arr[child] &lt; arr[child+<span class="number">1</span>]) &#123;</span><br><span class="line">                child++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果此时的父节点小于子树中的那个较大者，就与之交换！</span></span><br><span class="line">            <span class="keyword">if</span> (father &lt; arr[child]) &#123;</span><br><span class="line">                arr[root] = arr[child]; <span class="comment">// 父节点的原有值已经记录在father这个变量内了！</span></span><br><span class="line">                <span class="comment">//交换之后还需要接着对这个以儿子节点为根节点的子树进行堆判断，也就是进入下一个循环</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 说明该节点符合大顶堆的标准，退出for循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 由于当前下标为root的节点值可能是废弃的，即已经被交换过，所以这个节点位置的应有值是该移动节点的值，即最初始的父节点</span></span><br><span class="line">        arr[root] = father;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> began,<span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[began];</span><br><span class="line">        arr[began] = arr[end];</span><br><span class="line">        arr[end] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Max_ 10</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 归并排序中的合并算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> left, <span class="keyword">int</span> m, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> aux[Max_] = &#123;<span class="number">0</span>&#125;;  <span class="comment">// 临时数组 （若不使用临时数组，将两个有序数组合并为一个有序数组比较麻烦）</span></span><br><span class="line">    <span class="keyword">int</span> i; <span class="comment">//第一个数组索引</span></span><br><span class="line">    <span class="keyword">int</span> j; <span class="comment">//第二个数组索引</span></span><br><span class="line">    <span class="keyword">int</span> k; <span class="comment">//临时数组索引</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = left, j = m+<span class="number">1</span>, k = <span class="number">0</span>; k &lt;= right-left; k++) <span class="comment">// 分别将 i, j, k 指向各自数组的首部。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//若 i 到达第一个数组的尾部，将第二个数组余下元素复制到 临时数组中</span></span><br><span class="line">        <span class="keyword">if</span> (i == m+<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            aux[k] = <span class="built_in">array</span>[j++];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若 j 到达第二个数组的尾部，将第一个数组余下元素复制到 临时数组中</span></span><br><span class="line">        <span class="keyword">if</span> (j == right+<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            aux[k] = <span class="built_in">array</span>[i++];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果第一个数组的当前元素 比 第二个数组的当前元素小，将 第一个数组的当前元素复制到 临时数组中</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[i] &lt; <span class="built_in">array</span>[j])</span><br><span class="line">        &#123;</span><br><span class="line">            aux[k] = <span class="built_in">array</span>[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果第二个数组的当前元素 比 第一个数组的当前元素小，将 第二个数组的当前元素复制到 临时数组中</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            aux[k] = <span class="built_in">array</span>[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将有序的临时数组 元素 刷回 被排序的数组 array 中，</span></span><br><span class="line">    <span class="comment">//i = left , 被排序的数组array 的起始位置</span></span><br><span class="line">    <span class="comment">//j = 0， 临时数组的起始位置</span></span><br><span class="line">    <span class="keyword">for</span> (i = left, j = <span class="number">0</span>; i &lt;= right; i++, j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">array</span>[i] = aux[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先拆分，直到拆分到最小部分才结束，也就是只剩下一个元素的时候开始递归返回</span></span><br><span class="line">    <span class="comment">// 排序是在合并的时候发生的，通过下标来控制拆分后的元素位置，然后将需要排序的元素输出到临时数组中，最后重新覆盖原始数组中的元素列</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="built_in">end</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        i = (<span class="built_in">end</span> + start) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 对前半部分进行排序</span></span><br><span class="line">        MergeSort(<span class="built_in">array</span>, start, i);</span><br><span class="line">        <span class="comment">// 对后半部分进行排序</span></span><br><span class="line">        MergeSort(<span class="built_in">array</span>, i + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line">        <span class="comment">// 合并前后两部分</span></span><br><span class="line">        Merge(<span class="built_in">array</span>, start, i, <span class="built_in">end</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">//测试数据</span></span><br><span class="line">    <span class="keyword">int</span> arr_test[Max_] = &#123; <span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">7</span> &#125;;</span><br><span class="line">    MergeSort( arr_test, <span class="number">0</span>, Max_<span class="number">-1</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快排的核心思想就是哨兵，通过两个pivot来实现将所给的数组中的所有元素排序(大致排序，只按照与标兵的大小比较)，最后哨兵会和的时候就是标兵元素的正确存放地址，此时左边为小于标兵的元素，右边是大于标兵的元素。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/*****************************************************</span></span><br><span class="line"><span class="comment">File name：Quicksort</span></span><br><span class="line"><span class="comment">Author：Zhengqijun    Version:1.0    Date: 2016/11/04</span></span><br><span class="line"><span class="comment">Description: 对数组进行快速排序</span></span><br><span class="line"><span class="comment">Funcion List: 实现快速排序算法</span></span><br><span class="line"><span class="comment">*****************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************</span></span><br><span class="line"><span class="comment"> *函数名：display</span></span><br><span class="line"><span class="comment"> *作用：打印数组元素</span></span><br><span class="line"><span class="comment"> *参数：array - 打印的数组，maxlen - 数组元素个数</span></span><br><span class="line"><span class="comment"> *返回值：无</span></span><br><span class="line"><span class="comment"> **************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> maxlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; maxlen; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%-3d"</span>, <span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************</span></span><br><span class="line"><span class="comment"> *函数名：QuickSort</span></span><br><span class="line"><span class="comment"> *作用：快速排序算法</span></span><br><span class="line"><span class="comment"> *参数：</span></span><br><span class="line"><span class="comment"> *返回值：无</span></span><br><span class="line"><span class="comment"> ************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = low;</span><br><span class="line">        <span class="keyword">int</span> j = high;</span><br><span class="line">        <span class="keyword">int</span> k = arr[low];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 此时的K就是这次快速排序的基准值</span></span><br><span class="line">            <span class="comment">// 通过不断地左右探测，找到大于k的放在右边，小于k的放在左边。</span></span><br><span class="line">            <span class="comment">// 每次只找到第一个大于或者小于k的数，然后直接交换，再去寻找另一边的元素</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= k) <span class="comment">// 从右向左找第一个小于k的数</span></span><br><span class="line">            &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &lt; j)<span class="comment">// 确保上面的循环是因为arr[i] &lt; k而退出的也就是找到了第一个小于k的数</span></span><br><span class="line">            &#123;</span><br><span class="line">                arr[i++] = arr[j];<span class="comment">//然后把这个数放入到arr[i]中</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt; k) <span class="comment">// 从左向右找第一个大于等于k的数</span></span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">            &#123;</span><br><span class="line">                arr[j--] = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">// 当i == j时就是k应该放的位置。</span></span><br><span class="line">        <span class="comment">// 此时左边全部都是小于k的元素，因为所有大于k的元素都被交换到当时k所在的位置了，所有大于k的元素都被放到右侧了</span></span><br><span class="line"></span><br><span class="line">        arr[i] = k;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归调用</span></span><br><span class="line">        QuickSort(arr, low, i );  <span class="comment">// 排序k左边。排序当前数组的最低位到i位</span></span><br><span class="line">        QuickSort(arr, i + <span class="number">1</span>, high); <span class="comment">// 排序k右边，排序当前数组i之后的所有元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[BUF_SIZE] = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4564</span>,<span class="number">2345</span>,<span class="number">11</span>,<span class="number">23</span>,<span class="number">3423</span>,<span class="number">4352</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> maxlen = BUF_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"排序前的数组\n"</span>);</span><br><span class="line">    <span class="built_in">display</span>(<span class="built_in">array</span>, maxlen);</span><br><span class="line"></span><br><span class="line">    QuickSort(<span class="built_in">array</span>, <span class="number">0</span>, maxlen - <span class="number">1</span>); <span class="comment">// 快速排序</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"排序后的数组\n"</span>);</span><br><span class="line">    <span class="built_in">display</span>(<span class="built_in">array</span>, maxlen);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="桶式排序"><a href="#桶式排序" class="headerlink" title="桶式排序"></a>桶式排序</h3><p>桶排的原理就是归类！基数排序也是类似的原理。直接将元素放入到以该元素的数值为下标的数组单元中，不过实际操作时数组单元记录的是相同大小元素的个数！而在打印的时候只需要将<strong>数组下标</strong>打印<strong>数组元素值</strong>次就好了。</p>
<h4 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 桶排序</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> A</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bucketSort(<span class="keyword">int</span>[] A, <span class="keyword">int</span> max) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] B = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>];<span class="comment">// 0-max 总共max+1个数</span></span><br><span class="line">        <span class="keyword">int</span>[] reArray = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            B[A[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; B.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= B[i]; j++) &#123;</span><br><span class="line">                <span class="comment">// i 是被排序的数的大小 B[i] 是大小为i的被排序数的个数</span></span><br><span class="line">                reArray[k] = i;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reArray;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="C语言实现："><a href="#C语言实现：" class="headerlink" title="C语言实现："></a>C语言实现：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> length,<span class="keyword">int</span> <span class="built_in">max</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> B[<span class="built_in">max</span>+<span class="number">1</span>];<span class="comment">// 根据A中元素的最大值来确定B的元素个数</span></span><br><span class="line">    <span class="built_in">memset</span>(B,<span class="number">0</span>,(<span class="built_in">max</span>+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">//使用memset时记得引用string.h头文件</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length;i++)&#123;</span><br><span class="line">        B[A[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">max</span>+<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= B[i]; j++) &#123;</span><br><span class="line">            <span class="comment">// i 是被排序的数的大小 B[i] 是大小为i的被排序数的个数</span></span><br><span class="line">            A[k] = i;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h3><h3 id="排序分析"><a href="#排序分析" class="headerlink" title="排序分析"></a>排序分析</h3><img src="https://img.tanknee.cn/img/20191125222652.png"/>

<h2 id="图论算法"><a href="#图论算法" class="headerlink" title="图论算法"></a>图论算法</h2><p>图由顶点和边组成，一个图中也包含很多条边和很多个顶点。</p>
<p>根据边是否有向，可以将图分为<strong>有向图</strong>与<strong>无向图</strong>。</p>
<h3 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h3><img src="https://img.tanknee.cn/img/20191125165904.png"/>

<p>图有两种表示形式：<strong>邻接数组</strong>和<strong>邻接表</strong>。</p>
<h4 id="前者是用二维数组来实现图："><a href="#前者是用二维数组来实现图：" class="headerlink" title="前者是用二维数组来实现图："></a>前者是用<strong>二维数组</strong>来实现图：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Graph[Vertex1][Vertex2] = weight</span><br></pre></td></tr></table></figure>

<p>其中数组的两个下标为这条边的两个顶点，其中存储的值为这条边的权重</p>
<h4 id="后者是用链表的方式来实现图："><a href="#后者是用链表的方式来实现图：" class="headerlink" title="后者是用链表的方式来实现图："></a>后者是用<strong>链表</strong>的方式来实现图：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 5</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ENode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> index;                 <span class="comment">// 该边的顶点的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ENode</span> *<span class="title">nextEdge</span>;</span> <span class="comment">// 指向下一条弧的指针</span></span><br><span class="line">&#125; ENode, *PENode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接表中表的顶点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">VNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> index;          <span class="comment">// 顶点信息</span></span><br><span class="line">    ENode *firstEdge; <span class="comment">// 指向第一条依附该顶点的弧</span></span><br><span class="line">&#125; VNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LGraph</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> vexNum; <span class="comment">// 图的顶点的数目</span></span><br><span class="line">    <span class="keyword">int</span> edgNum; <span class="comment">// 图的边的数目</span></span><br><span class="line">    VNode vexs[MAX];</span><br><span class="line">&#125; LGraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 边的数据</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> start; <span class="comment">// 起始顶点</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">end</span>;   <span class="comment">// 结束顶点</span></span><br><span class="line">&#125; EData;</span><br><span class="line"><span class="keyword">static</span> EData gData[] = &#123;<span class="comment">//硬编码的图的数据</span></span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>, <span class="number">5</span>&#125;,</span><br><span class="line">    &#123;<span class="number">3</span>, <span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkToTheEnd</span><span class="params">(ENode *<span class="built_in">list</span>, ENode *node)</span></span>&#123;</span><br><span class="line">    ENode *p = <span class="built_in">list</span>;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;nextEdge)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;nextEdge;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;nextEdge = node;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建一张图</span></span><br><span class="line"><span class="function">LGraph *<span class="title">createLinkedGraph</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ENode *node;</span><br><span class="line">    LGraph *pG;</span><br><span class="line">    <span class="keyword">int</span> start,<span class="built_in">end</span>;</span><br><span class="line">    <span class="keyword">if</span> ((pG = (LGraph *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LGraph))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">memset</span>(pG, <span class="number">0</span>, <span class="keyword">sizeof</span>(LGraph));</span><br><span class="line">    pG-&gt;vexNum = MAX;</span><br><span class="line">    pG-&gt;edgNum = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pG-&gt;vexNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pG-&gt;vexs[i].index = i;</span><br><span class="line">        pG-&gt;vexs[i].firstEdge = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化"邻接表"的边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pG-&gt;edgNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读取边的起始顶点,结束顶点</span></span><br><span class="line">        start = gData[i].start;</span><br><span class="line">        <span class="built_in">end</span> = gData[i].<span class="built_in">end</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化node1</span></span><br><span class="line">        node = (ENode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ENode));</span><br><span class="line">        <span class="built_in">memset</span>(node,<span class="number">0</span>,<span class="keyword">sizeof</span>(ENode));</span><br><span class="line">        node-&gt;index = <span class="built_in">end</span>;</span><br><span class="line">        <span class="comment">// 将node1链接到"p1所在链表的末尾"</span></span><br><span class="line">        <span class="keyword">if</span> (pG-&gt;vexs[start].firstEdge == <span class="literal">NULL</span>)</span><br><span class="line">            pG-&gt;vexs[start].firstEdge = node;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            LinkToTheEnd(pG-&gt;vexs[start].firstEdge, node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pG;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LGraph *g;</span><br><span class="line">    g = createLinkedGraph();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>拓扑排序的核心还是图的构建以及入度数组的维护。</p>
<p>只要每次都找出入度为0的顶点，然后将其输出，再更新入度数组就可以找出图的拓扑排序方式了！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 5</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ENode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> index;                 <span class="comment">// 该边的顶点的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ENode</span> *<span class="title">nextEdge</span>;</span> <span class="comment">// 指向下一条弧的指针</span></span><br><span class="line">&#125; ENode, *PENode;<span class="comment">// _ENode 的变量别名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接表中表的顶点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">VNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> index;          <span class="comment">// 顶点信息</span></span><br><span class="line">    ENode *firstEdge; <span class="comment">// 指向第一条依附该顶点的弧</span></span><br><span class="line">&#125; VNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LGraph</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> vexNum; <span class="comment">// 图的顶点的数目</span></span><br><span class="line">    <span class="keyword">int</span> edgNum; <span class="comment">// 图的边的数目</span></span><br><span class="line">    VNode vexs[MAX];</span><br><span class="line">&#125; LGraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 边的数据</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> start; <span class="comment">// 起始顶点</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">end</span>;   <span class="comment">// 结束顶点</span></span><br><span class="line">&#125; EData;</span><br><span class="line"><span class="keyword">static</span> EData gData[] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>, <span class="number">4</span>&#125;,</span><br><span class="line">    &#123;<span class="number">3</span>, <span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkToTheEnd</span><span class="params">(ENode *<span class="built_in">list</span>, ENode *node)</span></span>&#123;</span><br><span class="line">    ENode *p = <span class="built_in">list</span>;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;nextEdge)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;nextEdge;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;nextEdge = node;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建一张图</span></span><br><span class="line"><span class="function">LGraph *<span class="title">createLinkedGraph</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ENode *node;</span><br><span class="line">    LGraph *pG;</span><br><span class="line">    <span class="keyword">int</span> start,<span class="built_in">end</span>;</span><br><span class="line">    <span class="keyword">if</span> ((pG = (LGraph *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LGraph))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">memset</span>(pG, <span class="number">0</span>, <span class="keyword">sizeof</span>(LGraph));</span><br><span class="line">    pG-&gt;vexNum = MAX;</span><br><span class="line">    pG-&gt;edgNum = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pG-&gt;vexNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pG-&gt;vexs[i].index = i;</span><br><span class="line">        pG-&gt;vexs[i].firstEdge = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化"邻接表"的边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pG-&gt;edgNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读取边的起始顶点,结束顶点</span></span><br><span class="line">        start = gData[i].start;</span><br><span class="line">        <span class="built_in">end</span> = gData[i].<span class="built_in">end</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化node1</span></span><br><span class="line">        node = (ENode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ENode));</span><br><span class="line">        <span class="built_in">memset</span>(node,<span class="number">0</span>,<span class="keyword">sizeof</span>(ENode));</span><br><span class="line">        node-&gt;index = <span class="built_in">end</span>;</span><br><span class="line">        <span class="comment">// 将node1链接到"p1所在链表的末尾"</span></span><br><span class="line">        <span class="keyword">if</span> (pG-&gt;vexs[start].firstEdge == <span class="literal">NULL</span>)</span><br><span class="line">            pG-&gt;vexs[start].firstEdge = node;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            LinkToTheEnd(pG-&gt;vexs[start].firstEdge, node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pG;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取图的出度数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createInDegree</span><span class="params">(LGraph *g,<span class="keyword">int</span> InDegree[])</span></span>&#123;</span><br><span class="line">    ENode *p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g-&gt;vexNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = g-&gt;vexs[i].firstEdge;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (p)</span><br><span class="line">        &#123;</span><br><span class="line">            InDegree[p-&gt;index]++;</span><br><span class="line">            p = p-&gt;nextEdge;   </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新维护入度数组</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * g    图指针</span></span><br><span class="line"><span class="comment"> * InDegree 入度数组</span></span><br><span class="line"><span class="comment"> * node 需要改变的节点指针</span></span><br><span class="line"><span class="comment"> * 删除节点后把它在入度数组中置为-1</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateInDegree</span><span class="params">(LGraph *g,<span class="keyword">int</span> InDegree[],<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    InDegree[index] = <span class="number">-1</span>;</span><br><span class="line">    ENode *p;</span><br><span class="line">    p = g-&gt;vexs[index].firstEdge;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        InDegree[p-&gt;index]--;</span><br><span class="line">        p = p-&gt;nextEdge;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TopologicalSort 拓扑排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TopologicalSort</span><span class="params">(LGraph *g)</span></span>&#123;</span><br><span class="line">    ENode *node;</span><br><span class="line">    <span class="keyword">int</span> InDegree[g-&gt;vexNum];</span><br><span class="line">    <span class="built_in">memset</span>(InDegree,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*g-&gt;vexNum);</span><br><span class="line">    createInDegree(g,InDegree);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g-&gt;vexNum; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (InDegree[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                j = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,j);</span><br><span class="line">        updateInDegree(g,InDegree,j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LGraph *g;</span><br><span class="line">    g = createLinkedGraph();</span><br><span class="line">    TopologicalSort(g);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><h4 id="图的搜索方法"><a href="#图的搜索方法" class="headerlink" title="图的搜索方法"></a>图的搜索方法</h4><ul>
<li><p>宽度优先BFS（breath-first-search）–队列实现</p>
<p>逐层遍历</p>
<p>访问节点v，再依次访问和v邻接的节点（或v的下一层节点）</p>
</li>
<li><p>深度优先DFS（depth-first-search）–堆栈实现：递归</p>
<p>先序遍历</p>
<p>访问节点v，对v的邻接节点递归DFS</p>
</li>
</ul>
<h4 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h4><p>求两个顶点间的最短路径，是一种贪婪算法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dijkstra</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义顶点Vertex类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Vertex</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> infinite_dis = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">private</span> String name;   <span class="comment">//节点名字</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> known;  <span class="comment">//此节点是否已知  </span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> adjuDist;   <span class="comment">//此节点距离  </span></span><br><span class="line">        <span class="keyword">private</span> Vertex parent;   <span class="comment">//当前从初始化节点到此节点的最短路径下的父亲节点</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Vertex</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.known = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">this</span>.adjuDist = infinite_dis;</span><br><span class="line">            <span class="keyword">this</span>.parent = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Vertex</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>();</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Vertex <span class="title">getParent</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParent</span><span class="params">(Vertex parent)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.getName() == ((Vertex)obj).getName()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.name == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name of Vertex to be compared cannot be null!"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span></span>&#123;</span><br><span class="line">        <span class="comment">//此有向边的起始点</span></span><br><span class="line">        <span class="keyword">private</span> Vertex startVertex;</span><br><span class="line">        <span class="comment">//此有向边的终点</span></span><br><span class="line">        <span class="keyword">private</span> Vertex endVertex;</span><br><span class="line">        <span class="comment">//此有向边的权值</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> weight;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(Vertex startVertex,Vertex endVertex,<span class="keyword">int</span> weight)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.startVertex = startVertex;</span><br><span class="line">            <span class="keyword">this</span>.endVertex = endVertex;</span><br><span class="line">            <span class="keyword">this</span>.weight = weight;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Vertex&gt; vertexList; <span class="comment">//图的顶点集</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Vertex,List&lt;Edge&gt; &gt; ver_edgeList_map;  <span class="comment">//图的每个顶点对应的有向边</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dijkstra</span><span class="params">(List&lt;Vertex&gt; vertexList, Map&lt;Vertex, List&lt;Edge&gt;&gt; ver_edgeList_map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vertexList = vertexList;</span><br><span class="line">        <span class="keyword">this</span>.ver_edgeList_map = ver_edgeList_map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(Vertex v)</span></span>&#123;</span><br><span class="line">        v.setParent(<span class="keyword">null</span>);</span><br><span class="line">        v.setAdjuDist(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateChildren</span><span class="params">(Vertex v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ver_edgeList_map.get(v)==<span class="keyword">null</span> || ver_edgeList_map.get(v).size()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Vertex&gt; childrenList = <span class="keyword">new</span> LinkedList&lt;Vertex&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Edge e:ver_edgeList_map.get(v))&#123;</span><br><span class="line">            Vertex childVertex = e.getEndVertex();</span><br><span class="line">            <span class="keyword">if</span> (!childVertex.isKnown())&#123;</span><br><span class="line">                childVertex.setKnown(<span class="keyword">true</span>);</span><br><span class="line">                childVertex.setAdjuDist(v.getAdjuDist()+e.getWeight());</span><br><span class="line">                childVertex.setParent(v);</span><br><span class="line">                childrenList.add(childVertex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> nowDist = v.getAdjuDist() + e.getWeight();</span><br><span class="line">            <span class="keyword">if</span> (nowDist &gt;= childVertex.getAdjuDist())&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                childVertex.setAdjuDist(nowDist);</span><br><span class="line">                childVertex.setParent(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Vertex vc:childrenList)&#123;</span><br><span class="line">            updateChildren(vc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dijkstraTravasal</span><span class="params">(<span class="keyword">int</span> startIndex,<span class="keyword">int</span> destIndex)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">            Vertex start = vertexList.get(startIndex);</span><br><span class="line">            Vertex dest  = vertexList.get(destIndex);</span><br><span class="line">            String path = <span class="string">"["</span> + dest.getName() + <span class="string">"]"</span>;</span><br><span class="line"></span><br><span class="line">            setRoot(start);</span><br><span class="line"></span><br><span class="line">            updateChildren(vertexList.get(startIndex));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> shortest_length = dest.getAdjuDist();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ((dest.getParent()!=<span class="keyword">null</span>)&amp;&amp;(!dest.equals(start)))&#123;</span><br><span class="line">                path = <span class="string">"["</span> + dest.getParent().getName() +<span class="string">"] --&gt; "</span>+path;</span><br><span class="line">                dest = dest.getParent();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"["</span>+vertexList.get(startIndex).getName()+<span class="string">"] to ["</span>+</span><br><span class="line">                vertexList.get(destIndex).getName()+<span class="string">"] dijkstra shortest path:: "</span>+path);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"shortest length::"</span> + shortest_length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Vertex v1= <span class="keyword">new</span> Vertex(<span class="string">"v1"</span>);</span><br><span class="line">        Vertex v2= <span class="keyword">new</span> Vertex(<span class="string">"v2"</span>);</span><br><span class="line">        Vertex v3= <span class="keyword">new</span> Vertex(<span class="string">"v3"</span>);</span><br><span class="line">        Vertex v4= <span class="keyword">new</span> Vertex(<span class="string">"v4"</span>);</span><br><span class="line">        Vertex v5= <span class="keyword">new</span> Vertex(<span class="string">"v5"</span>);</span><br><span class="line">        Vertex v6= <span class="keyword">new</span> Vertex(<span class="string">"v6"</span>);</span><br><span class="line">        Vertex v7= <span class="keyword">new</span> Vertex(<span class="string">"v7"</span>);</span><br><span class="line">        List&lt;Vertex&gt; verList = <span class="keyword">new</span> LinkedList&lt;Dijkstra.Vertex&gt;();</span><br><span class="line">        verList.add(v1);</span><br><span class="line">        verList.add(v2);</span><br><span class="line">        verList.add(v3);</span><br><span class="line">        verList.add(v4);</span><br><span class="line">        verList.add(v5);</span><br><span class="line">        verList.add(v6);</span><br><span class="line">        verList.add(v7);</span><br><span class="line"></span><br><span class="line">        Map&lt;Vertex, List&lt;Edge&gt;&gt; vertex_edgeList_map = <span class="keyword">new</span> HashMap&lt;Vertex, List&lt;Edge&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        List&lt;Edge&gt; v1List = <span class="keyword">new</span> LinkedList&lt;Dijkstra.Edge&gt;();</span><br><span class="line">        v1List.add(<span class="keyword">new</span> Edge(v1,v2,<span class="number">2</span>));</span><br><span class="line">        v1List.add(<span class="keyword">new</span> Edge(v1,v4,<span class="number">1</span>));</span><br><span class="line">        List&lt;Edge&gt; v2List = <span class="keyword">new</span> LinkedList&lt;Dijkstra.Edge&gt;();</span><br><span class="line">        v2List.add(<span class="keyword">new</span> Edge(v2,v4,<span class="number">3</span>));</span><br><span class="line">        v2List.add(<span class="keyword">new</span> Edge(v2,v5,<span class="number">10</span>));</span><br><span class="line">        List&lt;Edge&gt; v3List = <span class="keyword">new</span> LinkedList&lt;Dijkstra.Edge&gt;();</span><br><span class="line">        v3List.add(<span class="keyword">new</span> Edge(v3,v1,<span class="number">4</span>));</span><br><span class="line">        v3List.add(<span class="keyword">new</span> Edge(v3,v6,<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        List&lt;Edge&gt; v4List = <span class="keyword">new</span> LinkedList&lt;Dijkstra.Edge&gt;();</span><br><span class="line">        v4List.add(<span class="keyword">new</span> Edge(v4,v3,<span class="number">2</span>));</span><br><span class="line">        v4List.add(<span class="keyword">new</span> Edge(v4,v5,<span class="number">2</span>));</span><br><span class="line">        v4List.add(<span class="keyword">new</span> Edge(v4,v6,<span class="number">8</span>));</span><br><span class="line">        v4List.add(<span class="keyword">new</span> Edge(v4,v7,<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">        List&lt;Edge&gt; v5List = <span class="keyword">new</span> LinkedList&lt;Dijkstra.Edge&gt;();</span><br><span class="line">        v5List.add(<span class="keyword">new</span> Edge(v5,v7,<span class="number">6</span>));</span><br><span class="line"></span><br><span class="line">        List&lt;Edge&gt; v6List = <span class="keyword">new</span> LinkedList&lt;Dijkstra.Edge&gt;();</span><br><span class="line"></span><br><span class="line">        List&lt;Edge&gt; v7List = <span class="keyword">new</span> LinkedList&lt;Dijkstra.Edge&gt;();</span><br><span class="line">        v7List.add(<span class="keyword">new</span> Edge(v7,v6,<span class="number">1</span>));</span><br><span class="line">        vertex_edgeList_map.put(v1, v1List);</span><br><span class="line">        vertex_edgeList_map.put(v2, v2List);</span><br><span class="line">        vertex_edgeList_map.put(v3, v3List);</span><br><span class="line">        vertex_edgeList_map.put(v4, v4List);</span><br><span class="line">        vertex_edgeList_map.put(v5, v5List);</span><br><span class="line">        vertex_edgeList_map.put(v6, v6List);</span><br><span class="line">        vertex_edgeList_map.put(v7, v7List);</span><br><span class="line">        </span><br><span class="line">        Dijkstra g = <span class="keyword">new</span> Dijkstra(verList, vertex_edgeList_map);</span><br><span class="line">        g.dijkstraTravasal(<span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C语言实现Dijkstra算法：<a href="https://git.tanknee.cn/snippets/4" target="_blank" rel="noopener">Dijkstra</a></p>
<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><h4 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h4><p>求图的最小生成树</p>
<p>Prim算法选取新的一条边的原则是其中一个节点必须在已经选取的节点集合中，而另一个节点必须是为选取的节点。最终选定的边还必须要是全部满足条件的未选取边的权值最小值。也就是说prim算法选取的边必须是连续的，不可能是独立的一条边，因为其中的一个顶点必定是已知的。</p>
<img src="https://cdn.tanknee.cn/2019/11/201911274d163f08d9227.png"/>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prims</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> INF = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ENode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ivex;       <span class="comment">// 该边所指向的顶点的位置</span></span><br><span class="line">        <span class="keyword">int</span> weight;     <span class="comment">// 该边的权</span></span><br><span class="line">        ENode nextEdge; <span class="comment">// 指向下一条弧的指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">VNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> data;          </span><br><span class="line">        ENode firstEdge;    </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> VNode[] mVexs;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Prims</span><span class="params">(<span class="keyword">char</span>[] vexs, EData[] edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> vlen = vexs.length;</span><br><span class="line">        <span class="keyword">int</span> elen = edges.length;</span><br><span class="line">        mVexs = <span class="keyword">new</span> VNode[vlen];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mVexs.length; i++) &#123;</span><br><span class="line">            mVexs[i] = <span class="keyword">new</span> VNode();</span><br><span class="line">            mVexs[i].data = vexs[i];</span><br><span class="line">            mVexs[i].firstEdge = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化"边"</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elen; i++) &#123;</span><br><span class="line">            <span class="comment">// 读取边的起始顶点和结束顶点</span></span><br><span class="line">            <span class="keyword">char</span> c1 = edges[i].start;</span><br><span class="line">            <span class="keyword">char</span> c2 = edges[i].end;</span><br><span class="line">            <span class="keyword">int</span> weight = edges[i].weight;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取边的起始顶点和结束顶点</span></span><br><span class="line">            <span class="keyword">int</span> p1 = getPosition(c1);</span><br><span class="line">            <span class="keyword">int</span> p2 = getPosition(c2);</span><br><span class="line">            <span class="comment">// 初始化node1</span></span><br><span class="line">            ENode node1 = <span class="keyword">new</span> ENode();</span><br><span class="line">            node1.ivex = p2;</span><br><span class="line">            node1.weight = weight;</span><br><span class="line">            <span class="comment">// 将node1链接到"p1所在链表的末尾"</span></span><br><span class="line">            <span class="keyword">if</span>(mVexs[p1].firstEdge == <span class="keyword">null</span>)</span><br><span class="line">                mVexs[p1].firstEdge = node1;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                linkLast(mVexs[p1].firstEdge, node1);</span><br><span class="line">            <span class="comment">// 初始化node2</span></span><br><span class="line">            ENode node2 = <span class="keyword">new</span> ENode();</span><br><span class="line">            node2.ivex = p1;</span><br><span class="line">            node2.weight = weight;</span><br><span class="line">            <span class="comment">// 将node2链接到"p2所在链表的末尾"</span></span><br><span class="line">            <span class="keyword">if</span>(mVexs[p2].firstEdge == <span class="keyword">null</span>)</span><br><span class="line">                mVexs[p2].firstEdge = node2;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                linkLast(mVexs[p2].firstEdge, node2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(ENode list, ENode node)</span> </span>&#123;</span><br><span class="line">        ENode p = list;</span><br><span class="line">        <span class="keyword">while</span>(p.nextEdge!=<span class="keyword">null</span>)</span><br><span class="line">            p = p.nextEdge;</span><br><span class="line">        p.nextEdge = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getPosition</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mVexs.length; i++)</span><br><span class="line">            <span class="keyword">if</span>(mVexs[i].data==ch)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (start==end)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        ENode node = mVexs[start].firstEdge;</span><br><span class="line">        <span class="keyword">while</span> (node!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (end==node.ivex)</span><br><span class="line">                <span class="keyword">return</span> node.weight;</span><br><span class="line">            node = node.nextEdge;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> INF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prim</span><span class="params">(<span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min,i,j,k,m,n,tmp,sum;</span><br><span class="line">        <span class="keyword">int</span> num = mVexs.length;</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;                   <span class="comment">// prim最小树的索引，即prims数组的索引</span></span><br><span class="line">        <span class="keyword">char</span>[] prims = <span class="keyword">new</span> <span class="keyword">char</span>[num];  <span class="comment">// prim最小树的结果数组</span></span><br><span class="line">        <span class="keyword">int</span>[] weights = <span class="keyword">new</span> <span class="keyword">int</span>[num];  <span class="comment">// 顶点间边的权值</span></span><br><span class="line">        prims[index++] = mVexs[start].data;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++ )</span><br><span class="line">            weights[i] = getWeight(start, i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(start == i)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">            k = <span class="number">0</span>;</span><br><span class="line">            min = INF;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; num) &#123;</span><br><span class="line">                <span class="keyword">if</span> (weights[j] != <span class="number">0</span> &amp;&amp; weights[j] &lt; min) &#123;</span><br><span class="line">                    min = weights[j];</span><br><span class="line">                    k = j;</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            prims[index++] = mVexs[k].data;</span><br><span class="line">            weights[k] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; num; j++) &#123;</span><br><span class="line">                tmp = getWeight(k, j);</span><br><span class="line">                <span class="keyword">if</span> (weights[j] != <span class="number">0</span> &amp;&amp; tmp &lt; weights[j])</span><br><span class="line">                    weights[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; index; i++) &#123;</span><br><span class="line">            min = INF;</span><br><span class="line">            n = getPosition(prims[i]);</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                m = getPosition(prims[j]);</span><br><span class="line">                tmp = getWeight(m, n);</span><br><span class="line">                <span class="keyword">if</span> (tmp &lt; min)</span><br><span class="line">                    min = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += min;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">"PRIM(%c)=%d: "</span>, mVexs[start].data, sum);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            System.out.printf(<span class="string">"%c "</span>, prims[i]);</span><br><span class="line">        System.out.printf(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EData</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> start; <span class="comment">// 边的起点</span></span><br><span class="line">        <span class="keyword">char</span> end;   <span class="comment">// 边的终点</span></span><br><span class="line">        <span class="keyword">int</span> weight; <span class="comment">// 边的权重</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">EData</span><span class="params">(<span class="keyword">char</span> start, <span class="keyword">char</span> end, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">            <span class="keyword">this</span>.weight = weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">char</span>[] vexs = &#123;<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>&#125;;</span><br><span class="line">       EData[] edges = &#123;</span><br><span class="line">               <span class="keyword">new</span> EData(<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="number">12</span>),</span><br><span class="line">               <span class="keyword">new</span> EData(<span class="string">'A'</span>, <span class="string">'F'</span>, <span class="number">16</span>),</span><br><span class="line">               <span class="keyword">new</span> EData(<span class="string">'A'</span>, <span class="string">'G'</span>, <span class="number">14</span>),</span><br><span class="line">               <span class="keyword">new</span> EData(<span class="string">'B'</span>, <span class="string">'C'</span>, <span class="number">10</span>),</span><br><span class="line">               <span class="keyword">new</span> EData(<span class="string">'B'</span>, <span class="string">'F'</span>,  <span class="number">7</span>),</span><br><span class="line">               <span class="keyword">new</span> EData(<span class="string">'C'</span>, <span class="string">'D'</span>,  <span class="number">3</span>),</span><br><span class="line">               <span class="keyword">new</span> EData(<span class="string">'C'</span>, <span class="string">'E'</span>,  <span class="number">5</span>),</span><br><span class="line">               <span class="keyword">new</span> EData(<span class="string">'C'</span>, <span class="string">'F'</span>,  <span class="number">6</span>),</span><br><span class="line">               <span class="keyword">new</span> EData(<span class="string">'D'</span>, <span class="string">'E'</span>,  <span class="number">4</span>),</span><br><span class="line">               <span class="keyword">new</span> EData(<span class="string">'E'</span>, <span class="string">'F'</span>,  <span class="number">2</span>),</span><br><span class="line">               <span class="keyword">new</span> EData(<span class="string">'E'</span>, <span class="string">'G'</span>,  <span class="number">8</span>),</span><br><span class="line">               <span class="keyword">new</span> EData(<span class="string">'F'</span>, <span class="string">'G'</span>,  <span class="number">9</span>),</span><br><span class="line">       &#125;;</span><br><span class="line">       Prims pG;</span><br><span class="line">       pG = <span class="keyword">new</span> Prims(vexs, edges);</span><br><span class="line">       pG.prim(<span class="number">0</span>);   <span class="comment">// prim算法生成最小生成树</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h4><p>这个算法也是一个最小生成树算法。不过它与上面的Prim算法有所不同。</p>
<p>Prim算法选取新的一条边的原则是其中一个节点必须在已经选取的节点集合中，而另一个节点必须是为选取的节点。最终选定的边还必须要是全部满足条件的未选取边的权值最小值。也就是说prim算法选取的边必须是连续的，不可能是独立的一条边，因为其中的一个顶点必定是已知的。</p>
<p>Kruskal算法是在所有的边中进行。先排序，找出未加入生成树的最小权值的边，然后判断其是否会与已选取的边构成环，如果不会那么就加入到生成树中。</p>
<p>很显然这个算法也是一个贪婪算法。</p>
<img src="https://cdn.tanknee.cn/2019/11/201911275561670461ec5.png"/>

<h2 id="算法设计技巧"><a href="#算法设计技巧" class="headerlink" title="算法设计技巧"></a>算法设计技巧</h2><blockquote>
<p><strong>NP完全问题</strong>：NP也就是<code>Non-deterministic Polynomial</code>的缩写，非确定性多项式。</p>
<p>多项式时间指的是是时间复杂度为：$O(N)$  ,$O(\log(N))$等</p>
<p>非多项式时间是指这类算法的时间复杂度已经超过了计算机能够承受的范围了，例如$O(N!)$一类的时间复杂度。</p>
</blockquote>
<h3 id="贪婪算法"><a href="#贪婪算法" class="headerlink" title="贪婪算法"></a>贪婪算法</h3><p>贪婪算法是将任务分成不同的阶段，在每一个可以快速简单寻找到当前最优解的片段中，取用最优解，然后对每一个片段都重复这个过程，最终得到的就是整个任务的最优解或是次优解。</p>
<h4 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h4><img src="https://cdn.tanknee.cn/2019/11/20191126e5be5c33290cf.png"/>

<p>其中的平均完成时间的定义是：完成该任务的时间节点，而不是完成该任务的时间长度！</p>
<p>所以10-2为：<br>$$<br>(15+23+26+36)/4 = 25<br>$$<br>10-3为:<br>$$<br>(3+11+21+36)/4 = 17.75<br>$$<br>因此可以表明，不是是用事件单调递减的序列的解决方案必然是次优解，只有那些最小运行时间任务最先安排的解决办法才是最优解。</p>
<h4 id="贪婪算法的应用"><a href="#贪婪算法的应用" class="headerlink" title="贪婪算法的应用"></a>贪婪算法的应用</h4><ul>
<li>寻找图中的最短路径–<a href="#Dijkstra算法">Dijkstra算法</a></li>
<li>寻找图的最小生成树–<a href="#Prim算法">Prim算法</a></li>
<li>还有就是文件压缩–Huffman编码</li>
</ul>
<h4 id="Huffman编码"><a href="#Huffman编码" class="headerlink" title="Huffman编码"></a>Huffman编码</h4><img src="https://cdn.tanknee.cn/2019/11/20191126b29c6c7635916.png"/>

<p>由此可以得到字符编码的前缀码，不过使用前缀码的前提是每个字符编码都不是其他编码的前缀！因此每个字符都要放在树的叶子节点上。</p>
<img src="https://cdn.tanknee.cn/2019/11/20191126059412da1b1d2.png"/>

<p>这样做就确保了编码没有<strong>二义性</strong>。</p>
<h5 id="编码的比特数："><a href="#编码的比特数：" class="headerlink" title="编码的比特数："></a>编码的比特数：</h5><img src="https://img.tanknee.cn/blogpicbed/2019/11/20191128014302433d9c0.png"/>

<p>其中深度的数值等于其编码的位数！</p>
<img src="https://cdn.tanknee.cn/2019/11/201911260b2c7c30a1bbe.png"/>

<h5 id="Huffman算法"><a href="#Huffman算法" class="headerlink" title="Huffman算法"></a>Huffman算法</h5><p>算法对一个由树组成的森林进行，该森林中一共有C片叶子，也就是有C个字符需要编码。<strong>一棵树的权重等于它的树叶的频率之和</strong>。任取最小权重的两棵树$T_1$,$T_2$,并以这两棵树为子树形成新的树，将这样的过程进行<code>C-1</code>次，最终得到的就是Huffman编码的最优树。</p>
<blockquote>
<p>为什么需要进行<code>C-1</code>次：</p>
<p>​    因为森林中最开始有<code>C</code>棵树，也就是一共有<code>C</code>棵只有一个节点的树，每一次选取都会让两棵树合并成一棵树，树的总数减少一，因此从<code>C</code>到<code>1</code>也就需要进行<code>C-1</code>次</p>
</blockquote>
<h5 id="示例图："><a href="#示例图：" class="headerlink" title="示例图："></a>示例图：</h5><img src="https://cdn.tanknee.cn/2019/11/201911269a7d3ff4605c5.png"/>

<img src="https://cdn.tanknee.cn/2019/11/20191126e2dcb161519fb.png"/>

<p>该算法每一次选取子树都是在当前条件下选取权重最小的子树，因此该算法是贪婪算法。</p>
<h5 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdfix.h&gt;</span></span></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 哈夫曼编码树</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HuffmanTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> con[<span class="number">2</span>];                       <span class="comment">// 节点的内容</span></span><br><span class="line">    <span class="keyword">int</span> f;                          <span class="comment">//节点的频率</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HuffmanTree</span> *<span class="title">leftChild</span>;</span>  <span class="comment">//左儿子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HuffmanTree</span> *<span class="title">rightChild</span>;</span> <span class="comment">//右儿子</span></span><br><span class="line">&#125; * Node;</span><br><span class="line"><span class="comment">// 创建一个新的节点</span></span><br><span class="line"><span class="function">Node <span class="title">createNode</span><span class="params">(<span class="keyword">char</span> con[], <span class="keyword">int</span> f, Node left, Node right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先创建一个指针</span></span><br><span class="line">    Node newNode;</span><br><span class="line">    <span class="keyword">if</span> ((newNode = (Node)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node))) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(newNode, <span class="number">0</span>, <span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="comment">// strcpy(newNode-&gt;con,con);</span></span><br><span class="line">    <span class="keyword">if</span> (con)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(newNode-&gt;con,con,<span class="number">2</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(newNode-&gt;con,<span class="number">0</span>,<span class="number">2</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// newNode-&gt;con = con;</span></span><br><span class="line">    newNode-&gt;f = f;</span><br><span class="line">    newNode-&gt;leftChild = left;</span><br><span class="line">    newNode-&gt;rightChild = right;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * tree 树的数组</span></span><br><span class="line"><span class="comment"> * legth 数组的长度</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function">Node <span class="title">huffman</span><span class="params">(Node tree[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node tempNode, node1, node2,parent;</span><br><span class="line">    <span class="comment">//如果这个数组里面只剩下了两个元素，那么就说明已经排序完成了</span></span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">2</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">        node1 = tree[<span class="number">0</span>];</span><br><span class="line">        node2 = tree[<span class="number">1</span>];</span><br><span class="line">        parent = createNode(<span class="literal">NULL</span>,node1-&gt;f+node2-&gt;f,node1,node2);</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 给这个节点数组排序，找出频率最小的两个点</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tempNode = tree[i];</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; tempNode-&gt;f &lt; tree[j - <span class="number">1</span>]-&gt;f; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            tree[j] = tree[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        tree[j] = tempNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 频率最小的两个节点</span></span><br><span class="line">    node1 = tree[<span class="number">0</span>];</span><br><span class="line">    node2 = tree[<span class="number">1</span>];</span><br><span class="line">    parent = createNode(<span class="literal">NULL</span>,node1-&gt;f+node2-&gt;f,node1,node2);</span><br><span class="line">    <span class="comment">// 重新构建一个数组</span></span><br><span class="line">    Node newArray[length<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        newArray[i] = tree[i+<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    newArray[length<span class="number">-2</span>] = parent;</span><br><span class="line">    parent = huffman(newArray,length<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node node_a, node_e, node_i, node_s, <span class="keyword">node_t</span>, node_sp, node_nl,result;</span><br><span class="line">    node_a = createNode(<span class="string">"a"</span>, <span class="number">10</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    node_e = createNode(<span class="string">"e"</span>, <span class="number">15</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    node_i = createNode(<span class="string">"i"</span>, <span class="number">12</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    node_s = createNode(<span class="string">"s"</span>, <span class="number">3</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">node_t</span> = createNode(<span class="string">"t"</span>, <span class="number">4</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    node_sp = createNode(<span class="string">"sp"</span>, <span class="number">13</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    node_nl = createNode(<span class="string">"nl"</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    Node nodeArray[] = &#123;node_a, node_e, node_i, node_s, <span class="keyword">node_t</span>, node_sp, node_nl&#125;;</span><br><span class="line">    result = huffman(nodeArray, <span class="number">7</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h3><ul>
<li>分(Divide):递归解决较小的问题，基本情况直接返回就好</li>
<li>治(Conquer):从子问题中重构原问题的解</li>
</ul>
<h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><ul>
<li><p><a href="#求解算法时间复杂度的步骤">求解最大子序列的和</a></p>
</li>
<li><p><a href="#归并排序">归并排序</a></p>
</li>
<li><p><a href="#快速排序">快速排序</a></p>
</li>
<li><p>幂运算的快速求解</p>
</li>
<li><p>斐波那契数列的递归求和–性能较差</p>
<ul>
<li><img src="https://cdn.tanknee.cn/2019/11/2019112616dcd7130a2d6.png"/>



</li>
</ul>
</li>
</ul>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><h4 id="动态规划的核心思想是"><a href="#动态规划的核心思想是" class="headerlink" title="动态规划的核心思想是"></a>动态规划的核心思想是</h4><p>将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。</p>
<h4 id="斐波那契数列动态规划"><a href="#斐波那契数列动态规划" class="headerlink" title="斐波那契数列动态规划"></a>斐波那契数列动态规划</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f1,f2;</span><br><span class="line">    f1 = f2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> f1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        result = f1 + f2;</span><br><span class="line">        f1 = f2;</span><br><span class="line">        f2 = result; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fib(<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="最短编辑距离"><a href="#最短编辑距离" class="headerlink" title="最短编辑距离"></a>最短编辑距离</h4><p><a href="https://www.cnblogs.com/hapjin/p/7467035.html" target="_blank" rel="noopener"><img src="https://cdn.tanknee.cn/2019/11/20191126885babad4dcc4.png"/></a></p>
<p>在有的文章中，替换的代价是2，而在有的文章中，替换的代价是1，本文按照代价为1的来计算。不过个人认为代价为二更加合理。</p>
<h5 id="动态规划表的初始化"><a href="#动态规划表的初始化" class="headerlink" title="动态规划表的初始化"></a>动态规划表的初始化</h5><img src="https://cdn.tanknee.cn/2019/11/20191126cff68df72c86c.png"/>

<ul>
<li>D(0,j)=j，空串和长度为j的Y子串间的最小编辑距离（添加或删除对应的次数）</li>
<li>D(i,0)=i，长度为i的X子串和空串间的最小编辑距离添加或删除对应的次数）</li>
</ul>
<p>而最终的表的结果是：</p>
<img src="https://cdn.tanknee.cn/2019/11/201911260e9bdb95d8b6f.png"/>

<p>在三个中取最小值作为矩阵的元素！也就是为了找出变成另一个字符串的最小代价</p>
<h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">·</th>
<th align="center">s</th>
<th align="center">n</th>
<th align="center">o</th>
<th align="center">w</th>
<th align="center">y</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>·</strong></td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center"><strong>s</strong></td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center"><strong>u</strong></td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center"><strong>n</strong></td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center"><strong>n</strong></td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center"><strong>y</strong></td>
<td align="center">5</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
</tr>
</tbody></table>
<p>所以最终的结论是<code>sunny</code>到<code>snowy</code>的最小编辑距离为<code>3</code> 。</p>
<table>
<thead>
<tr>
<th></th>
<th>·</th>
<th>a</th>
<th>m</th>
<th>e</th>
</tr>
</thead>
<tbody><tr>
<td>·</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>m</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>e</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>1</td>
</tr>
</tbody></table>
<p>所以最终的结论是<code>me</code>到<code>ame</code>的最小编辑距离为<code>1</code> 。</p>
<h5 id="下面是源码"><a href="#下面是源码" class="headerlink" title="下面是源码"></a>下面是源码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a, b) (a &lt; b ? a : b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * res 字符1--原始字符串</span></span><br><span class="line"><span class="comment"> * des 字符2--目标字符串</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minEditDistance</span><span class="params">(<span class="keyword">char</span> *res, <span class="keyword">char</span> *des)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//首先初始化动态表--填充相对于空字符的编辑距离，也就是字符长度</span></span><br><span class="line">    <span class="keyword">int</span> dis[MAX][MAX] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (<span class="keyword">int</span>)<span class="built_in">strlen</span>(des); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dis[<span class="number">0</span>][i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= (<span class="keyword">int</span>)<span class="built_in">strlen</span>(res); j++)</span><br><span class="line">    &#123;</span><br><span class="line">        dis[j][<span class="number">0</span>] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环遍历整个数组，计算每一个编辑距离</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (<span class="keyword">int</span>)<span class="built_in">strlen</span>(res); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= (<span class="keyword">int</span>)<span class="built_in">strlen</span>(des); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果在该位置的两个元素相同，那么到此的最小编辑距离就等同于不包含这两个元素的最小编辑距离</span></span><br><span class="line">            <span class="keyword">if</span> (res[i<span class="number">-1</span>] == des[j<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[i][j] = dis[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 相对而言的！向下走的意思就是多出了一个多余元素，在相对于上面那一格的最小编辑距离而言需要将这个多出来的元素删掉</span></span><br><span class="line"><span class="comment">                 * 同理，向右走就是目标串多了一个元素，要在左侧编辑的基础下再多加一个元素</span></span><br><span class="line"><span class="comment">                 * 向右下角走也是差不多的道理，既有一个多余元素，而且目标串也多了一个元素，所以要使用替换操作。</span></span><br><span class="line"><span class="comment">                 * */</span></span><br><span class="line">                <span class="keyword">int</span> delEd = dis[i][j<span class="number">-1</span>]+<span class="number">1</span>;<span class="comment">//往下走就是删除 </span></span><br><span class="line">                <span class="keyword">int</span> insEd = dis[i<span class="number">-1</span>][j]+<span class="number">1</span>;<span class="comment">//往右走是插入</span></span><br><span class="line">                <span class="keyword">int</span> subEd = dis[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;<span class="comment">//向右下角走--对角线走就是替换 在这里替换的代价是1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> minEd = <span class="built_in">min</span>(<span class="built_in">min</span>(delEd,insEd),subEd);</span><br><span class="line">                dis[i][j] = minEd;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; MAX; m++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; MAX; n++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,dis[m][n]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[(<span class="keyword">int</span>)<span class="built_in">strlen</span>(res)][(<span class="keyword">int</span>)<span class="built_in">strlen</span>(des)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Min Distance of %s to %s is %d \n"</span>,<span class="string">"sunny"</span>,<span class="string">"snowy"</span>,minEditDistance(<span class="string">"sunny"</span>,<span class="string">"snowy"</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Min Distance of %s to %s is %d"</span>,<span class="string">"me"</span>,<span class="string">"ame"</span>,minEditDistance(<span class="string">"me"</span>,<span class="string">"ame"</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">TankNee</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://www.tanknee.cn/2019/11/28/datastruct_review/">https://www.tanknee.cn/2019/11/28/datastruct_review/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C/">操作</a><a class="post-meta__tags" href="/tags/%E5%9C%B0%E5%9D%80/">地址</a><a class="post-meta__tags" href="/tags/%E7%B1%BB%E5%9E%8B/">类型</a><a class="post-meta__tags" href="/tags/length/">length</a><a class="post-meta__tags" href="/tags/%E5%88%97%E8%A1%A8/">列表</a><a class="post-meta__tags" href="/tags/node/">node</a><a class="post-meta__tags" href="/tags/%E5%AD%97%E7%AC%A6/">字符</a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/%E5%87%BD%E6%95%B0/">函数</a><a class="post-meta__tags" href="/tags/%E8%8A%82%E7%82%B9/">节点</a><a class="post-meta__tags" href="/tags/int/">int</a><a class="post-meta__tags" href="/tags/temp/">temp</a><a class="post-meta__tags" href="/tags/%E5%8F%98%E9%87%8F/">变量</a><a class="post-meta__tags" href="/tags/%E6%9F%A5%E6%89%BE/">查找</a><a class="post-meta__tags" href="/tags/arr/">arr</a></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5ed5a3fd25ab3792" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/12/01/%E5%8D%81%E4%B8%80%E6%9C%88Nov/"><i class="fa fa-chevron-left">  </i><span>十一月November</span></a></div><div class="next-post pull-right"><a href="/2019/11/16/Hust-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A/"><span>Hust 面向对象大作业</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'true' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'tJv0hJ0qmpEgSvlqwrqQbBL9-gzGzoHsz',
  appKey:'YQyMpfNKSaHjrlBu3kMjwAo1',
  placeholder:'Write Your Ideas',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'zh-cn'
})</script></div></div><footer class="footer-bg" style="background-image: url(https://img.tanknee.cn/img/20191123190408.png)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By TankNee</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="icp"><a href="http://beian.miit.gov.cn/" target="_blank" rel="noopener"><span>浙ICP备19040955号</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>
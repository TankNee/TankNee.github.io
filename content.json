{"pages":[{"title":"","text":"5UwSEikR04","link":"/baidu_verify_5UwSEikR04.html"},{"title":"404","text":"页面消失了","link":"/404/index.html"},{"title":"Categories","text":"","link":"/categories/index.html"},{"title":"时光机","text":"","link":"/cross/index.html"},{"title":"Gallery","text":"2020-Spring 清和 2019-11-10 全国落日大赏 2020-06-25 2020-07-05","link":"/gallery/index.html"},{"title":"Links","text":"下面是站点的一些信息，可以在留言板或者在这里评论申请友链。谢谢 名称：归舟棹远 地址：https://tanknee.cn 描述：晚来天欲雨，能饮一杯无 头像：https://secure.gravatar.com/avatar/56f7d54e5b0a52b69ed162fc8afcf424?s=65&amp;r=X&amp;d=","link":"/links/index.html"},{"title":"slides","text":"","link":"/slides/index.html"},{"title":"About","text":"在HUST读书 日常半夜饿肚子 并无努力学习 只想混混日子 GitHub 即刻 微博","link":"/about/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"},{"title":"Mssage","text":"可以找我做友情链接！！兄弟们相位猛冲！！！Links前往 Links 页面添加友链","link":"/message/index.html"}],"posts":[{"title":"01、03杂记","text":"20190901 九月的第一天。明天就要正式上课了，大物马原，这学期我要好好学习大雾，我可以我能行，搞定大物冲冲冲！！ 不过今天没有去学车，有点可惜，不知道接下来还有多少时间可以去把车学完，要不国庆不回去直接留下来学车好了？应该也行吧，我还有机会hhh。 rng赢了tes，虽然今年的skt很强，但是莫名地对rng很放心，不是因为强，而仅仅是心安，哈哈哈哈，挺有意思的事情。 开学了，少熬夜，多读书，多跑步。 冲冲冲！！！ 20190903 好卑微，开学的日子也没有那么开心。感觉自己有点找不到方向。 别人都似乎有目标，都在坚定地走着，而我只是平平无奇地在大学里划水。 突然感觉在打字的时候的思想活跃状况和在洗澡，亦或是睡前的状态是完全不一样的。打字的时候似乎只剩下了潜意识，而原本的构思大多被打乱了，往往是想到什么写什么。 真的有点想去重庆玩吧。虽然不知道到底有什么这么吸引我。但是就是不想回家，也不想留下来学车。 这个学期没有英语课了，所以突然解放了一部分的自我。 害，手打字打的好疼。 辣鸡天蚕土豆，更新更的这么慢，呀屎了啊？？","link":"/2019/09/03/01-03%E6%9D%82%E8%AE%B0/"},{"title":"09杂记","text":"20190809 早上溜去医院划了波水，确实没什么动力，台风要来了。雨打着窗户。已经响了一整天了。 莫名的喜欢台风，也不能说是喜欢吧，应该说是昏暗的暴雨环境给予人深度思考的空间。 跟风黑了鹿晗和他的上海堡垒，但还是耐不住好奇，去把书找出来看了一遍。江南老贼写的东西，但又越看越不像是老贼写的，29岁的江南的笔力竟然也是如此的稚嫩，根本不像是龙族里那般的老练沉稳。 或许是鹿晗代入的原因，看的时候江洋的脸总是被替换成鹿晗的脸，但又会被鹿晗奇奇怪怪的演技劝退，我总觉得的江洋更适合的是隐形守护者的男主。 书里很少有过渡环节的描述，总是在和外星人拼斗的时候还会有柔情片段的上演，让人搞不清这究竟是爱情小说还是一部科幻/玄幻小说，老贼没搞明白，我也没有弄明白。 早上的时候，在二医的大堂里，人很少，零散的病人都有很明确的方向，不需要我这个二愣子志愿者给他们什么错误的帮助。 也是，很多事情发生的时候根本不会寻求我的同意，它发生了，与我无干。 以前，这一个多月来，很舍不得把联系方式删掉，最后一次的正常对话也停留在“生日快乐”，就像是林澜发给江洋的最后一句话是“晚安”。谁都没有在等什么东西，只是今天恰好台风来了，恰好我翻了一下微博，而后又去翻了翻朋友圈。 “不要再来偷偷看我啦” 我也不会再去偷偷看你啦 很难形容那一段时间的情感，有点像东拼西凑，对自己也不会再抱有很高的期待以及很高的忠诚。放得下是她的事情，放不下是我的事情不拿她的标准来限制我的行为才应该是我的方式这段日子挺难熬的，我不知道走不走的下去但我已经至少想明白了一件事情她将会是我人生中如林澜，诺诺亦或是其他般的一位她将永远的十八岁而我不会，我只会向前走像生成于太平洋的风终要刮过江南的丘陵踏山遍水，有所依恋，也终将老去 今天还看了芒果冰的一期视频，听到无用歌时被惊艳到了： 天下无用天地何用?不能席被,风月何用?不能饮食.纤尘何用?万物其中,变化何用?道法自成,面壁何用?不见滔滔,棒喝何用?一头大包.生我何用?不能欢笑,灭我何用？不减狂骄踏歌而行八荒路,物我两忘九逍遥。芒鞋斗笠千年走,万古长空一朝游. 生我何用 不能欢笑灭我何用 不减狂骄","link":"/2019/08/09/09%E6%9D%82%E8%AE%B0/"},{"title":"2001 太空漫游","text":"花了三天左右把2001太空漫游看了一遍，这本书躺在我的kindle里已经很久了，最初在动车上翻出来看，确实是看的我索然无味。nmd，wsm，为什么要在好好的科幻小说前写一段人猿奇幻历险？我这么庸俗的人根本看不进去好吗？ 当然，除了那块黑石。 寂静光滑 顿时就想起了丁仪和那个同样光滑的让人觉得无从击破的水滴。 大刘说过，他的作品多是对阿瑟的2001太空漫游的拙劣模仿，这部分应该是算作致敬吧。同样的未知文明，同样的无懈可击，同样的神秘绝望。看着太空漫游影片里的黑石场景，简直是喘不过气来，压抑，密不透风。弗洛伊德博士伸出手，谨慎的触碰无暇的黑石，像极了百万年前的人猿，好奇而恐惧。 文明起源曾有一个推测：外星人点化人类，而后，人类才有了文明。阿瑟的黑石，就与点化不谋而合。在恰当的时机，恰当的地点出现，就好像，有一双眼睛，在观察着人类，或者说是，监视着人类。 第一块黑石让人猿走向人类，第二块促使人类走向土星，走向深空。 说是促使，而实际上极为平淡，不管是书还是影片，对白极少，连过激的动作也很少见，没有传统科幻表现形式里的反抗，对立，战争，爱情。唯一剩下的只有探索。 对人工智能的探索 对未知深空的探索 对古今寰宇的探索 着实很惊艳，没有冲动，没有暴力，只剩如一潭静水般的宁静，一如影片里HAL的声音，就算Bowman在拆着他的逻辑芯片，他也不过是说了一句，“我害怕”。 很难想象这是写于半个世纪之前的科幻作品，那时，第一台计算机才出现了二十余年，而阿瑟-克拉克就已经开始讨论人工智能的可行性以及对人工智能的深层探讨，而其中的许多设定也极为的超前，至少，在现在看来，并没有十分的落伍。 故事的最后，Bowman穿过星之门，变成了星童。他注视着自己的蔚蓝色的家园，“令人惊讶的注意力”，他凝视着家园的过去，现在和未来，他是神，但他也是虚无。 不管是电影还是书，都有一种无法言说的老旧感。就好像崭新的白衬衫，用上了一层黄旧的滤镜，准确的说，就好像是高中化学书的人都活了过来。再配合少之又少的对白，恢弘磅礴的交响乐配乐，我一次次质疑自己是不是在看老派的话剧表演，而不是一部超越时代的科幻巨作，太空人们那机械鬼畜的步态走姿，昏暗地面，冷酷月光，像极了非洲大地上的邪教祭典，人们对着“神”顶礼膜拜，诚惶诚恐，不知所措为何。 想写影评好久了，本是想先写哪吒的影评，结果一直搁着没有写，只写了个标题，剩的有点脑袋发空，总感觉写着写着就变成观后感了，写了这么多年作文，会写的好像也就是中学作文了。 七月再见，八月你好","link":"/2019/08/02/2001-%E5%A4%AA%E7%A9%BA%E6%BC%AB%E6%B8%B8/"},{"title":"20190808","text":"早上没来得及吃药，也没来得及起床，早上过的有点累，中午摸鱼，又喝了酸奶，这几天好像真的不太行，要节制一点防止复发。 算法的书拿来了，确实比较通俗易懂，但有时候会想想是不是有点过于简单了，hh，还是要好好学吧。 去买点书看吧，晚风枕酒。确实在很多的瞬间都会怀疑自己做事情的动机，是因为真的喜欢，还是因为习惯。尝试一下iOS13，反正也没几个月了，尝尝鲜也没有什么问题。布置一下寝室吧买一个好一点的椅子买一个桌上小桌，买墙纸，把原来的撕掉。 趁着还有点钱，买点能提升生活质量的东西，而不是把钱浪费在不重要的地方，不过有时候趟雷也是一件很有意义的事情，。 也不要忘记了多写字，感觉现在比以前要好的多了，表达的能力也有所长进","link":"/2019/08/08/20190808/"},{"title":"20190926","text":"20190926 每日一曲哈哈哈哈 今天没什么课，但是做了很多事情。 1. 我又又又报名了三大团队，我真的是头铁。但也算是想要挑战一下自己吧，我真的好废物，一事无成，想做点有意思的事情，所以这次报的是web。 2. 博客改了很多东西 全局的随机图片我都改成了bing的封面图，虽然bing只有几张图片可以调用，不过也还算不错了，感谢网上各位大神的api。虽然加载速度有一点点受影响，不过也还算事可以接受。后面应该会上CDN什么的吧，相对而言可以加速。 博客底部的信息栏添加了很多东西。点击总次数，博客运行时间，当前访问的系统，客户端，IP地址等等内容都可以在最下面展示，还不错，再过几天可以继续优化，学一学CSS3，php，js，html等等，还有很多可以拓展，现在的代码框架还是有一点问题，后期可以稍微调整一下。 还有就是缩略图的，原作者不想加缩略图，但我还是加了，我比较喜欢不同文章订制的感觉 前几天就上了的邮件插件终于可以用了，现在用的是腾讯企业邮箱的smtp服务器，发件人也比较好看美观了，有点快乐哈哈哈哈。 好久没有用VPN了，算了，我不需要，毕竟还要备案的。 今后的话美化博客算是一个重要的兴趣动力了吧，其他的就随缘吧，Android随缘写，后台服务器可以慢慢来，淡定。","link":"/2019/09/26/20190926/"},{"title":"2020 新世界的船票","text":"我是旧世界的残党，新世界没有能载我的船 ——海贼王481集 十年前的小学三年级，那时常有写日记的作业，学校发的日记本是泛黄的绿格子本，一页约莫只有百来个格子，最顶头是填日期的地方，我仍记得我歪歪扭扭地在年份的空里写下2010，却又感觉不甚熟悉。 一晃眼，已经十年了初二的时候吧，在寝室里，蛋蛋问我以后会去读什么专业，虽然我也不知道那时候怎么会突然提起这个话题，我脱口而出的就是软件工程。原因也很奇怪，那几天在一本杂志上看过一个人在澳洲读软件工程硕士的文章，只是单纯地觉得这个专业很酷，而且可以玩我平时很少能触及的电脑。没想到四年之后，阴差阳错还真的来到了这个专业，本是一心想学的计算机，结果报的全没上，也算是一种缘分吧。 不知道是长大了的原因还是其他的原因，这十年的记忆要比前十年的要清晰的多。我会永远地记得在楼道里上下奔走寻找我妈的教室的那段记忆，虽然这几年已经模糊了不少，但那种晕眩感和盲目无从的感觉，从未离开我那段记忆。 重复轮播不停的十年两年小学，三年初中，三年高中，还有两年的大学，应该是这辈子第一次也是最后一次全在读书的十年了，你往回翻阅时，在每一年都能找到惊喜，失望，苦痛，欢愉，但是，这一年年的，又是何其的相似，无外乎上课，吃饭，寝室，所谓情绪，不过是这三点奔波间的插曲，我更像是无情的规则执行机器，按部就班地走着既定的线路。 每段学习的日子都会碰上几个难以忘怀的人，有的现在还有联系，有的热络了一段时间便沉寂下去，有的从冷落的通讯录中突然炸出，很快又冷却回去。 我真像个小孩，特别是在不承认这句话的时候，比如现在。 怀疑的，自责的，但从不悔过的十年 相信自己是病态的和坚定自己是正常人一样，无可苛责。到了今天，写到这里的时候，才真正的感觉到，这些年留下的到底是什么： 人们从历史中得到的唯一教训，就是得不到任何教训 ——黑格尔 本来只想写2019年发生的事情，刚写完开头，就发现已经偏得离谱，索性就直接往下写了。 说说今年吧大学的第一个暑假 没有学完车 没有做任何有意义的事情。 去了一趟并不那么痛快的苏州 第一次这么急着离开家来到学校，在外面呆了差不多半年，甚至直到现在也没有特别想回去的感觉，除了午夜饿肚子的时候，还有早上对着韵酒硬如纸板的手抓饼难以下咽时，会难以遏制地想起乐清的糯米饭，年糕，炒粉。 种了一年的树，很多时候都难以相信自己可以这么长时间不碰手机，不过大多时候不是在玩平板就是跟软件拼手速，甚至还有睡觉种树的诡异操作。不过我相信，今年的华科树王肯定还是我！！ 买的东西越来越昂贵，很多时候都超出了自己的承受范围，不过好的产品，确实可以有效提升效率。今年最满意的应该是上个月刚买的AirPods Pro，无他，省事。第二位就是过年的时候的iPad2018，虽然很多次都想要换成Air3或者Pro2018，不过着实承受不起了。 最让我受益匪浅的一件事情，是七月末，开始折腾以前认为繁琐不堪的服务器，自那之后一发不可收拾，如果没有那段时间的闲着蛋疼，应该后来就不会去参加前端项目，应该也就不会这么忙…Anyway，我认为这是有益的。 年初立的Flag不知道被我丢哪里去了，所以现在也没有办法知道自己到底有没有做到。反正暑假立下的什么学车，看书，看电影统统没有完成。这件事情告诉我们，不要乱搞什么Flag… 最后说说今天吧anyway，我想做的想说的基本都说了做了，今年也算是不留遗憾了。 害 大伙儿都过得开心点，明年一定是个好年 一定是","link":"/2019/12/31/2020_newWorld/"},{"title":"Android6.0及更高版本动态获取权限","text":"Android 6.0及其更高版本中，即API&gt;=23之后的版本中某些受保护的权限无法直接通过Manifest来直接默认获取，只能通过动态获取，这样做的好处是显而易见的，可以让权限用在该用的地方。 动态获取权限要做的是这几件事情： 判断当前的系统版本，API版本的多少来确定使用哪种获取权限的方法，如果API小于23那么就不需要发起权限获取操作。 如果API大于或等于23那么就发起权限获取，ActivityCompat.requestPermissions(this,new String[]{Manifest.permission.CAMERA},1); this 为当前的操作主体Activity，string数组内为所请求的权限，可见可以同时获取多个权限，最后一位是请求码requestcode。 最后一步是确定回调函数onRequestPermissionsResult(int requestCode,String[] Permissions,int[] grantResult) 其中grantResult数组的第一位若等于PackageManager.PERMISSION_GRANTED那么说明权限被授予否则权限授予失败。 接下来show you the code： 1234567891011button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { try{ //权限申请函数 requestCameraPermission(); }catch (Exception e){ Log.d(&quot;CameraDemo Start&quot;,e.toString()); } }}); 1234567891011121314151617private void requestCameraPermission(){ //判断SDK版本是否大于23 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M){ int checkCameraPermission = ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA); if(checkCameraPermission != PackageManager.PERMISSION_GRANTED){ //进入这个部分表示程序没有该权限 ActivityCompat.requestPermissions(this,new String[]{Manifest.permission.CAMERA},1); return; }else{ Toast.makeText(MainActivity.this,&quot;相机权限已获取成功&quot;,Toast.LENGTH_LONG).show(); onCallCamera(); } }else{ Toast.makeText(MainActivity.this,&quot;API小于23无需获取权限，只需要声明即可&quot;,Toast.LENGTH_LONG).show(); onCallCamera(); }} 1234567891011121314151617181920212223242526272829303132333435public void onRequestPermissionsResult(int requestCode,String[] Permissions,int[] grantResult){ switch (requestCode){ case 1: if(grantResult[0] == PackageManager.PERMISSION_GRANTED){ //TODO 相机调用函数 onCallCamera(); }else{ Toast.makeText(MainActivity.this,&quot;权限被拒绝&quot;,Toast.LENGTH_LONG).show(); } break; default: super.onRequestPermissionsResult(requestCode,Permissions,grantResult); }}​private void onCallCamera() { Intent i = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); startActivityForResult(i, 1); Toast.makeText(MainActivity.this, &quot;函数调用成功&quot;, Toast.LENGTH_LONG).show();}protected void onActivityResult(int requestcode, int resultCode, Intent data){ //接收camera拍摄下来的照片回传到activity中 try{ if(requestcode !=1){ return; } super.onActivityResult(requestcode,resultCode,data); Bundle extras = data.getExtras(); Bitmap bitmap = (Bitmap)extras.get(&quot;data&quot;); imageView.setImageBitmap(bitmap); }catch (Exception e){ Log.d(&quot;Camera&quot;,e.toString()); }​} 下面是另外一个动态获取权限的思路： 123456789Intent i =new Intent(MediaStore.ACTION_IMAGE_CAPTURE);if(ContextCompat.checkSelfPermission(MainActivity.this,Manifest.permission.CAMERA)!=PackageManager.PERMISSION_GRANTED){ ActivityCompat.requestPermissions(MainActivity.this,new String[]{Manifest.permission.CAMERA},1);}else { startActivityForResult(i,1); Toast.makeText(MainActivity.this,&quot;test_1&quot;,Toast.LENGTH_LONG).show();}startActivityForResult(i,1);Toast.makeText(MainActivity.this,&quot;test_2&quot;,Toast.LENGTH_LONG).show(); 核心部分是： 1if(ContextCompat.checkSelfPermission(MainActivity.this,Manifest.permission.CAMERA)!=PackageManager.PERMISSION_GRANTED){ ActivityCompat.requestPermissions(MainActivity.this,new String[]{Manifest.permission.CAMERA},1); } 其中的本质就是判断权限是否存在，然后若是不存在该权限那么就直接申请。但有一个坏处是这里申请的权限是写死的，最好的解决办法是写一个函数便于调用。","link":"/2019/07/28/android6-0%E5%8F%8A%E6%9B%B4%E9%AB%98%E7%89%88%E6%9C%AC%E5%8A%A8%E6%80%81%E8%8E%B7%E5%8F%96%E6%9D%83%E9%99%90/"},{"title":"FuckTheRegulation","text":"[Meting][Music server=”netease” id=”1338149101” type=”song”/][/Meting] 真的是期待了很久的海上钢琴师,今天首映,也不管不顾下个星期要考我一无所知的汇编,下午就直接跑去看了. 看的途中一直在想,如果我要写一篇影评,我到底会怎么写?我真的能把一部电影,一个人物,一句台词,真真切切的表达出来吗? 对不起,我觉得我不能,抱歉,我总是喜欢说对不起 小柠檬第一次弹完钢琴之后对船长说的第一句话就是:Fuck The Regulation!,莫名其妙,我对影片的前半段留有的最深的印象就是这句话,以至于最后1900走下悬梯,站在悬梯的中央,望着纽约的林立高楼时,我都在期待着他再次说出Fuck The Regulation!. 可惜他没有纽约是上帝的钢琴,完美到找不出一个狭缝塞进一只薄薄唱片. 完美到大海上最好的钢琴师都不敢奢望坐上那条钢琴凳 扔掉帽子走回了弗吉尼亚号. 其实也挺好.这世界有很多抉择,但没有一个抉择是非黑即白的. 脑袋里太乱了,最近事情真的很多很多,虽然我一直不想做,不想耗费全部精力在某件特定的事情上,除非这件事已经迫在眉睫. 我已经分不太清楚这种畏手畏脚的感觉是谨慎还是懦弱了.","link":"/2019/11/15/FuckTheRegulation/"},{"title":"Gitea--Git with a cup of tea","text":"Gitea–Git with a cup of teaGitea是一款开源的代码托管软件它来自于同样开源的gogs，是其一个分支，由于社区的开发贡献者与原gogs的开发者产生了意见上的分歧，社区开发者fork了gogs并不断迭代完善至今，其间还有很多有意思的事情，详情可以看这篇wolfogre. 为什么会有 Gitea克隆一个现有的项目，然后改头换面、自立门户、重新发行，这在开源的世界上不算什么新鲜事。但这种情况的发生往往事出有因，比如原项目不维护了，原项目拒绝实现某些新特性，新项目针对特定用户群做了优化，等等等等。 但 Gogs 仍在维护，Gitea 也没有实现什么新功能，针对的用户群也是一模一样的，那为什么还会有 Gitea 呢？Gitea 的官方博客里给出了解释，翻译成中文如下： Gitea 是一个开源社区驱动的 Gogs 克隆，后者是一个备受欢迎的 Git 自托管服务。我们是一个日益增长的群体——之前是 Gogs 的用户和贡献者，但发现了 Gogs 令人沮丧的“单一维护者”管理模式，所以决定作出努力，建立一个更加开放、更加高效的管理模式。 在此之前，我们尝试说服 Unknown 给社区中更多的人“写权限”。他理所当然地认为 Gogs 是自己的生物，不希望它在自己掌控之外生长。所以为了有效地让代码走向自由，重新克隆一份是必须的。 gogs是一个国人的产品，不得不说，确实是很优秀的个人作品，不过相对而言，我更喜欢gitea的UI风格和界面，具体的差异我暂时也还没有感受出来。 我的Gitea站点下面是Gitea的安装与使用 安装Gitea首先是要有一台可用的服务器。 这边我用的是宝塔面板，所以创建网站会比较轻松。用宝塔面板创建一个网站 然后用Xshell或其他类似软件链接服务器，并cd定位到所要安装的文件夹。 这边我采用的是Binary Install，二进制安装。输入以下代码： 12wget -O gitea https://dl.gitea.io/gitea/1.10.1/gitea-1.10.1-linux-amd64chmod +x gitea 很快就会完成安装包的下载。 然后可以启动服务，测试站点的使用情况。使用以下命令： 1./gitea web 然后就可以启动了。当然，你也可以在自己本地的Linux机器上安装。 当你选择在云服务器安装时，记得在阿里云/腾讯云上打开防火墙的3000端口，还有宝塔面板的3000端口。 Gitea域名配置当然你不会希望Gitea永远使用IP来访问，那么你就需要一个域名。解析过程不再赘述。直接修改ngnix的配置文件。 1234567891011121314151617181920212223242526272829303132333435server{ listen 80; listen 443 ssl http2; server_name yourdomain.com; #SSL-START SSL相关配置，请勿删除或修改下一行带注释的404规则 #error_page 404/404.html; #如果你不需要https那么删除下面这一部分就可以了（删到SSL-END） #HTTP_TO_HTTPS_START if ($server_port !~ 443){ rewrite ^(/.*)$ https://$host$1 permanent; } #HTTP_TO_HTTPS_END ssl_certificate ;#--这里填你的ssl证书地址 ssl_certificate_key ; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; ssl_session_cache shared:SSL:10m; ssl_session_timeout 10m; error_page 497 https://$host$request_uri; #SSL-END #重定向到Gitea client_max_body_size 20m; location / { #默认的端口是3000 proxy_pass http://localhost:3000; } } 然后记得在gitea安装时配置好URL即可。 Gitea的使用安装的时候还是有几个坑的比如SSH地址如果你不更改那么就会默认为LocalHost，不太雅观，记得修改 还有就是如果你使用root用户启动的Gitea，那么ssh的默认前缀就会是root，例如这样： 1root@git.tanknee.cn:tanknee/Xxxxx.git 十分的不友好，所以我建议新建一个git用户，然后再切换到git用户启动Gitea安装，就可以达到这种效果了： 1git@git.tanknee.cn:tanknee/Xxxxx.git 添加git用户12useradd gitsu -l git //切换用户 长期后台运行一种做法是将Gitea作为系统服务，开机自启动，另一种做法是用nohup，挂在后台。效果一致，但我觉得第一种相对会好一点。 开机自启动nohup挂后台1nohup ./gitea web &amp; 其中 &amp;代表一直挂在后台。 结语从gitlab转投到gitea之后服务器的负载小了很多，效果明显。 前后对比 负载对比 还是很好的一款开源代码托管平台。","link":"/2019/12/11/gitea_introduct/"},{"title":"HEXO的一些问题","text":"在差不多踩了WordPress的很多坑之后再来写Hexo发现还是有很多坑，不过还好，这个本地的博客系统倒是很符合我的习惯，而且直接在我的喜欢的编译器里面写代码然后再用命令行上传到GitHub上显示真的是太酷了，真为创造出这个显示模式的人感到骄傲。不过还是有一些不太优雅的地方。咱们撸代码的总是要讲究一个优美文雅是吧，typora不能识别Markdown文件以外的文件，而vscode的实时渲染好像也不太行，其实是我没有用过hhhh。接下来写一点遇到的坑： 一直打不开域名：这个问题往往和该域名的解析有关。你需要先用阿里云或者腾讯云之类的去把这个域名解析了，你才能在GitHub Page中重定向这个域名。如果出现域名指向混乱的问题，我觉得最好把之前的解析全部删掉，推到重来。 上传之后需要重新指定域名：这个问题也困扰了我很久，在不断地设置中我发现每次都是缺少一个名为CNAME的文件，其中仅包含你所要解析的域名，根据网上的一些博客可以知道我们只要在网站的根目录的source文件夹内新建一个名为CNAME的文件，没有后缀！！！！！，不要在这个文件名后面加上后缀！！然后再上传就好了，不会出现以上问题 busuanzi插件的字数统计无法运行：这个也是一个坑，因为在config文件里查阅到的选项并没有提示你要安装对应的插件，而实际上必须要安装wordcount插件，否则无法使用字数统计，其他几个部分的统计字数的功能都需要这个插件，下面是安装过程： npm hexo-wordcount —save 在主题的config文件里找到wordcount相关的开关并打开就好了 啊，好累啊，我不想写了，今天就到此为止吧。","link":"/2019/08/11/538/"},{"title":"Hexo豆瓣文章插件","text":"Github项目地址github地址: https://github.com/TankNee/hexo-douban-card 如果可以的话,希望你能给我一个star⭐ npm地址: https://www.npmjs.com/package/hexo-douban-card 示例 灯影绰约 电影名: 头文字D頭文字D(2005) 导演: 刘伟强/麦兆辉 主演: 周杰伦/陈冠希 上映时间: 2005-06-23(中国大陆/中国香港) 评分: 7.7 .douban-card-block { display: flex; justify-content: center; align-items: center; width: 100%; max-height: 400px; } .douban-card { display: flex; margin: 30px 10px; padding: 15px; border-radius: 15px; position: relative; justify-content: center; align-items: center; overflow: hidden; color: antiquewhite; text-decoration: none; } .douban-card:hover { text-decoration: none; } .douban-card-bgimg { position: absolute; width: 115%; height: 115%; filter: blur(15px) brightness(0.6); background-size: 100%; background-position: center; background-repeat: no-repeat; } .douban-card-img { position: relative; height: 130px; width: 80px; background-size: 100%; background-position: center; background-repeat: no-repeat; } .douban-card-left:hover .douban-card-img { filter: blur(5px) brightness(0.6); transform: perspective(800px) rotateX(180deg); } .douban-card-left .douban-card-img { transition: all 500ms ease; } .douban-card-left { position: relative; display: flex; flex-direction: column; align-items: center; } .douban-card-left .douban-card-status { height: 130px; width: 80px; text-align: center; font-weight: bold; position: absolute; left: 0; top: 30%; transform: rotateX(180deg); backface-visibility: hidden; transition: all 500ms ease; } .douban-card-left:hover .douban-card-status { transform: perspective(800px) rotateX(0deg); } .douban-card-right { position: relative; display: flex; flex-direction: column; margin-left: 12px; font-size: 16px; font-family: \"Courier New\", Courier, monospace; line-height: 1.3; color: antiquewhite; } .douban-card-item { margin-top: 4px; } 见字如晤 书名: 人生海海 作者: 麥家 出版年份: 2019-7-1 评分: 8.4 .douban-card-block { display: flex; justify-content: center; align-items: center; width: 100%; max-height: 400px; } .douban-card { display: flex; margin: 30px 10px; padding: 15px; border-radius: 15px; position: relative; justify-content: center; align-items: center; overflow: hidden; color: antiquewhite; text-decoration: none; } .douban-card:hover { text-decoration: none; } .douban-card-bgimg { position: absolute; width: 115%; height: 115%; filter: blur(15px) brightness(0.6); background-size: 100%; background-position: center; background-repeat: no-repeat; } .douban-card-img { position: relative; height: 130px; width: 80px; background-size: 100%; background-position: center; background-repeat: no-repeat; } .douban-card-left:hover .douban-card-img { filter: blur(5px) brightness(0.6); transform: perspective(800px) rotateX(180deg); } .douban-card-left .douban-card-img { transition: all 500ms ease; } .douban-card-left { position: relative; display: flex; flex-direction: column; align-items: center; } .douban-card-left .douban-card-status { height: 130px; width: 80px; text-align: center; font-weight: bold; position: absolute; left: 0; top: 30%; transform: rotateX(180deg); backface-visibility: hidden; transition: all 500ms ease; } .douban-card-left:hover .douban-card-status { transform: perspective(800px) rotateX(0deg); } .douban-card-right { position: relative; display: flex; flex-direction: column; margin-left: 12px; font-size: 16px; font-family: \"Courier New\", Courier, monospace; line-height: 1.3; color: antiquewhite; } .douban-card-item { margin-top: 4px; } 余音绕梁 音乐名: 我怀念的 表演者: 孙燕姿 发行时间: 2007-03-09 评分: 9.3 .douban-card-block { display: flex; justify-content: center; align-items: center; width: 100%; max-height: 400px; } .douban-card { display: flex; margin: 30px 10px; padding: 15px; border-radius: 15px; position: relative; justify-content: center; align-items: center; overflow: hidden; color: antiquewhite; text-decoration: none; } .douban-card:hover { text-decoration: none; } .douban-card-bgimg { position: absolute; width: 115%; height: 115%; filter: blur(15px) brightness(0.6); background-size: 100%; background-position: center; background-repeat: no-repeat; } .douban-card-img { position: relative; height: 130px; width: 80px; background-size: 100%; background-position: center; background-repeat: no-repeat; } .douban-card-left:hover .douban-card-img { filter: blur(5px) brightness(0.6); transform: perspective(800px) rotateX(180deg); } .douban-card-left .douban-card-img { transition: all 500ms ease; } .douban-card-left { position: relative; display: flex; flex-direction: column; align-items: center; } .douban-card-left .douban-card-status { height: 130px; width: 80px; text-align: center; font-weight: bold; position: absolute; left: 0; top: 30%; transform: rotateX(180deg); backface-visibility: hidden; transition: all 500ms ease; } .douban-card-left:hover .douban-card-status { transform: perspective(800px) rotateX(0deg); } .douban-card-right { position: relative; display: flex; flex-direction: column; margin-left: 12px; font-size: 16px; font-family: \"Courier New\", Courier, monospace; line-height: 1.3; color: antiquewhite; } .douban-card-item { margin-top: 4px; } 参数阐述 第一项douban 代表插件名 第二项可选:movie,book,music 第三项请填入对应的id例如: 填写subject后面的那串数字就好","link":"/2020/07/08/Hexo%E8%B1%86%E7%93%A3%E6%96%87%E7%AB%A0%E6%8F%92%E4%BB%B6/"},{"title":"Hexo静态网站多线部署","text":"多线部署：将同一个域名解析到多个服务器，并让不同地区的用户访问不同地区的服务器，以获得最好的访问体验 ​ Hexo是静态网站，因此只需要服务器能够发送静态网页就足够了，国内的选择是coding pages或者是gitee pages但是后者码云的免费版并不能提供自定义域名服务，所以不予考虑。国外的可以选择 GitHub Pages。 ​ 🆗，首先你需要一个域名，然后在你的域名服务供应商那里做如下设置。 ​ 将域名的CNAME记录指向github page，此处需要DNS服务商提供对应的解析线路，将境外线路应用给github page,同理，将境内线路或是默认线路给到coding pages。 此处会遇到coding pages时常抽风导致无法访问的问题，我的建议是使用自己买的服务器来部署，虽然这样就脱离了使用静态网站的初心–省钱 ​ 然后在Hexo的发布选项中添加两个静态网页供应商的git地址。 123456789# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: github: git@github.com:TankNee/xxx.github.io.git coding: git@e.coding.net:tanknee/xxx.coding.me.git gitea: git@git.xxx.cn:tanknee/xxx.gitea.io.git branch: master 其中github和coding都提供了自动部署服务，所以就只需要提交代码到你对应的仓库就好了","link":"/2020/06/02/Hexo%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E5%A4%9A%E7%BA%BF%E9%83%A8%E7%BD%B2/"},{"title":"Hust 面向对象大作业","text":"新建任务 打开个人助理软件 点击右下角的ADD按钮，进入新建任务窗口 弹出创建任务的窗口 选择任务类型 填写任务内容 点击确认按钮，完成任务添加 [scode type=”share”]任务仓库地址：Java[/scode]","link":"/2019/11/16/Hust-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A/"},{"title":"Java String的一些问题","text":"[scode type=”share”]String str=new String(“abc”); 紧接着这段代码之后的往往是这个问题，那就是这行代码究竟创建了几个String对象呢？[/scode] [scode type=”blue”]相信大家对这道题并不陌生，答案也是众所周知的，2个。[/scode] [scode type=”green”] 接下来我们就从这道题展开，一起回顾一下与创建String对象相关的一些JAVA知识。 [/scode] 我们可以把上面这行代码分成 String str、=、&quot;abc&quot; 和 new String() 四部分来看待。String str只是定义了一个名为str的String类型的变量，因此它并没有创建对象；=是对变量str进行初始化，将某个对象的引用（或者叫句柄）赋值给它，显然也没有创建对象；现在只剩下new String(&quot;abc&quot;)了。那么，new String(&quot;abc&quot;)为什么又能被看成”abc”和new String()呢？ [scode type=”green”]我们来看一下被我们调用了的String的构造器： [/scode] public String(String original) { //other code ... } 大家都知道，我们常用的创建一个类的实例（对象）的方法有以下两种: 使用new创建对象。 调用Class类的newInstance方法，利用反射机制创建对象。 我们正是使用new调用了String类的上面那个构造器方法创建了一个对象，并将它的引用赋值给了str变量。同时我们注意到，被调用的构造器方法接受的参数也是一个String对象，这个对象正是&quot;abc&quot;。由此我们又要引入另外一种创建String对象的方式的讨论——引号内包含文本。 这种方式是String特有的，并且它与new的方式存在很大区别。 String str=&quot;abc&quot;; 毫无疑问，这行代码创建了一个String对象。 String a=&quot;abc&quot;; String b=&quot;abc&quot;;那这里呢？ 答案还是一个。 String a=&quot;ab&quot;+&quot;cd&quot;; 再看看这里呢？ 答案是三个。 说到这里，我们就需要引入对字符串池相关知识的回顾了。 在JAVA虚拟机（JVM）中存在着一个字符串池，其中保存着很多String对象，并且可以被共享使用，因此它提高了效率。由于String类是final的，它的值一经创建就不可改变，因此我们不用担心String对象共享而带来程序的混乱。字符串池由String类维护，我们可以调用intern()方法来访问字符串池。 我们再回头看看String a=&quot;abc&quot;;，这行代码被执行的时候，JAVA虚拟机首先在字符串池中查找是否已经存在了值为”abc”的这么一个对象，它的判断依据是String类equals(Object obj)方法的返回值。如果有，则不再创建新的对象，直接返回已存在对象的引用；如果没有，则先创建这个对象，然后把它加入到字符串池中，再将它的引用返回。因此，我们不难理解前面三个例子中头两个例子为什么是这个答案了。 只有使用引号包含文本的方式创建的String对象之间使用“+”连接产生的新对象才会被加入字符串池中。对于所有包含new方式新建对象（包括null）的“+”连接表达式，它所产生的新对象都不会被加入字符串池中，对此我们不再赘述。因此我们提倡大家用引号包含文本的方式来创建String对象以提高效率，实际上这也是我们在编程中常采用的。 栈（stack）：主要保存基本类型（或者叫内置类型）（char、byte、short、int、long、float、double、boolean）和对象的引用，数据可以共享，速度仅次于寄存器（register），快于堆。 堆（heap）：用于存储对象 –自定义的一些类，还有Java自带的一些相对而言比较高级的类 转载自云端飘 原文链接","link":"/2019/11/05/Java-String%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"},{"title":"Neeto - 为补全缺憾而生的Markdown编辑器","text":"这是一篇不断更新的文章 考察了很多的markdown编辑器，有做得很棒的，比如typora，我个人很喜欢这个编辑器，但是有几个我无法忍受的问题： 没有云文件系统 没有图床的支持 然后其他的比较完整的markdown编辑如MWeb和熊掌记，都只有mac版，而我的主力是win所以基本不可用。 正好最近学了electron和js，然后买了一本Electron跨平台开发，里面有几张讲到了文本编辑器的制作，我也就准备自己做一个满足个人需求的文本编辑器。 [button color=”info” icon=”” url=”https://github.com/TankNee/Neeto&quot; type=””]GitHub地址[/button] [button color=”success” icon=”” url=”https://git.tanknee.cn/tanknee/ElectronTest_MarkDownEditer&quot; type=””]Gitea地址[/button] [button color=”dark” icon=”” url=”https://neeto.cn&quot; type=””]GitPage[/button] ScreenShot： 语法演示： LaTex语法支持 Running Shot Neeto 在1.X版本中发展设想将来必定会实现的功能： 括号的自动补全 LaTex公式解析 图片粘贴后上传到图床，并用返回的链接替换输入 实现云笔记功能，但不保证实现云协作 实现网页端的后台管理系统，应该将会使用Java构建后台 将来有可能实现的功能： 主题系统 文件系统 设置界面 将来应该不会实现的部分： 云协作 插件系统 实时渲染–这个我暂时也没有找到合理的解决方式。 关于后台今天1.9，已经写了一部分后端，但是由于其他的项目，所以暂时还没有发不出来，不过已经在路上了。","link":"/2020/01/09/neeto/"},{"title":"Neeto - 我所期待的MD编辑器","text":"或许，这个简陋的项目更应该被称为Electron &amp;&amp; JavaScript 的最佳实践！ Neeto的起源最初这个项目是基于Steve Kinney的 《Electron跨平台开发实战》 一书第三章的Fire Sale项目。这本书写的挺好，通俗易懂，并且比较有借鉴价值。本来的计划是抛开那本书重新构建Neeto的架构，但有些代码我也不想做重复工作，所以就没有另开一个工程。 Neeto的背景这个项目用了很多node仓库里的第三方模块，没有这些模块我也很难在十天左右的开发工期里完成Neeto的编写。比较核心的有下面这几个： &quot;jquery&quot;: &quot;^3.4.1&quot; &quot;mdui&quot;: &quot;^0.4.3&quot;一个Google MD设计规范的UI库 &quot;showdown&quot;: &quot;^1.9.1&quot; Neeto使用的markdown语法解析器 &quot;showdown-highlight&quot;: &quot;^2.1.3&quot; showdown的代码语法解析插件 &quot;showdown-katex&quot;: &quot;^0.6.0&quot;showdown的LaTeX语法解析插件 &quot;simplemde&quot;: &quot;^1.11.2&quot; 替代原本的textarea组件，实现更加丰富的操作 不过我在写Neeto时基本没有用到当下流行的第三方库：Vue or React or Angular，因为我想要在下个版本中用Vue重写Neeto，有很多方面都有改进的空间。并且因为我是基本上用的纯JavaScript写的，所以好多地方都十分的原始而简陋。我执意用原生js写的另一个目的就是尽可能熟悉js的一些用法，包括回调，异步，非阻塞性等等。 Neeto的设计思路说到思路，不得提我最喜欢的Markdown编辑器-Typora 毫无疑问，我相信Typora一定是Windows与MacOs上最优秀的编辑器，简洁，功能丰富，设计优雅。我的数据结构复习与汇编复习都是用Typora完成的，它是如此的完美以至于让我都快忘记了它的一些瑕疵。 它所见即所得（WYSIWYG）的实现效果让我理所当然的觉得，一款编辑器不就应该这样吗。当你写下你的灵感，编辑器将你的灵感完整无误地渲染成你所想的样子。 因此我在改写之时，就准备将Typora作为Neeto最好的榜样，并且我希望能比Typora做的更好！ 所以说，这个项目更像是补全，弥补我在Typora中未能得到的遗憾： 自定义图片上传的图床√ 云笔记功能-未实现 一次写作，多个写作平台（知乎，微信，CSDN等）完整实现效果√ Web网页管理云笔记-未实现 小程序查看云笔记-未实现 可以比较清晰的看到，我所想要实现的几个需求基本上都与网络相关，而Typora给自己的定位就仅仅是 Readable &amp; Writable 读写是Typora的核心功能，可以预见，作者并不准备为Typora提供与网络相关的功能，在win与mac两个平台上，也仅仅只有mac可以用一个插件来上传本地图片。 Neeto的后期计划表里也有打算实现插件系统，不过应该会是很后面 我在这个版本Version_1.0.8中，使用json文件来存储图床的配置信息，这只是实验性的尝试，并不保证长期有效性 后续我会支持更多的图床，如阿里云OSS，腾讯云COS，七牛云CDN等等。 什么是图床:图床是网络图片的一种存储方式，Web页面通过一条URL来获取图片。用户将图片上传到图床之后，图床服务器返回一条JSON消息，其中包含上传图片的网络URL，使用图床给定的图片链接就可以在多个地方调用图片，而不会出现本地图片无法直接使用的尴尬场面。 一些简单的小功能的实现一键复制到微信公众号平台点击Neeto头部的菜单栏，可以看到文件菜单选项。 点击之后会出现复制成功的提示 然后直接前往微信公众号后台粘贴就可以实现带格式粘贴。 使用时需要注意的几个地方： 复制时使用的图片应为网络图片，如果使用本地图片会出现上传失败的问题？ 尽量使用体积小的图片。 图片上传技巧可以将图片直接拖入左侧的文本编辑区域，也可以用QQ，Wechat等软件的截图工具截图后，直接在文本编辑区内粘贴，粘贴成功后顶部会出现LightTip提示上传成功。 图片拖入后上传这个功能是基于原书上拖入事件更改的，但我觉得是一个很有意思的部分，可以通过这一部分理解JS的处理哲学。 123456789// 监听drop事件--JavaScript是事件驱动的smde.codemirror.on(&quot;drop&quot;, function (editor, e) { //获取文件对象 const file = getDroppedFile(e) //获取dataTransfer对象 var df = e.dataTransfer //处理文件 dealWithFile(file, df)}); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061const dealWithFile = (file, df) =&gt; { // 文件对象数组 var dropFiles = [] console.log(file) if (fileTypeIsSupported(file)) { // 如果这个文件是图片类型的，就去处理这个文件对象 if (file.type.indexOf(&quot;image&quot;) !== -1) { // 获取图片的File对象 if (df.items !== undefined) { // Chrome有items属性，对Chrome的单独处理 for (var i = 0; i &lt; df.items.length; i++) { var item = df.items[i]; console.log(item.getAsFile()) // 用webkitGetAsEntry禁止上传目录 if (item.kind === &quot;file&quot; &amp;&amp; item.webkitGetAsEntry().isFile) { var dropFile = item.getAsFile(); // 判断完这个对象之后压入数组中 dropFiles.push(dropFile); } } } // 上传到图床 dropFiles.forEach(file =&gt; { // formdata的作用是构建post的请求body部分 const formdata = new FormData() formdata.append('image', file) // loading是加载动画的一段语句，在图片上传的过程中用于占位 smde.codemirror.doc.replaceSelection(loading) if (baseConfig.picBedUrl) { uploadToPicBeds(formdata, baseConfig.picBedUrl, baseConfig.token) .then(res =&gt; { var finalUrl = `&lt;img src=&quot;${res}&quot;&gt;` smde.codemirror.doc.undoSelection() smde.codemirror.doc.replaceSelection(finalUrl) rendererMarkDownToHtml(smde.value()) //LightTip是LuLuUI库的一个组件，我认为挺好看的，所以很多地方都用到了这个组件 new LightTip().success('图床图片上传成功', 2000); }) .catch(res =&gt; { smde.codemirror.doc.undoSelection() new LightTip().error('图床图片上传失败，请检查图床配置', 4000); finalUrl = `![${file.name}](${file.path})` smde.codemirror.doc.replaceSelection(finalUrl) rendererMarkDownToHtml(smde.value()) }) } else { var finalUrl = `![${file.name}](${file.path})` smde.codemirror.doc.undoSelection() smde.codemirror.doc.replaceSelection(finalUrl) rendererMarkDownToHtml(smde.value()) new LightTip().success('本地图片添加成功', 2000); } }); } else { mainProcess.openFile(currentWindow, file.path) } } else { new LightTip().error('该文件类型暂时无法上传', 4000); }} 直面问题不得不承认，有很多地方我都没有做完，甚至完成度只有$60%$,但我急于进入Vue的学习开发，就不得不将纯JavaScript的版本早点完结。 左右界面的同步滚动问题，由于我一直找不到好的同步滚动解决方案，因此我采用的是两个显示部分距离顶部的长度相等，这样确实不太好很多时候都会出现奇怪的问题… 左侧UI布局不是特别的合理 很多按钮都是废弃的按钮，我已经没有什么精力去将他们一一修正了。 tasklist列表还是显示不正常 如果你使用了Neeto并且有任何意见或是反馈，请及时告知我，告知的方法也很简单，点击左侧下部的小飞机按钮，填写建议还有您的联系方式即可，万分感谢 附录MarkDown语法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Markdown GuideEmphasis**bold***italics*~~strikethrough~~Headers# Big header## Medium header### Small header#### Tiny headerLists* Generic list item* Generic list item* Generic list item1. Numbered list item2. Numbered list item3. Numbered list itemLinks[Text to display](http://www.example.com)Quotes&gt; This is a quote.&gt; It can span multiple lines!Images Need to upload an image? Imgur has a great interface.![](http://www.example.com/image.jpg)Tables| Column 1 | Column 2 | Column 3 || -------- | -------- | -------- || John | Doe | Male || Mary | Smith | Female |Or without aligning the columns...| Column 1 | Column 2 | Column 3 || -------- | -------- | -------- || John | Doe | Male || Mary | Smith | Female |Displaying code`var example = &quot;hello!&quot;;`Or spanning multiple lines...codevar example = &quot;hello!&quot;;alert(example);code LaTeX数学公式实现：支持LaTeX语法 $\\alpha, \\beta, \\Beta, \\gamma, \\Gamma, \\pi, \\Pi, \\phi, \\varphi, \\mu, \\Phi$ $\\cos(2 \\theta) = \\cos ^ 2 \\theta - \\sin ^ 2 \\theta$ $\\lim_{x \\to \\infty}^ (e^(-x)) = 0$ 写在最后说实话吧，好长一段时间里我都听不喜欢前端的，因为在我的刻板前端不就是切图吗，然后写点小动画，有什么前途，但是说来容易做时难啊，真正放开手去做的时候才能切身感受到前端也已经不仅仅是前端了，不过，还是要两头兼顾，前后端都要掌握。 最后一些屁话，应该没有人真的会看到这里吧。说真的，大学越活越糊涂我是真的有点难受，学习也整不起来，技术也学不明白，身体也没有很好//PS:本武汉（回来的）人已经14天未见异常了，所以我不是患者！！但是我好像有点感冒… 如果你对Neeto感兴趣可以前往Neeto官网 查看源码和更多信息，项目已经在GitHub和Gitea开源了，如果可以的话，能为我点个Star吗！！！！这对我真的很重要(cxx语气)","link":"/2020/01/21/neetoad/"},{"title":"Shell脚本编程最简尝试","text":"Shell每一个shell脚本都需要一个注解，形如 1#! /bin/bash 123$n 其中n为数字，是外界输入到脚本里的参数$0 代表文件本身$1 是第一个参数 读取外部文本内容并输出 123456#!/bin/bashwhile read linedo echo $linedone &lt; $1 其中$1是外部文件名，line是该文本里的每一行的内容。通过一个while循环输出文本内容。 本次作业： 12345678910#!/bin/bash# Line CountlineCount=0 # 初始化行计数器while read linedo echo $line # 输出每一行的内容 lineCount=`expr $lineCount + 1` # 行计数器自增done &lt; $1echo $lineCount # 输出行数","link":"/2020/03/09/556/"},{"title":"The Video Of WhuHan","text":"","link":"/2020/04/04/561/"},{"title":"Twenty","text":"本想写几句无关痛痒的话，放几张莫名其妙的图片就了事，但今天做完工程实训的答辩，确实有很多很多的话想说出来。无意写成实训的心得感悟，只是于此往前回顾时有种一眼万年的陌生感。一年多前，用着蹩脚的安卓写一个烂的不行的ToDoList现在想想虽然觉得有点可笑，但那种翻遍万书仍然不得答案的感觉仍然会一下涌上来。 成长这个词已经用烂了，我没有长大，我只是对这些都熟悉了，仅此而已。但我也拿不准我还是不是昨天躺下睡着前的那个我，或许是的，但为何今早掠过河边看对岸的藤架仍有种熟悉而陌生的感觉。 噩梦一则 Demo一支 彩蛋一副 一段简单的伪代码 1234567891011121314import AliPay from 'YourApps';import Content from 'ThisArticle'; var words = Content.words;var redPocketToken = words.map((word) =&gt; word.isBold).join('');AliPay.launch().then((AliPayMainScreen) =&gt; { var searchComponent = AliPayMainScreen.getSearchComponent(); searchComponent.search('红包').then((RedPocketPage) =&gt; { var redPocketTokenComponent = RedPocketPage.getRedPocketTokenComponent(); redPocketTokenComponent.search(redPocketToken).then(() =&gt; console.log('Congratulation!')); });}); Tips：如果你实在看不懂并且找不到口令，那我这提示也太没意思了。 近日观影一则 灯影绰约 电影名: 头文字D頭文字D(2005) 导演: 刘伟强/麦兆辉 主演: 周杰伦/陈冠希 上映时间: 2005-06-23(中国大陆/中国香港) 评分: 7.7 .douban-card-block { display: flex; justify-content: center; align-items: center; width: 100%; max-height: 400px; } .douban-card { display: flex; margin: 30px 10px; padding: 15px; border-radius: 15px; position: relative; justify-content: center; align-items: center; overflow: hidden; color: antiquewhite; text-decoration: none; } .douban-card:hover { text-decoration: none; } .douban-card-bgimg { position: absolute; width: 115%; height: 115%; filter: blur(15px) brightness(0.6); background-size: 100%; background-position: center; background-repeat: no-repeat; } .douban-card-img { position: relative; height: 130px; width: 80px; background-size: 100%; background-position: center; background-repeat: no-repeat; } .douban-card-left:hover .douban-card-img { filter: blur(5px) brightness(0.6); transform: perspective(800px) rotateX(180deg); } .douban-card-left .douban-card-img { transition: all 500ms ease; } .douban-card-left { position: relative; display: flex; flex-direction: column; align-items: center; } .douban-card-left .douban-card-status { height: 130px; width: 80px; text-align: center; font-weight: bold; position: absolute; left: 0; top: 30%; transform: rotateX(180deg); backface-visibility: hidden; transition: all 500ms ease; } .douban-card-left:hover .douban-card-status { transform: perspective(800px) rotateX(0deg); } .douban-card-right { position: relative; display: flex; flex-direction: column; margin-left: 12px; font-size: 16px; font-family: \"Courier New\", Courier, monospace; line-height: 1.3; color: antiquewhite; } .douban-card-item { margin-top: 4px; } 近日读书一则 见字如晤 书名: 人生海海 作者: 麥家 出版年份: 2019-7-1 评分: 8.4 .douban-card-block { display: flex; justify-content: center; align-items: center; width: 100%; max-height: 400px; } .douban-card { display: flex; margin: 30px 10px; padding: 15px; border-radius: 15px; position: relative; justify-content: center; align-items: center; overflow: hidden; color: antiquewhite; text-decoration: none; } .douban-card:hover { text-decoration: none; } .douban-card-bgimg { position: absolute; width: 115%; height: 115%; filter: blur(15px) brightness(0.6); background-size: 100%; background-position: center; background-repeat: no-repeat; } .douban-card-img { position: relative; height: 130px; width: 80px; background-size: 100%; background-position: center; background-repeat: no-repeat; } .douban-card-left:hover .douban-card-img { filter: blur(5px) brightness(0.6); transform: perspective(800px) rotateX(180deg); } .douban-card-left .douban-card-img { transition: all 500ms ease; } .douban-card-left { position: relative; display: flex; flex-direction: column; align-items: center; } .douban-card-left .douban-card-status { height: 130px; width: 80px; text-align: center; font-weight: bold; position: absolute; left: 0; top: 30%; transform: rotateX(180deg); backface-visibility: hidden; transition: all 500ms ease; } .douban-card-left:hover .douban-card-status { transform: perspective(800px) rotateX(0deg); } .douban-card-right { position: relative; display: flex; flex-direction: column; margin-left: 12px; font-size: 16px; font-family: \"Courier New\", Courier, monospace; line-height: 1.3; color: antiquewhite; } .douban-card-item { margin-top: 4px; } 近日听歌一首 余音绕梁 音乐名: 我怀念的 表演者: 孙燕姿 发行时间: 2007-03-09 评分: 9.3 .douban-card-block { display: flex; justify-content: center; align-items: center; width: 100%; max-height: 400px; } .douban-card { display: flex; margin: 30px 10px; padding: 15px; border-radius: 15px; position: relative; justify-content: center; align-items: center; overflow: hidden; color: antiquewhite; text-decoration: none; } .douban-card:hover { text-decoration: none; } .douban-card-bgimg { position: absolute; width: 115%; height: 115%; filter: blur(15px) brightness(0.6); background-size: 100%; background-position: center; background-repeat: no-repeat; } .douban-card-img { position: relative; height: 130px; width: 80px; background-size: 100%; background-position: center; background-repeat: no-repeat; } .douban-card-left:hover .douban-card-img { filter: blur(5px) brightness(0.6); transform: perspective(800px) rotateX(180deg); } .douban-card-left .douban-card-img { transition: all 500ms ease; } .douban-card-left { position: relative; display: flex; flex-direction: column; align-items: center; } .douban-card-left .douban-card-status { height: 130px; width: 80px; text-align: center; font-weight: bold; position: absolute; left: 0; top: 30%; transform: rotateX(180deg); backface-visibility: hidden; transition: all 500ms ease; } .douban-card-left:hover .douban-card-status { transform: perspective(800px) rotateX(0deg); } .douban-card-right { position: relative; display: flex; flex-direction: column; margin-left: 12px; font-size: 16px; font-family: \"Courier New\", Courier, monospace; line-height: 1.3; color: antiquewhite; } .douban-card-item { margin-top: 4px; } 谢谢你看到这里","link":"/2020/07/04/twenty/"},{"title":"WordPress开启https失败后无法打开网站问题的解决办法","text":"本来想着看这个Chrome提示的不安全标志很不舒服，就准备开启https提升网站的安全性。但是万万没有想到这才是噩梦的开始。我在阿里的SSL证书管理那里买了免费的ssl证书，然后给TankNee‘s Blog解析上去，然后发现没什么用，查阅了网上的其他人的博客之后把WordPress设置里的域名设置直接给改了，我真的是哭了，然后就出现了怎么样都进入不了网站，连后台都访问不了。 不过仔细看看问题的原因还是很简单的，因为你把http改成了https而你其他部分却还没有配置好。我预估这里跟.htaccess 这个文件也有点关系，所以我就不准备这么搞了。但是后台进不去根本就改不回来了啊，于是乎就接着找，根据网上的指导，重新改回来的本质方法就是把数据库里存着的那行条例改成http就好了。 但是我有没有MyPHPadmin，那可怎么办呢？ 于是我就决定用ssh终端来修改。 用终端连接服务器。 mysql -u root -p 输入你的密码 show databases; //切记最后要加分号，不然无法识别语句的结束 use wordpressdb; //不是那个名为wordpress的数据库 show tables; 选取需要修改的行，查看当前的数据select * from wp_options where option_id = 1; //这里option_id是一条字段全部字段在这里：option_id | option_name | option_value | autoload 修改/更新当前行：update wp_options set option_value = 'http://yoursite.com' where option_id = 1; 再修改option_id=2的那一行 select * from wp_options where option_id = 2; update wp_options set option_value = 'http://yoursite.com' where option_id = 2; 然后直接打开域名就可以看到已经可以访问了。","link":"/2019/08/29/536/"},{"title":"WordPress数据库连接失败问题","text":"今天打开博客的时候遇到了一个错误提示：Error establishing a database connection随后去百度寻找解决办法。 重启Apache服务器 ： service httpd restart 这个方法失败，并且第一次直接重启的时候过程非常的缓慢，具体原因并不知晓。 修改 wp-config.php 文件，添加define('WP_ALLOW_REPAIR', true);，然后重启服务器。不过这个方法也失败，没有起作用 打开终端，登录mysql ：mysql -u root -p,会发现无法登录，如果报错是Can't connect to local MySQL server through socket '/var/lib/mysql/mysql.sock' (111) 那么直接重启MySQL服务器就好service mariadb start 。我遇到Can't connect to local MySQL server through socket '/var/lib/mysql/mysql.sock' (2) 也是可以这么解决。 至此问题结束！!","link":"/2019/08/30/535/"},{"title":"一月January","text":"[Meting][Music server=”netease” id=”208902” type=”song”/][/Meting] 刚刚在翻以前写的博客时，突然想起来自己还没有写一月份的博客 习惯性的想要给文章找一首歌，但因为这两天一直在家里，基本上就没怎么听歌，歌单里最新收藏的是蔡健雅的红色高跟鞋，没什么寓意，就是觉得熟悉，便收藏了。 三号早上考完了大物，自信满满地走出考场，结果到头来只有那么点分数，可能我是真的不配学物理，当然，汇编，数据结构，Java我大概也是都不配学的。 算了，好歹都过了，我就不强求了。 这个月随缘做项目，其实也不知道为了什么，可能就是为了开心吧，感觉这个寒假连游戏都没代码有意思，靠，这还是我吗，我震惊了。 根据一本electron的入门指导书做了一个简单的markdown编辑器，修修改改，甚至还想着用vue重写，但是应该是会懒得写了，也不一定是吧，说不定我开心我就写了呢？ Neeto Markdown Editor 其实我写的还是挺漂亮的对吧…基本的功能我还是都做完了的呢。但是为什么没人给我⭐..//小声逼逼 刚做完markdown编辑器，冠状病毒就爆发了，前前后后去检查了好几次，被人用枪测了好几次体温，尽管如此，我还是不放心，花了两百大洋去乐清医院挂了号，拍了CT，最后当然是p事没有，有时候会肉疼自己的两百块钱，但一想到不测的话就会心慌好久，就没那么肉疼了。 之后又看到丁香园出的疫情地图，信息很全，正好手边也在看node js，就准备整一个疫情数据的接口，然后开放开源//收割⭐，走上人生巅峰（大雾）。 不过确实靠着这个项目拿到了目前为止最多的⭐（7个），每天早上爬起来看到⭐数目变多，api使用数增加就感到特别的满足，可能这就是程序员吧？ WuHan-nCoV-2019-DataAPI 手头还有两个在做的项目，我真的是精力充沛…希望不会秃的太早吧 武汉加油，温州加油，我想吃糯米饭（哭腔）","link":"/2020/02/03/%E4%B8%80%E6%9C%88Jan/"},{"title":"WuHan-nCoV-2019疫情数据接口","text":"nCov-DataCollect 本接口又复活辣，3.2更新，请移步GitHub [button color=”info” icon=”” url=”https://github.com/TankNee/nCoV-2019-DataAPI&quot; type=””]Github地址[/button] 数据来自丁香园 [scode type=”red”]武汉加油，温州加油[/scode] 本项目基于nodejs-express框架构建，使用正则表达式爬取页面信息 数据可视化查看地址管理后台 登录用户名 ： demo 登录密码：demo 模板来源：lin-xin api接口地址基础URL： http://ncov.tanknee.cn/api/ 获取后台数据库中的最新数据： http://ncov.tanknee.cn/api/ 请求方法： GET 返回实例: 只截取了部分数据 1234567891011121314151617181920212223242526272829&quot;sumInfo&quot;: { &quot;id&quot;: 1559, &quot;confirmedCount&quot;: 7830, &quot;curedCount&quot;: 135, &quot;deadCount&quot;: 170, &quot;suspectedCount&quot;: 12139, &quot;addtime&quot;: 1580387755098 }, &quot;provinceInfo&quot;: [ { &quot;id&quot;: 19270, &quot;provinceName&quot;: &quot;湖北省&quot;, &quot;provinceShortName&quot;: &quot;湖北&quot;, &quot;confirmedCount&quot;: 4586, &quot;suspectedCount&quot;: 0, &quot;curedCount&quot;: 90, &quot;deadCount&quot;: 162, &quot;addtime&quot;: 1580387755098, &quot;cities&quot;: [ { &quot;id&quot;: 176949, &quot;cityName&quot;: &quot;武汉&quot;, &quot;provinceShortName&quot;: &quot;湖北&quot;, &quot;confirmedCount&quot;: 2261, &quot;suspectedCount&quot;: 0, &quot;curedCount&quot;: 54, &quot;deadCount&quot;: 129, &quot;addtime&quot;: 1580387755098 },.... 返回实例参数： 参数名称 参数类型 备注 provinceName String 省份全名 provinceShortName String 省份短名 cityName String 城市名称 confirmedCount number 确诊人数 suspectedCount number 疑似人数 curedCount number 治愈人数 deadCount number 死亡人数 addtime number 爬取时间 获取实时数据： http://ncov.tanknee.cn/api/realtime 请求方法： GET 获取疫情总和数据的全部历史数据： http://ncov.tanknee.cn/api/sum 请求方法：GET 获取单一省份的最新数据： http://ncov.tanknee.cn/api/province 请求参数： 参数名称 参数类型 备注 province String 省份名称 all String 是否获取全部历史消息，默认为false 请求方法： POST 返回实例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126{ &quot;provinceInfo&quot;: [ { &quot;id&quot;: 5944, &quot;provinceName&quot;: &quot;浙江省&quot;, &quot;provinceShortName&quot;: &quot;浙江&quot;, &quot;confirmedCount&quot;: 173, &quot;suspectedCount&quot;: 0, &quot;curedCount&quot;: 3, &quot;deadCount&quot;: 0, &quot;addtime&quot;: 1580224800003 } ], &quot;citiesOfProvince&quot;: [ { &quot;id&quot;: 47028, &quot;cityName&quot;: &quot;温州&quot;, &quot;provinceShortName&quot;: &quot;浙江&quot;, &quot;confirmedCount&quot;: 60, &quot;suspectedCount&quot;: 0, &quot;curedCount&quot;: 3, &quot;deadCount&quot;: 0, &quot;addtime&quot;: 1580224800003 }, { &quot;id&quot;: 47029, &quot;cityName&quot;: &quot;杭州&quot;, &quot;provinceShortName&quot;: &quot;浙江&quot;, &quot;confirmedCount&quot;: 32, &quot;suspectedCount&quot;: 0, &quot;curedCount&quot;: 0, &quot;deadCount&quot;: 0, &quot;addtime&quot;: 1580224800003 }, { &quot;id&quot;: 47030, &quot;cityName&quot;: &quot;台州&quot;, &quot;provinceShortName&quot;: &quot;浙江&quot;, &quot;confirmedCount&quot;: 22, &quot;suspectedCount&quot;: 0, &quot;curedCount&quot;: 0, &quot;deadCount&quot;: 0, &quot;addtime&quot;: 1580224800003 }, { &quot;id&quot;: 47031, &quot;cityName&quot;: &quot;宁波&quot;, &quot;provinceShortName&quot;: &quot;浙江&quot;, &quot;confirmedCount&quot;: 17, &quot;suspectedCount&quot;: 0, &quot;curedCount&quot;: 0, &quot;deadCount&quot;: 0, &quot;addtime&quot;: 1580224800003 }, { &quot;id&quot;: 47032, &quot;cityName&quot;: &quot;嘉兴&quot;, &quot;provinceShortName&quot;: &quot;浙江&quot;, &quot;confirmedCount&quot;: 11, &quot;suspectedCount&quot;: 0, &quot;curedCount&quot;: 0, &quot;deadCount&quot;: 0, &quot;addtime&quot;: 1580224800003 }, { &quot;id&quot;: 47033, &quot;cityName&quot;: &quot;绍兴&quot;, &quot;provinceShortName&quot;: &quot;浙江&quot;, &quot;confirmedCount&quot;: 7, &quot;suspectedCount&quot;: 0, &quot;curedCount&quot;: 0, &quot;deadCount&quot;: 0, &quot;addtime&quot;: 1580224800003 }, { &quot;id&quot;: 47034, &quot;cityName&quot;: &quot;金华&quot;, &quot;provinceShortName&quot;: &quot;浙江&quot;, &quot;confirmedCount&quot;: 7, &quot;suspectedCount&quot;: 0, &quot;curedCount&quot;: 0, &quot;deadCount&quot;: 0, &quot;addtime&quot;: 1580224800003 }, { &quot;id&quot;: 47035, &quot;cityName&quot;: &quot;衢州&quot;, &quot;provinceShortName&quot;: &quot;浙江&quot;, &quot;confirmedCount&quot;: 5, &quot;suspectedCount&quot;: 0, &quot;curedCount&quot;: 0, &quot;deadCount&quot;: 0, &quot;addtime&quot;: 1580224800003 }, { &quot;id&quot;: 47036, &quot;cityName&quot;: &quot;丽水&quot;, &quot;provinceShortName&quot;: &quot;浙江&quot;, &quot;confirmedCount&quot;: 5, &quot;suspectedCount&quot;: 0, &quot;curedCount&quot;: 0, &quot;deadCount&quot;: 0, &quot;addtime&quot;: 1580224800003 }, { &quot;id&quot;: 47037, &quot;cityName&quot;: &quot;舟山&quot;, &quot;provinceShortName&quot;: &quot;浙江&quot;, &quot;confirmedCount&quot;: 4, &quot;suspectedCount&quot;: 0, &quot;curedCount&quot;: 0, &quot;deadCount&quot;: 0, &quot;addtime&quot;: 1580224800003 }, { &quot;id&quot;: 47038, &quot;cityName&quot;: &quot;湖州&quot;, &quot;provinceShortName&quot;: &quot;浙江&quot;, &quot;confirmedCount&quot;: 3, &quot;suspectedCount&quot;: 0, &quot;curedCount&quot;: 0, &quot;deadCount&quot;: 0, &quot;addtime&quot;: 1580224800003 } ]} 返回实例参数： 参数名称 参数类型 备注 provinceName String 省份全名 provinceShortName String 省份短名 cityName String 城市名称 confirmedCount number 确诊人数 suspectedCount number 疑似人数 curedCount number 治愈人数 deadCount number 死亡人数 addtime number 爬取时间 获取单一城市的全部信息： http://ncov.tanknee.cn/api/city 请求参数： 参数名称 参数类型 备注 cityname String 城市名称 all String 是否获取全部历史消息，默认为false 请求方法： POST 返回实例：123456789101112[ { &quot;id&quot;: 46994, &quot;cityName&quot;: &quot;武汉&quot;, &quot;provinceShortName&quot;: &quot;湖北&quot;, &quot;confirmedCount&quot;: 1590, &quot;suspectedCount&quot;: 0, &quot;curedCount&quot;: 47, &quot;deadCount&quot;: 85, &quot;addtime&quot;: 1580224800003 }] 返回实例参数： 参数名称 参数类型 备注 provinceShortName String 省份短名 cityName String 城市名称 confirmedCount number 确诊人数 suspectedCount number 疑似人数 curedCount number 治愈人数 deadCount number 死亡人数 addtime number 爬取时间","link":"/2020/01/29/ncov/"},{"title":"七月July","text":"深夜，暴雨和雷霆 写总结这件事情其实已经在我的待办事项里面躺了很久了，每周写周报好像已经不太现实了，太懒了，没得救了。 七月有三十一天 前十天庸庸碌碌，磨蹭着写了五六天的C++，最后写出来一个半死不活的记账本，好像确实除了一些搬砖的内容之外就没学到什么东西了。 然后在寝室躺了两天，期间和来武汉的zzl畅谈了好几个晚上，确实也挺开心的吧。不能总把新老朋友拿来比较，不同的人都有不同的特点 而后十二号便去了南京。南京真是一个从名字开始就让我很喜欢的城市，没有北京给人的那种霸道，也没有扬州给以我的小家气魄。要不是考不上南大，我肯定去南京（假装马后炮）。//大牌档太好吃了，我永远爱南京大牌档 再后来又去了镇江，去了扬州，不知在这三四个火车站里来来回回上上下下了多少遍。有感叹过江苏城市的破旧和朴素，也会感慨江南小镇的秀丽和精致，有对京杭运河的无言，亦有对运河边声浪滔滔的广场舞的欲言又止。真像是活在过去的人，却又挂着今人的衣裳。 在青松客栈的老爷爷家里躺到17号后，就坐着老爷爷的小电瓶，离开了。也顺便见识了一下扬州站火车汽车一家亲的神奇建筑规划。 暑假是从第十七天开始的 先是被拉去活活当了四五天的苦工，整天扒拉这块的废料，或者打包纸箱，或者打打表格，然后就又是瘫了四五天，整天鼓捣服务器，网站，本事没学到什么，倒是命令行越打越能耐了，也慢慢的喜欢上了OS X，苹果家的玩意儿真是好看，没有话说。（MacBook Pro Yes！！！）等我有钱了一定去买一台真的MacBook Pro。 确实慢慢看淡放轻松了很多，也不再死磕一个死胡同了。明白了差别，也就不会接着跟自己赌气了。没意义。 再多的思考也抵不过晚间趴在桌子上时模糊而撕裂的痛苦。就像是从家里出门等公交，却突然发现家里的钥匙没带，而且门还没关，这时你往前走也好，死命往回跑也好，都阻止不了你将会晒到双倍的太阳的事实。 诶，有时候下雨还挺美好的","link":"/2019/08/06/179/"},{"title":"三月March","text":"鬼知道我这个月经历了什么东西。 每日高强度Coding，我都怀疑自己已经不太像个正常人了… 原来我也会有对着电脑感到生理性呕吐的时候.. 昨天人机交互课上老师随口一句：高考都要延迟了，你们开学是别想了 等疫情过了想出去好好看看…毕竟谁也不想永远呆在家里。 一代宗师：宗师，一代（人）前两天抽空看了一代宗师，说来惭愧，以前一直以为一代宗师是指的叶问四部曲的第一部，后来才明白是王家卫的电影。王家卫的电影看的很少，基本算是没有吧，最近的一次交集应该是知道了《大话西游之大圣娶亲》里那句流传甚广的爱你一万年是出自他的《重庆森林》。 一代宗师更像是一部小说，对白更多的辅助人物形象的刻画，以及时代特征的描述，而不是像更多的武侠电影那样去推动剧情的发展。 一如其冷静，不占烟火气的格调。 如果人生有四季，四十岁前，我的人生都是春天。 做羹要讲究火候。火候不到，众口难调，火候过了，事情就焦。做人也是这样。 暗事好做，明事难成。 宝森不是想当英雄，是想造时势。现在这炉子里，需要这根新柴。 让他搭手多大的面子，姓叶的不识抬举，咱可不要坏了规矩。 别跟他们一般见识，老人死守着规矩，新人什么时候才能出头啊。叶问是个好材料，就看他这次能不能出头。宫家没有败绩，您又在这儿，他凭什么出头。 你的脾气啊，就是爹年轻的时候。眼睛里只有胜负，没有人情世故。人要往远看，过了山，眼界就开阔了。但凡一个人见不得人好，见不得人高明，是没有容人之心。咱们宫家的门槛高，但是不出小人。 人活这一世，能耐还在其次。有的成了面子，有的成了里子，都是时势使然。这次让你下来，是想求个始终，让你看看，爹是怎么退下来的。你从小是看着我跟人交手长大的，这是最后一次。你是订了亲的人了，江湖的事，和你没关系。当个好大夫，平平安安的，就是尽孝心了。 台词剪辑 日丽风和，云销雨霁","link":"/2020/04/03/560/"},{"title":"中秋快活噢","text":"不管生活怎么样 一定要快乐啊，哈哈哈哈哈哈 好久没有来这里写了，最近一直在上课，虽然课表不是很满，但是确实是没有精力来照顾博客了。本来昨天是要写周报的日子，但是我忘记了哈哈哈哈哈，算了，不打紧。 我永远爱加冰的红茶拿铁 南京大牌档的梅香排骨真的是太好吃了！！ 生活可期！ 中秋快乐哈哈哈哈哈！！ 但是这个怎么不显示了，我好气？？？？","link":"/2019/09/13/%E4%B8%AD%E7%A7%8B%E5%BF%AB%E6%B4%BB%E5%99%A2/"},{"title":"九月September","text":"有点恍惚，突然就十月份了 九月就这么过去了lpl的三只去S9的队伍也出来了，虽说今年确实没什么希望，但我还是觉得会有一个好成绩，没什么可说的，今年的电子竞技基本全线爆炸，能赢就好。 九月相比八月也多做了很多事情！开了新的三个站：可道云盘，cheveretor图床，微擎，虽然最后一个还没有投入使用，但是小程序也是我接下来的一个目标吧！域名这件事情有一点点拖沓，管理局到现在还没有审核出来，不知道能不能通过，毕竟接下来我都要上课，估计很难接到电话。 开学的新鲜感在这一个月的时间里也逐渐消磨光了，我也慢慢的失去了学车的热情，国庆没有去过驾校一次，感觉接下来也不太可能回去学车了，不过我还是要尽量去看看。钱都用了，总要拿点什么回来！ 还有就是呢通过了笔试，接下来估计要去参加他们的面试了，我自己估量了一下，是有点菜，什么都没有学会，flappy bird也做的稀烂，readme还有一大堆没有完成，我真的好慢啊，有点扰心。 不过呢，还是保留一分努力的念头，毕竟国庆玩的还是挺开心的。 最近有点疯狂种草相机，想要拥有一台自己的微单，看好Sony α6000，不过二手都要2500+有点承受不住，最近已经尽量在省钱了，希望在寒假出去玩之前拥有hhh，虽然我知道不太可能。 还想说什么来着。看了《我和我的祖国》，真的有点想泪涌，有几个片段确实很感人，最喜欢升旗还有夺冠，白昼流星拍得有点智障，和其他的有比较大的差距，有点反感。 还有几个目标，直接写在这里： 完成flappy bird 全站https 了解css，给导航栏写一个下划线动画 通过dian的熬测，或者是为熬测做一些准备。 先这些吧。万事安好 [scode type=”blue”]下面是前几个月的总结[/scode][post cid=”179” /]","link":"/2019/10/07/%E4%B9%9D%E6%9C%88September/"},{"title":"二月February","text":"闰年的二月也没有比普通年份的二月更加特别 在家里的生活平淡的像一盆水，翻不出什么花样。每天早上起来：八点了，那就再睡半个钟头，才七点？那就玩会儿手机，然后跑到电脑前上神经兮兮的网课。 网课很好的证明了大学里上不上课基本上是没什么区别的，除非你真的在听课？你不会真的有听课吧？ 25号的时候村里终于开放了出去的权限，只有血统纯正的村里人，才能进出无阻，甚至还能在路边打到滴滴。 那天碰见的滴滴司机是个外省人，老婆孩子都回去了，疫情爆发，自己没来得及回家，导致现在一个人待在异乡，连吃了半个月的面，最后两天甚至连菜叶都没有，迫不得已去拿隔壁阿婆的菜。 无心评价对错。 村里不给外村人发配菜，外村人家里弹尽粮绝，隔壁阿婆蔬菜满园。 怎么个选法也不必多说吧。反正我家还有火锅吃。 前几天还看到站在KFC门口点外卖的段子，愣是让外卖小哥站着血赚配送费，没想到自己到了KFC门口时，也活成了段子… 日子也没啥过头，天天歌舞升平，看片吃肉 这一个月看的电影，怕是比我前几年加起来看的都多。在家里把公立里祖传的投影仪架起来，投在家里那面潮的不行的破墙上，看着还挺舒服哈哈哈。 恐怖直播","link":"/2020/03/02/555/"},{"title":"九月二十一日纪实","text":"让我康康我今天都做了什么事情今天确实还是做了很多事情的hhhh 早上搭建了图库 - 然后配置了一下iterm2终端，oh my zsh的主题还不错 不过我还是感觉图床的响应速度没有那么快，加载比较慢 还有就是mac风格代码块的插件添加，我真的好喜欢这个风格的代码块，虽然做不到原作者那么完美哈哈哈12&lt;?php echo 'hello jrotty!'; ?&gt;高亮测试 1printf(&quot;Hello World&quot;); 没想到换了域名之后访问的人这么少，真的有点难过，我以为总会有几个的。算了，等过几天域名备案之后应该就会有所改善吧哈哈哈","link":"/2019/09/21/%E4%B9%9D%E6%9C%88%E4%BA%8C%E5%8D%81%E4%B8%80%E6%97%A5%E7%BA%AA%E5%AE%9E/"},{"title":"五月May","text":"提笔落字时总觉自己文疏才浅，阅历浅薄，无从着笔。 五月共三十一天，步数超过3000的日子大概不足十天，倒是出去吃饭吃了很多次。 一号结束了为期两个月的打工生涯，小半年也算是搞到了第一笔大额资金。 八号往鹅厂投了简历，挣扎了两三天，终是没过，虽然也没给原因，大概就是因为我太菜了吧，一问三不知。 2020年5月8日 电话面试，深圳总部面试 dom事件的冒泡与捕获 CSS中的样式优先级是怎样分布的 React-Native的底层实现，是如何与原生系统进行交互的 算法题：找出一个字符串的最长重复子序列 2020年5月15日 电话面试，武汉腾讯 JavaScript原型链的实现（不了解） http协议中数据传输的编码方式，发送json格式的数据时的content-type 说一下auth2.0 说一下当下前端框架对Dom做了哪些优化 用户登录的实现 使用了什么加密方式–jwt jwt有什么缺点 session和cookie 讲一下MySQL的索引实现（不了解） 明年再努力吧。","link":"/2020/06/01/569/"},{"title":"人心中的成见是一座大山","text":"很抱歉引用了哪吒里的一句流行台词，但却是时下没有比这句话更好的表达方式了。 可能是带节奏的言论看多了的原因，经常看到某些文章就冒火，但是很多时候骂也不是，不骂也不是，心里堵得慌，这世上的傻逼还是很多的，微博，自媒体占一大半，妈的，一群垃圾，毁坏我的资讯内容质量，真他妈是社会的毒瘤。 下面是我觉得这两天看到的比较多的几点： 华为与其他各个厂商的对立男女两性的对立国外媒体言论的愚蠢 诚然，我认为最主要的原因只有一个：信息不对称！ fine，以今天上了知乎热榜的那个关于穿衣自由的文章来说吧。 公众号的读者与公众号的作者的地位是绝对不平等的。公众号只会给你他想要展示的那部分思想，真正的有力度的反驳的言论他根本不会放出来，不过这也很好理解，毕竟作为情感类公众号（？）还是需要一个良好的社会人设的。 其实我也很奇怪，好好的影评不写为什么要去掺一脚穿衣不自由这个很容易引发社会讨论的话题。 可能是为了流量吧。不过也必然是为了流量。 当进入她的公众号时，我就已经失去了所谓的言论自由，我的语言表达能力不好，难以描述那种如鲠在喉的难受。如果问我还有什么类似的感受的话我觉得就是微博粉丝控评吧，硬生生把正常的宣传变成垃圾流量明星的垃圾作品宣展会，草，一群铁憨批。不过至少微博还有正常人能转发再评论，让我等低贱路人有机会看上一眼正常人的想法。 而公众号就不一样了，他是100%控评，他甚至还可以专门挑出几个被带上了预定节奏的憨憨拉出来批斗一下以表自己的委屈？！！！！ 呵呵，本来不想对其中的内容做什么评价，但是在知乎看到了编者来主动回答这个问题，真的是忍不住来骂人了，妈的垃圾。 第一点你提了国外，他们就会觉得你崇洋媚外 在？您是憨批吗？ 用几天短暂的旅游来定义国外开放自由的穿衣习惯 ？ 用国外懒得鸟你的相对更孤僻的社会人格来证明外国人的眼光更加的开放？ 用中东地区，韩国，比利时没有自由的例子来举证中国女性应该接着去争取获得自由？ 第二点你说人言可畏，大家要尊重，他直接告诉你国家没有不让，中国很自由，你写个屁。所以到底为什么那天我帮男性发生的时候风平浪静，大部分女生在留言区都表示反思，到了女性这里就成了这样。你们真是最魔幻的一群中国互联网冲浪手没搞清楚黑白就颐指气使的样子，真他妈丑。 我只想说，看你气急败坏没办法控制舆论的样子，真他妈爽。 这他妈这么简单的一个道理你个做互联网自媒体的会想不清楚吗？ 你让男性看美女你他妈还不允许别人评价，顺便给别人扣上了大帽子说你这是阻碍女性的穿衣自由？ 我可透你个嘴，代码都写不过来谁他妈有兴趣看美女。 而且，大多数男生who tm care 你管不管我穿什么？ 我觉得男性真的很懒，不过你如果指责我，我一定要找你茬。 我为什么没有对前面的话作解释，因为我觉得他说的对，知乎上大多数的高赞也不过是照着格式重新写了一遍，但是这并不是指责的理由。 就允许你们发流量不允许大家伙蹭流量吗？ Fine 我今天也是一个被节奏带走的人呢 冷静下来想想这究竟是为什么。 是闲的太慌了没事情？ 是九年义务教育没学好智商低？ 或许都是。 不过最近只要看到说什么要为女性争取这个权利争取那个权利的言论就很反感，因为这些言论里有一半是没有正视男女的个体生理差异，还有另外一半是对这个社会的高度不信任与敏感。 恕我直言，在我的认知里女性的生存环境已经比别的性别要好得多的多了。 或许这就是我心中的成见，我跟前的大山。","link":"/2019/08/13/%E4%BA%BA%E5%BF%83%E4%B8%AD%E7%9A%84%E6%88%90%E8%A7%81%E6%98%AF%E4%B8%80%E5%BA%A7%E5%A4%A7%E5%B1%B1/"},{"title":"从wordpress转移到typecho","text":"我真的是受够了臃肿的wordpress！！！ 诚然，wp很完善，该有的功能wp都有，而且十分的便捷，后台的管理系统也比typecho要完善的多得多得多，但是问题也出现的比typecho要多。访问速度也不如te。 这一次迁移遇到了很多的事情，不过还行都一一解决了。 在使用wordpress2typecho这个插件时出现数据库查询失败的问题，查询百度后得出解决办法： 首先是要开启debug模式，然后发现问题是typecho的数据库有一个字段的预设容积太小了，装不下wordpress的数据，于是我用phpadmin打开数据库，把agent这个字段扩大了十倍，然后就转移成功了 还有一个问题就是固定链接一直不好用，导致网址里面出现index.php非常的不雅观，查询之后给出解决办法： 在宝塔管理面板里把typecho的伪静态改为typecho模式然后重启服务器，最后在typecho的设置里更改就好了。 今天即刻把手机壳寄给我了，但是我已经申请退款了啊，我好烦躁，寄回去好像又要花自己的钱，我真的是欲哭无泪，感觉要把钱打水漂了，真的是好烦…. 这个服务器还有好久才满三个月，我估计满三个月之后再去域名备案也要搞好久好久，要不是国外的太贵了，谁愿意这要搞呢..我心累。","link":"/2019/09/19/%E4%BB%8Ewordpress%E8%BD%AC%E7%A7%BB%E5%88%B0typecho/"},{"title":"冬至愉悦","text":"美好冬至的清晨，是在九点半醒来的 我总是觉得冬至不是已经过了吗，后来想想那个好像是立冬？但是为什么过了立冬才是冬至？？这两个难道不是同一个意思吗？？？今日疑惑 惭愧，我拿着汤圆钱去吃了饺子我是南方人的叛徒，我认罪。 这是2019年的倒数第九天，也是我来学校的第一百二十六天，二十一世纪10年代的最后一年还有不到百分之三的余额，大家也都别冲值了，不会变强的,只会变秃。 前几天在网上遇见一个自称患了抑郁的网友我希望他是假的，但我也希望他能好起来，不管是哪种情况。 害，说到出去看看，我都多久没有出学校大门了。 最近受某位脸大的朋友影响，开始点评吃过的饭菜？ 冬至，年近，归程不远 大家冬至快乐","link":"/2019/12/22/%E5%86%AC%E8%87%B3%E6%84%89%E6%82%A6/"},{"title":"你好，武汉","text":"认识武汉的第354天 Countdown！ 来了江城这么多天，终于记起来可以去江滩看看！ 江滩✅ 在没有风的江岸走才能真实的感受到武汉这个大农村的闷热，西岸的高楼很多，最高的那座甚至还在施工，确实也挺符合武汉大工地的社会定位。 和傻蝉玩气枪打气球，打了十枪才中了两个？还是三个，被老板娘嘲讽 的无地自容，气死我了！！？？ 江景还是挺漂亮的，七点过半，西岸的楼市全都亮起灯来，有点像农村的社会哥亮出自己的金板牙。 7：00的江滩 7：30的江滩 还有彻夜轰鸣的长江大桥，桥下日夜不息的笙歌（实际上是大妈的广场舞）。 甚至复兴路的地铁站也挺有意思 fine，今天除了气枪和那碗一般般的冰粉都挺完美的。","link":"/2019/08/20/%E4%BD%A0%E5%A5%BD-%E6%AD%A6%E6%B1%89/"},{"title":"凌波日出","text":"[Meting][Music server=”netease” id=”23705316” type=”song”/][/Meting] 三天时间又重新认识了一边武汉，也发现了很多之前一直没有察觉到的风景。[scode type=”blue”]武大东湖旁的日出真的是太美了，那天早上六点钟到了凌波门的桥上，坐在桥沿真有一种坐在画里的错觉，右前方是几对男男女女，在浅浅的东湖里上上下下。[/scode] 确实，很多时候需要有对照才能真切的感受到时间的流淌，我们几个坐在桥沿等待初阳从远岸层云中跃出，未见时，等待焦灼，初见时，深感惊艳，如梦如幻。还有这张，虽然有点可惜，没能把我们几个都拍入照。但这剪影真的是太棒了！！！ 要是那次去稻城的时候也能拍一张这样的照片就好了，可惜，没有重来的机会了。 后来我们又坐到了七点钟，太阳也完全跃出了碎云。旁边游泳的人也都走了，钓鱼的大叔的一天也才刚刚开始。 后来，我们又去了武汉的昙华林，我之前一直想着要去昙华林看看，结果到了门外的商业中心，没有进到里面去。 [scode type=”red”]好像在各位的衬托下没有那么黑了hhh[/scode] 生活尚可，保持快乐。 [scode type=”green”]再来一份TIME-LAPSE吧！！[/scode] https://tanknee.cn/usr/uploads/2019/10/3502797405.mp4","link":"/2019/10/05/%E5%87%8C%E6%B3%A2%E6%97%A5%E5%87%BA/"},{"title":"十一月November","text":"[scode type=”red”]这是十一月的倒数第二天（21点13分），还有不到二十八个小时，2019年的十一月就要结束了。[/scode] 这个让我期待的，恐惧的，令人头大的十一月。 经历了三场结课考试，三次寒风中的早起物理实验，关于物理实验，我一直不是很明白为什么我的物理实验课总是在一年中最寒冷的几个月。 [scode type=”blue”]原本包含期许的公选课，也在这个忙碌的十三周完结了。虽然我至今仍然对那一次没有去成中操观星耿耿于怀。[/scode] [scode type=”blue”]陪伴了我七个多月的airpods Ⅱ也在前几天出给了文华学院的一个女生，甚至还第一次被陌生人加了微信？[/scode] [scode type=”blue”]二十四号去参加了上大学以来第三次五公里跑[/scode] 但是这一次却没有等来第三块奖牌，本以为本科四年能凑齐八块奖牌召唤神龙的，可惜了，要在华科读研才能拿到第八块了（大雾。 期待了很久很久的airpods pro终于在上个月的月末发布了，然后我又纠结了很久很久，辗转apple官网和拼多多，最后还是剁手收入囊中了，害，我真是一个败家的人。 我买的真的不是mac 追了整整一个多月的LOL S9也是在面向对象考试的前一天完结了，平心而论，少了几分激动，多了几分理所当然哈哈哈，本来在群里早就说好了夺冠就去下单airpods结果还是因为没有抢到而不了了之 不过最后还是败了，去pdd买了哈哈哈哈哈哈。 写到这里的时候突然想起在中旬的时候在家里的爷爷碰上了交通事故，所幸并不严重（应该不是很严重，不过还是住了很多天医院，而且做了一个小手术，而我本准备在出事的那天打电话给爷爷却由于一直忙于复习，忘了这件事，真的是很惭愧很惭愧。 wisco那边的项目也开始推进了，虽然直到现在我对前端依旧是一窍不通，甚至还有点畏惧花里胡哨的CSS语法，我真的是对平面设计没有任何天赋的人。 这个月没有认识更多的人，而是感觉，自己开始去认识那些一直在身边的人，虽然有时候有那么一点点的尴尬，无奈，但是都还挺好，毕竟我知道: [scode type=”green”]没有任何一场相逢是恰到好处。[/scode] [scode type=”green”]华科的天也太好看了吧[/scode] [scode type=”blue”]下面是前几个月的总结[/scode][post cid=”525” /][post cid=”519” /]","link":"/2019/12/01/%E5%8D%81%E4%B8%80%E6%9C%88Nov/"},{"title":"十月October","text":"​ 今天下午从实验室里上完课出来，和一个同学一起去靠的近的东教工食堂吃饭，路上的时候他突然问我为什么会一个人去商场里吃饭，他说虽然他也会有时候一个人去看电影但是还是难以接受一个人去吃饭？ 突然，也就是那么一瞬间吧，觉得自己真的已经是习惯了一个人​ 已经不太记得第一次一个人去看电影时看的是什么了，大概是一部普通的片子吧，不过还是能记得我是在一八年的头几个月去看的，那个冬天挺冷的。再往后就慢慢地看的越来越多，可能也是觉得想看就看，没必要一定要有人陪着一起是吧？倘若电影太烂太作那就是浪费了两个人的时间，确实不值得。 总觉得这个十月是如此的漫长而丰腴。月初的国庆假期，接待了来汉的几个同学，看到了武汉的第一缕阳光。 世间美景大多相似，那一日的相遇甚至不及凌波门桥上破碎的湛蓝水泥板。 中旬时，在前往东九的路上，收到了备案局的备案成功的短信，担惊受怕了半个多月终于是看到了尽头。 而后便是漫长的S9赛程，占据了我十月中旬大半时间，有奇迹突围，亦有英雄落幕，也有差强人意堪堪出线。不过倒是进入下旬后，各家队伍表现得都挺喜人，换我一个好梦。 不堪展望的十一月大多时候还是很难承认，大二的前两个月已经过去了，学期已经过半。下个月几乎是每隔三四天就有一门课结课或是考试，而下下个月十二月倒是悠闲不少。可能是有点质疑自己的能力，对一个大作业也是少不了畏惧。 抱怨真的不是一件好事。 但愿我接下来能转型到结果导向而不是过程导向。 [scode type=”blue”]下面是前几个月的总结[/scode] [post cid=”519” /][post cid=”179” /]","link":"/2019/10/31/%E5%8D%81%E6%9C%88October/"},{"title":"四月April","text":"Gitea Contribution Github Contribution 断断续续写了一快一整年的月报了，还是没有确定究竟要留下一个什么样的形式。偶尔会有段时间很在意某种格式，但也经常过了一会儿就不太在意了。 前两天在公众号里发了一张图片： 暴力终究也会递归式地催生新的暴力反抗。 好几次在社交平台看到触动以致激怒我的言论，反驳的字已经全部打进了输入框，最后却哐哐哐全都删掉。 诚然，有那么一瞬间，想把作者的脑袋拧下来，问候他到底有没有读过书，整天逼逼赖赖发这些脑瘫言论？ 但是当我全部删掉之后，突然就有那么一瞬间平静下来。 暴力是如此的易于传播，以致于每一次都会上当。 发完这张图片之后，又在原博评论里看到新的东西： 达克效应（D-K effect） 全称为邓宁-克鲁格效应（Dunning-Kruger effect）。它是一种认知偏差现象，指的是能力欠缺的人在自己欠考虑的决定的基础上得出错误结论，但是无法正确认识到自身的不足，辨别错误行为。这些能力欠缺者们沉浸在自我营造的虚幻的优势之中，常常高估自己的能力水平，却无法客观评价他人的能力。 上了大学之后，看到的无知的事情越来越多，起初是愤懑，想着义正言辞地反驳，幻想我这一段狗屁不通的言论能起到一点点我设想的效果，后来也就慢慢冷静。 没有人想听你的教诲和理由，你是什么，他又是什么？ 碰了几鼻子的灰之后再也没有跟人抬杠的心情，挺好的。 Keep hungry and keep stupid! 也祝五月返校的各位开学愉快，暑假相会","link":"/2020/05/02/568/"},{"title":"堆排序","text":"[scode type=”yellow”]堆排序思路[/scode] 将传入的数组看作是一个没有完成的堆 将堆整理排序成一个大顶堆 将大顶堆最大的元素，也就是堆顶，与这个堆最后的元素进行交换 然后视这个除刚刚交换的那个元素外的数组为一个堆，对它进行大顶堆标准检查，并将其整理成一个大顶堆 有一点需要注意的是每次交换之后接下来需要接着排序的堆的大小需要减一！ 为了减小空间的占用，可以视交换到末尾的元素为已经出堆的元素，仅仅对这些元素之前的数组进行大顶堆检查。 [scode type=”yellow”]大顶堆概念[/scode] ​ 大顶堆是一个被完全填满的二叉树，除了堆底部的叶子节点以外.其父节点必定要大于它的子节点，由这个特性，我们可以构造大顶堆。 [scode type=”yellow”]堆的数列表示[/scode] ​ 设其父节点的下标为i,那么它的左儿子的下标就是2i+1,其右儿子的下标就是左儿子加一也就是2i+2。 ​ 由上面这个下标的规律我们可以直接从整个堆数组的中部开始遍历整个堆，因为观察堆的结构可知，length/2 - 1下标的节点是必定存在有左儿子的，所以我们不用担心下标越界的问题。 [scode type=”yellow”]堆的遍历与调整[/scode] ​[scode type=”blue”]遍历的本质就是将每一个元素都访问到，这里可以用递归，也可以用循环，递归对大数据并不友好，所以应该视情况而定！ ​ 调整的话主要是实现父节点与子节点的比较，如果父节点小于子节点的较大者，那么就下沉。这里小于较大者的原因是：因为小的元素要下沉就必须要跟两个子树中较大的那个进行交换，否则如果跟较小的节点进行交换的话可能还需要交换两次！。[/scode] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130/** * MyHeapSort */public class MyHeapSort { public static void main(String[] args) { int[] arr = { 50, 10, 90, 30, 70, 40, 80, 60, 20 }; System.out.println(&quot;排序之前：&quot;); for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i] + &quot; &quot;); } // 堆排序 heapSort(arr); System.out.println(); System.out.println(&quot;排序之后：&quot;); for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i] + &quot; &quot;); } } public static void heapSort(int[] arr) { // Create a big top heap for (int i = arr.length/2; i &gt;=0; i--) { heapAdjust(arr, i, arr.length); } // 将堆顶最大的那个元素和后面的元素进行交换，然后再生成大顶堆 for (int i = arr.length-1; i &gt;= 0; i--) { // 交换堆顶和队列中最后一个元素的值 exchange(arr, 0, i); // 判断这个队列是否能构成大顶堆不能的话就调整 // 这里调整的实质是：只有堆顶一个元素需要调整，因此只需要将堆顶的元素下沉到相应的位置就好了不需要调整太多元素！！ heapAdjust(arr, 0, i); } } public static void heapAdjust(int[] arr,int root,int length) { // 以 root节点为根节点，遍历这个长度为length的子树，判断其是否满足大顶堆的要求 int child; // 子节点的值 int father; // 父节点的值 for(father = arr[root];2*root+1 &lt; length;root = child){ child = 2*root+1; // 以root节点为根节点的左子树的下标 // 如果这个根节点的左子树不是这个堆的最后一个元素并且左子树小于右子树。那么就把下标指向右子树 // 因为小的元素要下沉就必须要跟两个子树中较大的那个进行交换，否则如果跟较小的节点进行交换的话可能还需要交换两次！ if (child != length-1 &amp;&amp; arr[child] &lt; arr[child+1]) { child++; } // 如果此时的父节点小于子树中的那个较大者，就与之交换！ if (father &lt; arr[child]) { arr[root] = arr[child]; // 父节点的原有值已经记录在father这个变量内了！ }else{ // 说明该节点符合大顶堆的标准，退出for循环 break; } } // 由于当前下表为root的节点值可能是废弃的，即已经被交换过，所以这个节点位置的应有值是该移动节点的值，即最初始的父节点 arr[root] = father; } public static void exchange(int[] arr,int began,int end) { int temp = arr[began]; arr[began] = arr[end]; arr[end] = temp; }// 下面是我自己探索出来的堆排序，使用了过多的递归，导致空间爆炸，效率很低 /** * 堆排序 * * @param A */ public static void heapSort(int[] A, int index) { // A 是要排序的数组 int[] temp = createHeap(A,index); int temp1 = temp[0]; temp[0] = temp[temp.length-1-index]; temp[temp.length-1-index] = temp1; if (index == A.length-1) { return; } heapSort(temp, ++index); } /** * 构造小顶堆 * * @param A */ public static int[] createHeap(int[] A,int max) { int[] B = new int[A.length-max]; for (int i = 0; i &lt; B.length; i++) { B[i] = A[i]; } for (int i = B.length / 2 - 1; i &gt;= 0; i--) { comparePartOfHeapSort(B, i); } for (int i = 0; i &lt; B.length; i++) { A[i] = B[i]; } return A; } public static void comparePartOfHeapSort(int[] A, int index) { // 控制元素的下沉 int j = index * 2 + 1; int k = index * 2 + 2; if (j &lt; A.length) { if (A[index] &lt; A[j]) { // 比左子树要小,那么进行交换 int temp = A[index]; A[index] = A[j]; A[j] = temp; comparePartOfHeapSort(A, j); } if (k &lt; A.length &amp;&amp; A[index] &lt; A[k]) { // 比左子树要大，且右子树存在时，就跟右子树进行比较 // 比右子树要小，那么交换 int temp = A[index]; A[index] = A[k]; A[k] = temp; comparePartOfHeapSort(A, k); } // 比左右节点都要大，那么就说明该节点在这个位置是正确的，然后返回 return; } else { // 连左子树都不存在，说明该节点已经为叶子节点 return; } }}","link":"/2019/11/13/%E5%A0%86%E6%8E%92%E5%BA%8F/"},{"title":"在index主页显示文章缩略图","text":"因为这个主题的原作者没有直接提供在主界面的缩略图功能，所以我就准备自己写了。 效果如下 ## 接下来是具体操作： 在functions.php文件中添加这么一个函数： 123456789101112131415161718192021function imgs_postthumb($cid) { $db = Typecho_Db::get(); $rs = $db-&gt;fetchRow($db-&gt;select('table.contents.text') -&gt;from('table.contents') -&gt;where('table.contents.cid=?', $cid) -&gt;order('table.contents.cid', Typecho_Db::SORT_ASC) -&gt;limit(1)); preg_match_all(&quot;/\\&lt;img.*?src\\=\\&quot;(.*?)\\&quot;[^&gt;]*&gt;/i&quot;, $rs['text'], $thumbUrl); //通过正则式获取图片地址 $img_src = $thumbUrl[1][0]; //将赋值给img_src $img_counter = count($thumbUrl[0]); //一个src地址的计数器 switch ($img_counter &gt; 0) { case $allPics = 1: echo $img_src; //当找到一个src地址的时候，输出缩略图 break; default: echo theurl.'images/random/deu'.mt_rand(1,7).'.jpg';//没有找到的话就输出一张随机图像。 break; };} 如果这个函数与functions里的其他函数重名了就直接改一下！ ## 然后在index.php文件里找到这一段： 12345678910&lt;div class=&quot;post-entry&quot;&gt; &lt;div class=&quot;feature&quot;&gt; &lt;a href=&quot;&lt;?php $this-&gt;permalink() ?&gt;&quot;&gt;&lt;div class=&quot;overlay&quot;&gt;&lt;i class=&quot;iconfont&quot;&gt;&amp;#xe61e;&lt;/i&gt;&lt;/div&gt;&lt;img src=&quot;&lt;?php echo imgs_postthumb($this-&gt;cid); ; ?&gt;&quot;&gt;&lt;/a&gt; &lt;/div&gt; 改成我这个样子即可。 需要注意的一点是，这个函数只能识别html格式插入的图片，其他格式暂时无法识别参考文章：Typecho获取文章第一张图片（缩略图）","link":"/2019/09/26/%E5%9C%A8index%E4%B8%BB%E9%A1%B5%E6%98%BE%E7%A4%BA%E6%96%87%E7%AB%A0%E7%BC%A9%E7%95%A5%E5%9B%BE/"},{"title":"墙中语","text":"偶然去外网看了一圈 真的是令人作呕 看得我晚饭加饮料都要吐出来了，真的是令人恶心 果然国家建立网络长城还是有很好的的作用的 至少国内的网络监管有力，环境也要文明得多 我吐辣，口区！","link":"/2019/08/19/%E5%A2%99%E4%B8%AD%E8%AF%AD/"},{"title":"如何制作一个简单的网络爬虫？nodejs实现","text":"接下来有打算每半个月写一点东西，不然写东西的频率太低就会造成正反馈，产出越来越少了。 这段时间一共做了三个爬虫： 爬取丁香园的疫情数据 爬取联想的虚拟货币乐豆 第三个跟第一个类似，不过工作量大一点 一共用了两种不同的技术，前两个是自己的思路，用的是nodejs+express+superagent，实话实说，nodejs做后台确实对数据很友好，再用一下Sequelize做ORM对象映射，真的非常的方便。 做这个也是为了熟悉express的架构为以后填坑，虽然坑也不是特别多。 自己还给Sequelize文档做了一个镜像仓库，方便访问。文档 不过用JavaScript写程序有一点着实无法避免，那就是异步操作。 JavaScript作为浏览器的主要逻辑实现语言，少不了对网络操作的支持，如果浏览器不使用异步来获取数据的话就会有页面加载缓慢等问题，而在JavaScript写的后端中也是避免不了处理异步操作，比较头疼的就是循环异步操作，我查了网上很多的文档，主要的解决方案是循环递归嵌套promise，然后保证获取到最后一个promise对象，然后等待他的resolve或者reject。 来详细说说这几个工程吧。 丁香园数据爬取这个项目是我自发进行的，做了大概有三四天的样子吧。 分析页面数据 打开丁香园的网站，右键查看网页源码，可以看到丁香园的数据是后端渲染的，所有需要的数据都以json的形式嵌入到html的JavaScript中。 其实最开始的丁香园页面并不是这个样子的，最开始并没有那么直观，都是写在html标签页里。 我估计是为了方便各位网友爬取它的数据？毕竟写成html＋JavaScript的非常利于爬取 而且里面的数据几乎都已经是完美严格的json格式，只需要使用JSON.parse()就好了。后台也没什么好说的，直接写一个定时器，定时爬取即可。暴露一些接口就能在GitHub上收割。 联想虚拟货币爬取这是酷安老哥找我做的一个项目，毕竟是人生中第一笔外包，我犹豫了两分钟马上就开始做了。第一天花了半天研究了页面，分析了重难点。 每一个账号的货币数量是不同的，需要登陆账号 联想对单个IP有登录限制，如果单位时间内请求过多就会封锁IP一段时间 获取网页元素 第一点是我在这部分中遇到的第一个坑。因为以前做的都是不用登陆的页面，只需要获取的HTML数据就可以直接分析了，所以上网查了一些资料。 其实要解决起来也很简单，就是模拟登陆操作，获取联想服务器返回的cookie数据，然后之后都带着这个cookie去访问货币查询的页面就好了。 这里穿插一些我对网页安全性的思考： 网页是安全的吗？ 不是，没有网页是安全的，纯粹的网页几乎不可能是完全安全的，所以很多的网银都需要插上一些硬件工具去确保安全性。 那么网页可以做到相对安全吗？ 可以，也是应该的。 使用session或者cookie或是token来区别用户属性，避免未登录的未知用户查看敏感页面，并加上过期特性，保证数据的安全。 使用不可逆的加密方式对用户输入的密码加以保护，只有这样，后台在不需要知道用户真实密码的情况下确认用户的登录状态。我个人认为MD5加密是一种对我这个水平而言相对较好的用户信息加密方式。 在分析联想的登录界面时，发现了一个让我哭笑不得的地方。 联想的登录页面的密码是加密的 加密用的算法是base64，这个不是不可逆的加密算法 百度百科 Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，Base64就是一种基于64个可打印字符来表示二进制数据的方法。可查看RFC2045～RFC2049，上面有MIME的详细规范。 Base64编码是从二进制到字符的过程，可用于在HTTP环境下传递较长的标识信息。采用Base64编码具有不可读性，需要解码后才能阅读。 甚至在联想的某些登录页面，密码是明文传输的…我对联想的技术水平是真的无语了，我就不说是哪几个页面了。 解决了登录这个问题之后就基本上搞定了一大半。 而后是运维和调优，其间遇到IP被封锁，我就设了爬取时间间隔，就基本上没出过问题了。 信息获取的方式现在网页主要是两种 后端渲染的SSR页面，或者是prerender预渲染 单页面应用，前端请求数据前端渲染 第二种对爬虫不友好，只能手动去找前端接口，然后看运气能能不能请求到对应的数据，比较随缘。 第一种的话我现在大多是用的正则表达式，JavaScript对正则还是比较友好的，操作dom也很方便，基本流程就是 查看网页源码 找到需要数据 寻找唯一标识符 编写正则表达式 挑选数据并保存或者发送 在使用正则表达式之前可以使用dom操作工具将需要搜索的范围缩小，便于匹配。","link":"/2020/03/15/spider/"},{"title":"宇宙的每一秒都是这宇宙概率最小的事情","text":"今天早上吃完早饭时突然想起了这句话。这世界，这宇宙，有无数的要素在影响着当下，或许，几分钟之后，就会有光粒到达太阳，世界崩塌毁灭；或许是二向箔也说不定。 连上帝都只能掷骰子！在这宇宙往后的几百亿年里，再次复现当下（18:32:30）的概率几乎是0，这概率小到哪怕宇宙轮回几百亿次也不会再次出现。所以，我们的生命时独一无二的，就算把尺度放到宇宙的层次，也是绝无仅有，独一无二的。 感慨于生活之宽广，也沉醉于自然之神奇。","link":"/2019/09/28/%E5%AE%87%E5%AE%99%E7%9A%84%E6%AF%8F%E4%B8%80%E7%A7%92%E9%83%BD%E6%98%AF%E8%BF%99%E5%AE%87%E5%AE%99%E6%A6%82%E7%8E%87%E6%9C%80%E5%B0%8F%E7%9A%84%E4%BA%8B%E6%83%85/"},{"title":"少年秉性","text":"终于是又回到了武汉 今天也算是经历了很多。 中午在WenZhou站丢了外婆给的一百块，伤心了好一阵子，真的好难过，但是在得知有人也丢了钱而且也是外婆给的钱之后就有点庆幸？不对，反正就是没那么不开心了 人来人往的WhuHan站 路上的景也见过好几回了，没有那么感兴趣了：浙江段的山山水水，也算有点了然于心。 其实早就做好了一个人住十几天的准备，但是当我推开寝室的门，闻见略有霉味的空气，还是有一瞬间好想落泪。 而后便是整理了下行李，收拾了一会儿，特地带来武汉的一鸣手撕面包也有点无味，本想好的很多整理宿舍的设想全都被我的懒惰打败了，真的是太难了。 韵苑楼下 真的好难受。 虽然我知道我的难受来源于何处。 说点开心的吧，下午买的几样东西全部都发货了。 二十四号估计是能去西西弗看七堇年的。 早早定好的todo 本来想好的一句结尾一直没能想起来是什么。 算了，遇事皆有期，凡事不强求。","link":"/2019/08/17/%E5%B0%91%E5%B9%B4%E7%A7%89%E6%80%A7/"},{"title":"山高水远，路遥马亡","text":"高考前三个月吧，把七堇年的《灯下尘》看了很多遍。 着实很喜欢她的随笔，虽然说实话并不能给予我什么精神上的力量？更像是一种补给，在需要的时候出现了。 我曾一直以为七堇年才二十来岁？到了签售会再去查了一下百度百科，发现原来都已经三十多了，害，其实也没差，旅行的小姑娘都看着挺年轻的，不过现在感觉看着更像是长辈姑姑阿姨了。 第一次参加签售会，不知道其他的作家是什么样子，七堇年在签完字之后都会抬起头来对读者说了句谢谢，并报以微笑，确实让人心生好感。 在排队的那几个小时里突然意识到了两件事情： 我好像挺喜欢与别人对视的我好像很脸盲 也算是了了一个心愿吧，过得也算是完美，后会有期啦。 神奇的武汉一号线 不熟悉与陌生才是相识相知的基石，不是吗？","link":"/2019/08/25/%E5%B1%B1%E9%AB%98%E6%B0%B4%E8%BF%9C-%E8%B7%AF%E9%81%A5%E9%A9%AC%E4%BA%A1/"},{"title":"工程实训纪","text":"选题：PC端记账本软件语言：C++开发工具：Qt库、Qt Creator其实组里的人都比较懒，做完了之后觉得应该做个游戏什么的比较考验自己的能力，不过做实用的软件也确实比较有意思，为此还买了个机械键盘，感觉有点浪费hhh，下面开始正题了。软件要实现的几个主要功能 记录每日支出 实现简单的本地登录功能-&gt;即实现数据库的写入与读取我在这里用的是Qt自带的一个比较简单的QSQLite，有需求的可以上远程服务器，不过我这里还是遇到了一些问题就是在打包之后无法使用数据库，可能是依赖没有添加的原因，由于已经蒙混过关了所以就没有深究这一块的问题。 实现支出数据的图表化 总体看下来个人认为比较繁琐的是数据库的部分，巧的是我之前做的一个项目里有比较接近的模块，所以这部分是我自己来负责的，零零总总还都比较简单，由于队友都不太行hhhh，我也就没想着做拓展功能，谁能想到五个人的团队实际上只有两个人在写代码呢？ 12345678910bool OpenDateBase();int main(int argc, char *argv[]){ OpenDateBase(); QApplication a(argc, argv); MainWindow w; w.show(); return a.exec();} 可以看到main部分的代码还是比较简单的，大概是实现这么一个逻辑：打开数据库，生成窗口实例，展示窗口最后再让窗口一直显示 1234567891011121314151617181920bool OpenDateBase(){ QSqlDatabase mydb=QSqlDatabase::addDatabase(&quot;QSQLITE&quot;); mydb.setDatabaseName(&quot;cashitem.db&quot;); if(mydb.open()) { qDebug()&lt;&lt;&quot;open success&quot;; QSqlQuery query; //新建item表，id设置为主键，一个金额，一个类型，一个内容,一个时间 query.exec(&quot;create table item(id INTEGER PRIMARY KEY AUTOINCREMENT,money int,type varchar,content varchar,addtime time,useraccount varchar)&quot;);//条目，即输入的支出数据 query.exec(&quot;create table user(id INTEGER PRIMARY KEY AUTOINCREMENT,useraccount varchar,userpassword varchar,useremail varchar)&quot;);//用户信息 query.exec(&quot;create table user_budget_setting(id INTEGER PRIMARY KEY AUTOINCREMENT,useraccount varchar,dayBudget int,monthBudget int,yearBudget int)&quot;);//用户的支出与预算表 return true; } else { //给出debug提示，便于定位错误的地点 qDebug()&lt;&lt;&quot;open failed&quot;; return false; }} 必须在Qt给出的.pro文件中添加sql，见下文的最后一行 1234567#-------------------------------------------------## Project created by QtCreator 2019-07-03T10:40:19##-------------------------------------------------QT += core gui sql charts 这一部分的代码我是根据网上的一篇博客改的，在这里我先创建了一个数据库，若数据库存在那么就会直接调用，这里的数据库使用还是比较轻松的，以前我用服务器的数据库真的是一波三折哈哈哈，而后创建了三张数据表，含义在我给的注释里。这个主键我也是纠结了很久，我以为给他传一个NULL就好了，后来我发现还不能加‘’单引号确实比较坑爹，详细可以看我后面给出的代码。接下来是主窗口的代码mainwindow： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow){ ui-&gt;setupUi(this); tagWidgetLayout.setParent(ui-&gt;dailyBoardContent); connect(&amp;user_login,&amp;userLoginWindow::loginSuccess,this,&amp;MainWindow::user_login_sucess); connect(&amp;itemMark,&amp;itemMark::conveyData,this,&amp;MainWindow::addNewItemLabel); ui-&gt;edit_pushButton-&gt;hide(); ui-&gt;delet_pushButton_2-&gt;hide(); ui-&gt;statusBar-&gt;hide(); ui-&gt;menuBar-&gt;hide(); ui-&gt;mainToolBar-&gt;hide();}MainWindow::~MainWindow()//主窗口的销毁函数{ QSqlQuery query;//建立一个数据库的query QString sql1; sql1=&quot;insert into user_login(id,useraccount)values(NULL,'') &quot;; query.exec(sql1); query.exec(&quot;select id,useraccount from user_login where id &gt;= 0&quot;); while (query.next()) { QString id = query.value(0).toString(); useraccount = query.value(1).toString(); qDebug()&lt;&lt;&quot;mainwindow:&quot;&lt;tabWidget-&gt;hide(); itemMark.show();}void MainWindow::addNewItemLabel(int money ,QString type,QString content){ newWidget = new itemWidget(money,type,content,ui-&gt;itemListWidget); QSqlQuery query1; query1.exec(&quot;select id,useraccount from user_login where id &gt;= 0&quot;); while (query1.next()) { QString id = query1.value(0).toString(); useraccount = query1.value(1).toString(); qDebug()&lt;itemListWidget,0); listwidgetitem-&gt;setSizeHint(QSize(50,50)); ui-&gt;itemListWidget-&gt;setItemWidget(listwidgetitem,newWidget); ui-&gt;itemListWidget-&gt;show(); }}void MainWindow::deletItem(){ QListWidgetItem *listwidgetitem= ui-&gt;itemListWidget-&gt;currentItem(); listwidgetitem-&gt;setHidden(true);}void MainWindow::on_userAvatarPic_clicked(){ user_login.show();}void MainWindow::on_dailyBoardButton_clicked(){ ui-&gt;stackedWidget-&gt;setCurrentIndex(0);}void MainWindow::on_chartAnalysisButton_clicked(){ int i = ui-&gt;monthSelector-&gt;currentIndex(); chartsMaking(i+1); ui-&gt;stackedWidget-&gt;setCurrentIndex(1);}void MainWindow::on_bugetSettingButton_clicked(){ QSqlQuery query_user; query_user.exec(&quot;select id,useraccount from user_login where id &gt;= 0&quot;); while(query_user.next()){ useraccount = query_user.value(1).toString(); // qDebug()&lt;stackedWidget-&gt;setCurrentIndex(2); QSqlQuery query; QDateTime dtm; QString timeNow=dtm.currentDateTime().toString(&quot;yyyyMMdd&quot;); int year = timeNow.toInt(); // int day = year % 100; year/=100; // int month = year % 100; year/=100; int thisMonthCost(0),thisDayCost(0),thisYearCost(0); QString monthNow = timeNow.remove(6,7); timeNow=dtm.currentDateTime().toString(&quot;yyyyMMdd&quot;); QString sql =QString(&quot;select money,addtime,useraccount from item where addtime between '%1%2%3'and '%4%5%6'&quot;).arg(year).arg(&quot;01&quot;).arg(&quot;01&quot;).arg(year+1).arg(&quot;01&quot;).arg(&quot;00&quot;); query.exec(sql); while(query.next()){ if (query.value(2).toString() == useraccount) { thisYearCost+=query.value(0).toInt(); if (query.value(1).toString().contains(monthNow,Qt::CaseInsensitive)) thisMonthCost+=query.value(0).toInt(); if (query.value(1).toString() == timeNow ) thisDayCost+=query.value(0).toInt(); } } //qDebug()&lt;dayBudget)//TODO 增加弹窗提示 { ui-&gt;dayprogressBar-&gt;setMaximum(thisDayCost); } else ui-&gt;dayprogressBar-&gt;setMaximum(dayBudget); if (thisMonthCost&gt;monthBudget)//TODO 增加弹窗提示 { ui-&gt;monthprogressBar-&gt;setMaximum(thisMonthCost); } else ui-&gt;monthprogressBar-&gt;setMaximum(monthBudget); if (thisYearCost&gt;yearBudget)//TODO 增加弹窗提示 { ui-&gt;yearprogressBar-&gt;setMaximum(thisYearCost); } else ui-&gt;yearprogressBar-&gt;setMaximum(yearBudget); ui-&gt;dayprogressBar-&gt;setValue(thisDayCost); ui-&gt;monthprogressBar-&gt;setValue(thisMonthCost); ui-&gt;yearprogressBar-&gt;setValue(thisYearCost); QString daylabel = QString(&quot;每日预算：%1/%2&quot;).arg(thisDayCost).arg(dayBudget); QString monthlabel = QString(&quot;每月预算：%1/%2&quot;).arg(thisMonthCost).arg(monthBudget); QString yearlabel = QString(&quot;每年预算：%1/%2&quot;).arg(thisYearCost).arg(yearBudget); ui-&gt;dayBudgetSetlabel-&gt;setText(daylabel); ui-&gt;monthBudgetSetlabel-&gt;setText(monthlabel); ui-&gt;yearBudgetSetlabel-&gt;setText(yearlabel);}void MainWindow::on_dayBudgetSetButton_clicked(){ //接收新的预算 int dayBudget; dayBudget = QInputDialog::getInt(this,&quot;设置&quot;,&quot;每日预算：&quot;,0); QSqlQuery query; QSqlQueryModel *model_2 = new QSqlQueryModel; QString sql = QString(&quot;select count (*) from user_budget_setting where useraccount = '%1'&quot;).arg(useraccount); model_2-&gt;setQuery(sql); QModelIndex index1 = model_2-&gt;index(0,0); if (index1.data()==0){//插入一条新记录 sql = QString(&quot;insert into user_budget_setting(id,dayBudget,monthBudget,yearBudget,useraccount) values(NULL,'%1','%2','%3','%4')&quot;).arg(dayBudget).arg(0).arg(0).arg(useraccount); qDebug()&lt;dayprogressBar-&gt;value()).arg(dayBudget); ui-&gt;dayBudgetSetlabel-&gt;setText(daylabel); if (ui-&gt;dayprogressBar-&gt;value()&gt;dayBudget)//TODO 增加弹窗提示 { ui-&gt;dayprogressBar-&gt;setMaximum(ui-&gt;dayprogressBar-&gt;value()); } else ui-&gt;dayprogressBar-&gt;setMaximum(dayBudget); ui-&gt;dayBudgetSetlabel-&gt;show();}void MainWindow::on_monthBudgetSetButton_clicked(){ //接收新的预算 int monthBudget; monthBudget = QInputDialog::getInt(this,&quot;设置&quot;,&quot;每月预算：&quot;,0); //TODO添加数据库操作 QSqlQuery query; QSqlQueryModel *model_2 = new QSqlQueryModel; QString sql = QString(&quot;select count (*) from user_budget_setting where useraccount = '%1'&quot;).arg(useraccount); model_2-&gt;setQuery(sql); QModelIndex index1 = model_2-&gt;index(0,0); if (index1.data()==0){//插入一条新记录 sql = QString(&quot;insert into user_budget_setting(id,dayBudget,monthBudget,yearBudget,useraccount) values(NULL,'%1','%2','%3','%4')&quot;).arg(0).arg(monthBudget).arg(0).arg(useraccount); qDebug()&lt;monthprogressBar-&gt;value()).arg(monthBudget); ui-&gt;monthBudgetSetlabel-&gt;setText(monthlabel); if (ui-&gt;monthprogressBar-&gt;value()&gt;monthBudget)//TODO 增加弹窗提示 { ui-&gt;monthprogressBar-&gt;setMaximum(ui-&gt;monthprogressBar-&gt;value()); } else ui-&gt;monthprogressBar-&gt;setMaximum(monthBudget); ui-&gt;monthBudgetSetlabel-&gt;show();}void MainWindow::on_yearBudgetSetButton_clicked(){ //接收新的预算 int yearBudget; yearBudget = QInputDialog::getInt(this,&quot;设置&quot;,&quot;每年预算：&quot;,0); //TODO添加数据库操作 QSqlQuery query; QSqlQueryModel *model_2 = new QSqlQueryModel; QString sql = QString(&quot;select count (*) from user_budget_setting where useraccount = '%1'&quot;).arg(useraccount); model_2-&gt;setQuery(sql); QModelIndex index1 = model_2-&gt;index(0,0); if (index1.data()==0){//插入一条新记录 sql = QString(&quot;insert into user_budget_setting(id,dayBudget,monthBudget,yearBudget,useraccount) values(NULL,'%1','%2','%3','%4')&quot;).arg(0).arg(0).arg(yearBudget).arg(useraccount); qDebug()&lt;yearprogressBar-&gt;value()).arg(yearBudget); ui-&gt;yearBudgetSetlabel-&gt;setText(yearlabel); if (ui-&gt;yearprogressBar-&gt;value()&gt;yearBudget)//TODO 增加弹窗提示 { ui-&gt;yearprogressBar-&gt;setMaximum(ui-&gt;yearprogressBar-&gt;value()); } else ui-&gt;yearprogressBar-&gt;setMaximum(yearBudget); ui-&gt;yearBudgetSetlabel-&gt;show();}void MainWindow::on_monthSelector_activated(int index){ int x = index; x++; chartsMaking(x);}//饼状图生成函数void MainWindow::chartsMaking(int month){ QSqlQuery query1; query1.exec(&quot;select id,useraccount from user_login where id &gt;= 0&quot;); while (query1.next()) { QString id = query1.value(0).toString(); useraccount = query1.value(1).toString(); qDebug()&lt;&lt;&quot;BarMaking:&quot;&lt;append(&quot;饮食&quot;,eatMoney); series-&gt;append(&quot;娱乐&quot;,entertainmentMoney); series-&gt;append(&quot;教育&quot;,eduMoney); series-&gt;setLabelsVisible(); /*QPieSlice *slice_red = series-&gt;slices().at(0); QPieSlice *slice_green = series-&gt;slices().at(1); QPieSlice *slice_blue = series-&gt;slices().at(2); slice_red-&gt;setColor(QColor(255,0,0,255)); slice_green-&gt;setColor(QColor(0,255,0,255)); slice_blue-&gt;setColor(QColor(0,0,255,255));*/ QChart *chart = new QChart(); chart-&gt;addSeries(series); QString title = QString(&quot;您的%1月的账单统计图&quot;).arg(month); chart-&gt;setTitle(title); chart-&gt;legend()-&gt;hide(); ui-&gt;chartViewer-&gt;setChart(chart); //QChartView *chartview = new QChartView(chart); //chartview-&gt;setRenderHint(QPainter::Antialiasing); //chartview-&gt;resize(400,400); //chartview-&gt;show(); //ui-&gt;graphicsView-&gt;setChart(chart); //ui-&gt;graphicsView-&gt;setRenderHint(QPainter::Antialiasing);}//柱状图生成函数void MainWindow::barChartsMaking(int month){ QSqlQuery query1; query1.exec(&quot;select id,useraccount from user_login where id &gt;= 0&quot;); while (query1.next()) { QString id = query1.value(0).toString(); useraccount = query1.value(1).toString(); qDebug()&lt;&lt;&quot;BarMaking:&quot;&lt;append(set); //series-&gt;append(setEntertainment); //series-&gt;append(setEdu); QChart *chart = new QChart(); QString title = QString(&quot;您的%1月的账单统计图&quot;).arg(month); chart-&gt;setTitle(title); QBarCategoryAxis *axis = new QBarCategoryAxis(); axis-&gt;append(category); chart-&gt;createDefaultAxes(); chart-&gt;addSeries(series); chart-&gt;setAxisX(axis,series); ui-&gt;chartViewer-&gt;setChart(chart);}void MainWindow::on_delet_pushButton_2_clicked(){ QListWidgetItem *listwidgetitem= ui-&gt;itemListWidget-&gt;currentItem(); listwidgetitem-&gt;setHidden(true); QSqlQuery query; int curRow = ui-&gt;itemListWidget-&gt;currentIndex().row(); //鼠标选择删除第几行 QModelIndex index = ui-&gt;itemListWidget-&gt;currentIndex(); int id=index.sibling(curRow,0).data().toInt(); QString str =QString(&quot;delete from item where id = '%1'&quot;).arg(curRow) ; query.exec(str);}//编辑按钮void MainWindow::on_edit_pushButton_clicked(){ QSqlQuery query; query.exec(&quot;select id,money,type,content,addtime from item where id &gt;= 1&quot;); QString str; QString str1; QString str2; QString str3; QString str4; QString str5; QDateTime dtm; int dtm0; while(query.next()) { //query.value(0)是id的值，将其转换为int型 //QString str0 = dtm.toString(&quot;yyyy-mm-dd hh:mm:ss&quot;); str1 = query.value(0).toString(); str2 = query.value(1).toString(); str3 = query.value(2).toString(); str4 = query.value(3).toString(); str5 = query.value(4).toString(); //输出两个值 qDebug() &lt;&lt; str1&lt;&lt; str2&lt;&lt; str3&lt;&lt; str4&lt;itemListWidget-&gt;clear();}void MainWindow::user_login_sucess(){ QSqlQuery query1; query1.exec(&quot;select id,useraccount from user_login where id &gt;= 0&quot;); while (query1.next()) { QString id = query1.value(0).toString(); useraccount = query1.value(1).toString(); qDebug()&lt;&lt;&quot;mainwindow:&quot;&lt;itemListWidget-&gt;clear(); while (query1.next()) { QString id = query1.value(0).toString(); int money = query1.value(1).toInt(); QString type = query1.value(2).toString(); QString content = query1.value(3).toString(); useraccount = query1.value(5).toString(); newWidget = new itemWidget(money,type,content,ui-&gt;itemListWidget); QListWidgetItem *listwidgetitem = new QListWidgetItem(ui-&gt;itemListWidget,0); listwidgetitem-&gt;setSizeHint(QSize(50,50)); ui-&gt;itemListWidget-&gt;setItemWidget(listwidgetitem,newWidget); ui-&gt;itemListWidget-&gt;show(); qDebug()&lt;monthSelector-&gt;currentIndex(); chartsMaking(index+1);}void MainWindow::on_selectLinerChart_clicked(){ int index; index = ui-&gt;monthSelector-&gt;currentIndex(); barChartsMaking(index+1);} 接下来是用户登录的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include &quot;userloginwindow.h&quot;#include &quot;ui_userloginwindow.h&quot;#include#include#include#include#include#include#include#includeusing namespace std;userLoginWindow::userLoginWindow(QWidget *parent) : QWidget(parent), ui(new Ui::userLoginWindow){ ui-&gt;setupUi(this); this-&gt;setWindowTitle(&quot; &quot;); //注册页面 ui-&gt;userID_reg-&gt;setPlaceholderText(&quot;请输入用户名&quot;); ui-&gt;userPassword_reg-&gt;setPlaceholderText(&quot;密码&quot;); ui-&gt;userPassword_reg_2-&gt;setPlaceholderText(&quot;确认密码&quot;); ui-&gt;userPassword_reg-&gt;setEchoMode(QLineEdit::Password); ui-&gt;userPassword_reg_2-&gt;setEchoMode(QLineEdit::Password); ui-&gt;userMail-&gt;setPlaceholderText(&quot;xxx@xxx.xxx&quot;); //注册操作 connect(ui-&gt;reg_button,&amp;QPushButton::clicked,this,&amp;userLoginWindow::sendToDateBase_regist); //登陆操作 connect(ui-&gt;loginButton,&amp;QPushButton::clicked,this,&amp;userLoginWindow::sendToDateBase_log); //登录界面 ui-&gt;username-&gt;setPlaceholderText(&quot;请输入用户名&quot;); ui-&gt;userPassword-&gt;setEchoMode(QLineEdit::Password); ui-&gt;userPassword-&gt;setPlaceholderText(&quot;请输入密码&quot;);}userLoginWindow::~userLoginWindow(){ delete ui;}void userLoginWindow::on_registerButton_clicked(){ ui-&gt;log-&gt;hide(); ui-&gt;reg-&gt;show();}void userLoginWindow::on_return_button_clicked(){ ui-&gt;log-&gt;show(); ui-&gt;reg-&gt;hide();}void userLoginWindow::sendToDateBase_regist(){ QSqlQuery query; QString sql; QString str1 ,str2, str3; str1 = ui-&gt;userID_reg-&gt;text(); str2 = ui-&gt;userPassword_reg-&gt;text(); str3 = ui-&gt;userMail-&gt;text(); QSqlQueryModel *model1=new QSqlQueryModel; sql = QString(&quot;select count (*) from user where useraccount = '%1'&quot;).arg(str1); model1-&gt;setQuery(sql); QModelIndex index1=model1-&gt;index(0,0); //query.exec(sql); if(index1.data()==0){ //如果这条数据不存在那么插入这条数据 sql = QString(&quot;insert into user(id, useraccount, userpassword,useremail) values(NULL,'%1', '%2', '%3')&quot;).arg(str1).arg(str2).arg(str3); query.exec(sql); //debug测试 query.exec(&quot;select id,useraccount,userpassword,useremail from user where id &gt;= 1&quot;); while(query.next()) { //query.value(0)是id的值，将其转换为int型 //QString str0 = dtm.toString(&quot;yyyy-mm-dd hh:mm:ss&quot;); str1 = query.value(1).toString(); str2 = query.value(2).toString(); str3 = query.value(3).toString(); //输出两个值 qDebug() &lt;&lt; str1&lt;&lt; str2&lt;&lt; str3 ; } qDebug()&lt;&lt;&quot;注册成功&quot;; ui-&gt;userID_reg-&gt;clear(); ui-&gt;userPassword_reg-&gt;clear(); ui-&gt;userPassword_reg_2-&gt;clear(); ui-&gt;userMail-&gt;clear(); ui-&gt;reg-&gt;hide(); ui-&gt;log-&gt;show(); }else{ qDebug()&lt;&lt;&quot;用户已存在&quot;; }}void userLoginWindow::sendToDateBase_log(){ QSqlQuery query; QString sql; QString str1 ,str2, str3; str1 = ui-&gt;username-&gt;text();//用户输入的用户名 str2 = ui-&gt;userPassword-&gt;text();//用户输入的密码 QSqlQueryModel *model1=new QSqlQueryModel; QSqlQueryModel *model2=new QSqlQueryModel; sql = QString(&quot;select count (*) from user where useraccount = '%1'&quot;).arg(str1); model1-&gt;setQuery(sql); QModelIndex index1=model1-&gt;index(0,0); if(index1.data()==0){ qDebug()&lt;&lt;&quot;用户名不存在&quot;; }else{ //获取该用户名下的密码进行对比 sql=QString(&quot;select userpassword from user where useraccount = '%1'&quot;).arg(str1); model2-&gt;setQuery(sql); QModelIndex index2=model2-&gt;index(0,0); if(index2.data()==str2){ query.exec(&quot;create table user_login(id INTEGER PRIMARY KEY AUTOINCREMENT ,useraccount varchar)&quot;);//这张表是为了获取当前登录的用户，并以此来确定各个模块的显示 sql = QString(&quot;insert into user_login(id,useraccount) values(NULL,'%1')&quot;).arg(str1); query.exec(sql); qDebug()&lt;&lt;&quot;userlogwindow:&quot;&lt;username-&gt;clear(); ui-&gt;userPassword-&gt;clear(); this-&gt;close(); qDebug()&lt;&lt;&quot;登陆成功&quot;; }else{ qDebug()&lt;&lt;&quot;密码错误&quot;; } }}void userLoginWindow::regUser(){ int user_num_int; qint64 pos; QFile file(&quot;userAccout.txt&quot;); bool isOk = file.open(QIODevice::ReadWrite|QIODevice::Text); if (isOk == true){ pos=file.size(); QString user_num = file.readLine(); QTextStream txtout(&amp;file); for (int i=0;iuserID_reg-&gt;text()&lt;userPassword_reg-&gt;text()&lt;userMail-&gt;text()&lt;log-&gt;show(); ui-&gt;reg-&gt;hide(); ui-&gt;userID_reg-&gt;clear(); ui-&gt;userPassword_reg-&gt;clear(); ui-&gt;userPassword_reg_2-&gt;clear(); ui-&gt;userMail-&gt;clear();} 最后做完了整个项目后反思了一下，有这么几个做的不太好：用户登录之后没有更改登录的状态显示，导致直接可以登录第二个用户，后期偷懒没有把这个做成更加美观的解决方案很多地方都重复的使用了相同的代码，下一次可以试着做成一个简单的调用函数，降低各个版块之间的耦合度。在做用户支出条目的时候没有实现条目的增删查改，只完成了条目的输入和清空，原因是我发现删改在QListWidget里实现比较麻烦，在翻阅了他的官方文档后他提示我要使用QListView，但那时已经接近项目结束了所以就没有重写。最后一点就是有时候我太放心别人写的东西了，要保持自己怀疑的心。最后放上我的GitHub地址：TankNee’s Repo -CashBook万分感谢各位合作的队友们","link":"/2019/07/24/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%AE%AD-%E8%AE%B0%E8%B4%A6%E8%BD%AF%E4%BB%B6/"},{"title":"建站纪","text":"成本： 阿里云的服务器+两个顶级域名合计60+，预计一年的维护费用在300+。 说实话还是不便宜的，但是收获的是一台境外服务器，一个博客，后续还可以加上其他的模块，例如下载等，但是看阿里云的1m小水管还是算了吧，划不来划不来，家里没矿玩不起hhh。 流程： 购置域名：在阿里那边购置的万网域名，top比cn的域名要便宜一点，但是好像微信有时候会对top的域名进行屏蔽警告，而且在用终端ping这两个域名的时候响应速度cn要比top快得多，具体我也不知道是什么原因，因为我把两个域名都绑定在相同的服务器上了，真的是奇了怪了....购置云服务器：阿里云的轻量级应用服务器，没什么好说的，选个喜欢的就好，系统我选用的是centos，不过我看到阿里在购买时有提供WordPress镜像的选择，具体我也不是很清楚，可能可以直接安装那个来实现搭建吧，不过我还是用的centos因为ss的需要具体可以看另一篇。配置服务器：我这里搭建的是LAMP的博客，是基于centOS搭建的。安装Apache，mariadb，安装php最后打开你的服务器的网址即可 注意事项： 这里的php要尽量安装高版本的，centos自带的PHP版本一般为5.2，而最新的WordPress所需的版本一般在5.6左右所以最好直接安装php7方便后续的更新以及维护","link":"/2019/07/25/%E5%BB%BA%E7%AB%99%E7%BA%AA/"},{"title":"快速提交git代码到多个托管平台","text":"我的个人Git仓库 我的GitHub 其实做法很简单，就是编写批处理程序。Linux下用bash，windows下用bat写，Linux我没有测试，但是应该没有什么问题。 123git add .git commit -m&quot;:tada: update my document&quot;git push -u github master &amp;&amp; git push -u origin master 其中第三行的github和origin是远程仓库的名字，相关的名字可以在.git/config文件中找到，只需要替换那两个名称就OK了，会自动提交对应的修改。 用法将这段文字保存到push.bat文件，Linux就保存到push.sh文件，然后打开终端，定位到该文件所在的目录，输入./push就会自动执行语句了。 请把该脚本文件放在.git文件夹的同级目录","link":"/2020/03/26/559/"},{"title":"我是杂乱碎片的收集者","text":"大二了竟然还能不时收到学校里各大工作室的宣传单。我用大一上的三个月时间证明了自己并不适合高强度的开发学习并重。归根结底我还是一个自由散漫，懒散堕落的人。不过我也会把我对崭新的，未从尝试的工具的探索热情一一贯彻下去综述，我希望我今后最大的进步是把压力驱动转移到兴趣驱动上来，并且获得相应的一些成就。","link":"/2019/09/21/%E6%88%91%E6%98%AF%E6%9D%82%E4%B9%B1%E7%A2%8E%E7%89%87%E7%9A%84%E6%94%B6%E9%9B%86%E8%80%85/"},{"title":"完成经典算法的C语言实现","text":"[button color=”success” icon=”” url=”https://git.tanknee.cn/tanknee/DataStruct&quot; type=””]全文源码git地址[/button] 基于磁盘的带替换选择的合并排序先替换选择，再进行外部合并排序。 替换选择先从源文件中读取M个数据，然后将M个数据中的最小值输出到输出文件中，再从源文件读取下一个数据。直到死区放满了或者源文件读完了再更换输出文件，直到全部处理完成，源文件与输出文件的指针交换，进行合并排序。 合并排序从两个有数据的文件中读取第一个数据，然后比较大小，将较小的打印在输出文件上，直到这个顺串打印完成。当两个文件全部输出完后进行下一次合并排序。 合并排序结束的条件是输出文件中只有一个是有数据的，另一个没有数据。 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291#define INF (~(0x1 &lt;&lt; 31)) // 最大值(即0X7FFFFFFF)#define NUM(N) N * 2 + 1#define runN 3int num = runN;void DiskMerge();void swapArray();// 插入排序//这里使用排序来替代原本的构建堆，其目的都是找出最小的元素，因此我认为效果是一致的，所以为了方便我选择使用插入排序。void insertSort(int A[], int length){ // 插入排序的主要思想是排过序的前一部分是永远有序的，只需要将当前元素放置到正确位置就好 int temp = 0; int j = 0; for (int i = 1; i &lt; length; i++) //可以选择直接从第一个元素开始 { temp = A[i]; for (j = i; j &gt; 0 &amp;&amp; A[j - 1] &gt; temp; j--) // 第一个j=i的元素是还没有被排序的待排元素！所以要从第i-1个元素开始排序 { A[j] = A[j - 1]; } // 退出上一个循环的原因要么是找到了该放的正确位置，要么是到了数组的第一位。 // 但是不管是那种情况，此时j就是正确位置的下标！ A[j] = temp; }}/** * fa1 fa2是输入磁带 * fb1 fb2是输出磁带 * */void DiskMergeSort(FILE *fa_1, FILE *fa_2, FILE *fb_1, FILE *fb_2){ //定义缓冲区 int tempBuff[runN] = {INF, INF, INF}; // 死区，存放不符合要求的元素 int deadSpace[runN] = {INF, INF, INF}; //数据缓存 int dataCache[1] = {0}; int index = 0; int j = 0; int flag = 0; // 读入三个初始数据 while (!feof(fa_1) &amp;&amp; j &lt; 3) { fscanf(fa_1, &quot;%d&quot;, tempBuff + j); ++j; } //排序 insertSort(tempBuff, runN); while (1) { // 循环继续的条件是输入磁盘的指针没有达到末尾，并且当前顺串没有完结,并且死区没有放满 // 当tempBuff的第一个元素都是INF时，说明队列已经清空了。 while (!feof(fa_1) &amp;&amp; tempBuff[0] != INF &amp;&amp; index != 3) { /* 把最小的记录写道输出磁盘上，再从输入磁盘读入下一个记录，如果它比刚刚写的记录要大，那么就把他加入到数组中，否则就放入死区。 * * */ insertSort(tempBuff, runN); fprintf(fb_1, &quot;%d &quot;, tempBuff[0]); fscanf(fa_1, &quot;%d&quot;, dataCache); // 如果读入的值比刚刚打印的那个值要大，那么就将这个数据放入到队列中 if (dataCache[0] &gt; tempBuff[0]) { tempBuff[0] = dataCache[0]; insertSort(tempBuff, runN); } else { //将打印了的那个位置置为最大正数 tempBuff[0] = INF; insertSort(tempBuff, runN); //如果这个读入的值比打印的值还要小，那么就将这个数据放入死区中 deadSpace[index++] = dataCache[0]; } } //如果此时输入磁盘已经读取完了，那么就将当前队列中的所有数据导入到该磁盘中 if (feof(fa_1)) { index = 0; while (tempBuff[index] != INF &amp;&amp; index &lt; 3) { fprintf(fb_1, &quot;%d &quot;, tempBuff[index]); index++; } //队列打印完成之后，将死区的元素放入到另一个输出磁盘中 FILE *tempFp = fb_1; fb_1 = fb_2; fb_2 = tempFp; index = 0; //重新构建队列，然后把它输入到输出磁盘中去 insertSort(deadSpace, runN); while (deadSpace[index] != INF) { fprintf(fb_1, &quot;%d &quot;, deadSpace[index]); index++; } break; } // swapPoint(fb_1,fb_2); fprintf(fb_1, &quot;%d &quot;, INF); FILE *tempFp = fb_1; fb_1 = fb_2; fb_2 = tempFp; // 将死区内存储的数据转移到队列中 swapArray(tempBuff, deadSpace, runN); for (int i = 0; i &lt; runN; i++) { deadSpace[i] = INF; } index = 0; } fclose(fa_1); fclose(fa_2); fclose(fb_1); fclose(fb_2); // 将a1 a2中的文件合并排序到b1，b2中 fa_1 = fopen(&quot;SortSource\\\\TA1.txt&quot;, &quot;a+&quot;); fa_2 = fopen(&quot;SortSource\\\\TA2.txt&quot;, &quot;a+&quot;); fb_1 = fopen(&quot;SortSource\\\\TB1.txt&quot;, &quot;a+&quot;); fb_2 = fopen(&quot;SortSource\\\\TB2.txt&quot;, &quot;a+&quot;); //下面进行合并排序 DiskMerge(fb_1, fb_2, fa_1, fa_2);}/** * 合并部分 * fa1 fa2是输入磁带 * fb1 fb2是输出磁带 * */void DiskMerge(FILE *fa1, FILE *fa2, FILE *fb1, FILE *fb2){ int temp1 = 0; int temp2 = 0; // 抹去输出磁盘上的全部内容 fb1 = fopen(&quot;SortSource\\\\TA1.txt&quot;, &quot;w&quot;); fb2 = fopen(&quot;SortSource\\\\TA2.txt&quot;, &quot;w&quot;); // 重新打开输出磁盘 fb1 = fopen(&quot;SortSource\\\\TA1.txt&quot;, &quot;a+&quot;); fb2 = fopen(&quot;SortSource\\\\TA2.txt&quot;, &quot;a+&quot;); // 选择当前要输出的磁盘 FILE *outp = fb1; //用于交换的临时变量 FILE *tempPoint; // 输入输出磁盘的标志 //1 - TB对应输入 -1 - TA对应输入 int flag = 1; // 读取元素 fscanf(fa1, &quot;%d&quot;, &amp;temp1); fscanf(fa2, &quot;%d&quot;, &amp;temp2); while (1) { // 如果两个输入磁盘都没有读到文件末尾那么就一直进行，直到全部数据都被合并完成 while (!feof(fa1) || !feof(fa2)) { //当读取到分割符号时，或者是读取到文件末尾，就将另一个输入磁盘顺串全部输出到输出磁盘上 if (temp1 == INF || feof(fa1)) { if (!feof(fa1)) { fscanf(fa1, &quot;%d&quot;, &amp;temp1); } while (temp2 != INF &amp;&amp; !feof(fa2)) { fprintf(outp, &quot;%d &quot;, temp2); fscanf(fa2, &quot;%d&quot;, &amp;temp2); } outp = fb2; if (temp2 == INF &amp;&amp; !feof(fa2)) { fprintf(outp,&quot;%d &quot;,INF); fscanf(fa2, &quot;%d&quot;, &amp;temp2); } if (feof(fa1) &amp;&amp; feof(fa2)) { break; } if (feof(fa1)) { temp1 = INF; } } if (temp2 == INF || feof(fa2)) { if (!feof(fa2)) { fscanf(fa2, &quot;%d&quot;, &amp;temp2); } while (temp1 != INF &amp;&amp; !feof(fa1)) { fprintf(outp, &quot;%d &quot;, temp1); fscanf(fa1, &quot;%d&quot;, &amp;temp1); } outp = fb2; if (temp1 == INF &amp;&amp; !feof(fa1)) { fprintf(outp,&quot;%d &quot;,INF); fscanf(fa1, &quot;%d&quot;, &amp;temp1); } if (feof(fa1) &amp;&amp; feof(fa2)) { break; } if (feof(fa2)) { temp2 = INF; } } // 将较小的那个数放到当前输出磁盘中去，然后读取下一个元素 if (temp1 &gt; temp2) { fprintf(outp, &quot;%d &quot;, temp2); fscanf(fa2, &quot;%d&quot;, &amp;temp2); } else if (temp1 &lt; temp2) { fprintf(outp, &quot;%d &quot;, temp1); fscanf(fa1, &quot;%d&quot;, &amp;temp1); } } // 当两个文件都读取完成了，那么就关闭文件，完成文件的写入操作 fclose(fb1); fclose(fb2); //接下来就是重新打开外部文件，并且此时要将原本的输入磁盘和输出磁盘交换。也就是输入变成了输出，输出变成了输入 //下面这一段是将原本输入磁盘全部抹去，因为它们将要被当作输出磁盘使用 // 输入输出磁盘的标志 //1 - TB对应输入 -1 - TA对应输入 if (flag == 1) { //清除当前的输入磁盘，并把它赋给输出磁盘指针 fb1 = fopen(&quot;SortSource\\\\TB1.txt&quot;, &quot;w&quot;); fb2 = fopen(&quot;SortSource\\\\TB2.txt&quot;, &quot;w&quot;); fb1 = fopen(&quot;SortSource\\\\TB1.txt&quot;, &quot;a+&quot;); fb2 = fopen(&quot;SortSource\\\\TB2.txt&quot;, &quot;a+&quot;); // 打开输入文件，创建指针赋值给输入指针 fa1 = fopen(&quot;SortSource\\\\TA1.txt&quot;, &quot;r&quot;); fa2 = fopen(&quot;SortSource\\\\TA2.txt&quot;, &quot;r&quot;); } else if (flag == -1) { // 与上面类似 fb1 = fopen(&quot;SortSource\\\\TA1.txt&quot;, &quot;w&quot;); fb2 = fopen(&quot;SortSource\\\\TA2.txt&quot;, &quot;w&quot;); fb1 = fopen(&quot;SortSource\\\\TA1.txt&quot;, &quot;a+&quot;); fb2 = fopen(&quot;SortSource\\\\TA2.txt&quot;, &quot;a+&quot;); fa1 = fopen(&quot;SortSource\\\\TB1.txt&quot;, &quot;r&quot;); fa2 = fopen(&quot;SortSource\\\\TB2.txt&quot;, &quot;r&quot;); } flag *= -1; int temp3 = fscanf(fa1, &quot;%d&quot;, &amp;temp1); int temp4 = fscanf(fa2, &quot;%d&quot;, &amp;temp2); outp = fb1; if (fa1 != NULL &amp;&amp; temp4 == -1) { break; } else if (temp3 == -1 &amp;&amp; fa2 != NULL) { break; } }}void swapArray(int A[], int B[], int length){ for (int i = 0; i &lt; length; i++) { A[i] = B[i]; }}int main(int argc, char const *argv[]){ FILE *fa_1, *fa_2, *fb_1, *fb_2; fa_1 = fopen(&quot;SortSource\\\\TA1.txt&quot;, &quot;a+&quot;); fa_2 = fopen(&quot;SortSource\\\\TA2.txt&quot;, &quot;a+&quot;); fb_1 = fopen(&quot;SortSource\\\\TB1.txt&quot;, &quot;a+&quot;); fb_2 = fopen(&quot;SortSource\\\\TB2.txt&quot;, &quot;a+&quot;); DiskMergeSort(fa_1, fa_2, fb_1, fb_2); //关闭文件流 fclose(fa_1); fclose(fa_2); fclose(fb_1); fclose(fb_2); return 0;} 测试用例一共五十个数据。 13326 8497 13428 12105 29791 18956 18729 16025 27748 17760 11586 3912 1443 20730 6316 26020 28423 11436 9791 8752 13264 28739 8677 26431 6875 32184 511 15554 2852 25515 4100 9823 6537 17420 1131 24515 9169 4892 6604 13112 7404 17044 23362 7802 28284 11555 12819 14790 5013 22046 测试结果1511 1131 1443 2852 3326 3912 4100 4892 5013 6316 6537 6604 6875 7404 7802 8497 8677 8752 9169 9791 9823 11436 11555 11586 12105 12819 13112 13264 13428 14790 15554 16025 17044 17420 17760 18729 18956 20730 22046 23362 24515 25515 26020 26431 27748 28284 28423 28739 29791 32184 AVL树的插入 左旋转 右旋转 左右旋转 右左旋转 完全二叉树 定义：一棵二叉树中，只有最下面两层结点的度可以小于2，并且最下一层的叶结点集中在靠左的若干位置上。这样的二叉树称为完全二叉树。 特点：叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。显然，一棵满二叉树必定是一棵完全二叉树，而完全二叉树未必是满二叉树。 插入四种情况 LL: RR:LR:相当于进行了一次RR旋转一次LL旋转。 RL: 相当于先进行了LL旋转在进行了RR旋转。 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#define MAX(a,b) (a &gt; b) ? (a) : (b)/** * AVL树的结构体定义 * */typedef struct AVLTreeNode{ int data; //节点存储的值 int height; //当前节点的高度 struct AVLTreeNode *leftChild; //左儿子 struct AVLTreeNode *rightChild; //右儿子}Node,*AVLTree;/*** * @param data 存储的数据 * @param left 左儿子 * @param right 右儿子 * */static Node *createAVLTreeNode(int data,Node *left,Node *right){ // 为这个新的节点开辟内存空间 Node *node; if (((node = (Node *)malloc(sizeof(Node))) == NULL)){ return NULL; } // 为这个node赋初值 node-&gt;data = data; // 空子树的高度为0 node-&gt;height = 0; node-&gt;leftChild = left; node-&gt;rightChild = right; return node;}// 获取节点的高度int getHeightOfNode(Node *node){ return (node==NULL) ? 0 : node-&gt;height;}/* * LL：左左对应的情况(左单旋转)。 * * 返回值：旋转后的根节点 */static Node* leftLeftRotation(AVLTree k2){ AVLTree k1; k1 = k2-&gt;leftChild; // k2与k1的右子树进行互换 k2-&gt;leftChild = k1-&gt;rightChild; k1-&gt;rightChild = k2; k2-&gt;height = MAX( getHeightOfNode(k2-&gt;leftChild), getHeightOfNode(k2-&gt;rightChild)) + 1; k1-&gt;height = MAX( getHeightOfNode(k1-&gt;leftChild), k2-&gt;height) + 1; // 旋转完成之后的根节点是k1，即k1上浮了而原本的k2下沉为k1的儿子了 return k1;}/* * RR：右右对应的情况(右单旋转)。 * * 返回值：旋转后的根节点 */static Node* rightRightRotation(AVLTree k2){ AVLTree k1; k1 = k2-&gt;rightChild; // k2与k1的右子树进行互换 k2-&gt;rightChild = k1-&gt;leftChild; k1-&gt;leftChild = k2; k2-&gt;height = MAX( getHeightOfNode(k2-&gt;leftChild), getHeightOfNode(k2-&gt;rightChild)) + 1; //此时的k2为k1的左儿子，所以只需要比较k2和k1的右儿子的高度就好了 k1-&gt;height = MAX( getHeightOfNode(k1-&gt;rightChild), k2-&gt;height) + 1; // 旋转完成之后的根节点是k1，即k1上浮了而原本的k2下沉为k1的儿子了 return k1;}/** * * LR * 相当于进行了一次RR旋转一次LL旋转。 * */static Node *leftRightRotation(Node *k3){ //先对k3的左子树进行RR旋转，再对旋转后的k3进行LL旋转 k3-&gt;leftChild = rightRightRotation(k3-&gt;leftChild); return leftLeftRotation(k3);}/** * * RL * 相当于进行了一次LL旋转一次RR旋转。 * */static Node *rightLeftRotation(Node *k3){ //先对k3的右子树进行LL旋转，再对旋转后的k3进行RR旋转 k3-&gt;rightChild = leftLeftRotation(k3-&gt;rightChild); return rightRightRotation(k3);}/** * 传入要插入的树 * 传入要插入的数据 * 返回更新后的树的根节点 * */Node *insertIntoAVLTree(AVLTree tree,int data){ // 如果树是一个空树 if (tree == NULL){ // 那么就建立一个空节点 tree = createAVLTreeNode(data,NULL,NULL); // 如果创建失败的话 if (tree == NULL){ printf(&quot;Create Node Failed&quot;); } } if (data &lt; tree-&gt;data)//如果要插入的数值比根节点的值要小，那么就插入到其左子树中 { // 然后递归调用插入方法，直到找到一个空节点再插入！ tree-&gt;leftChild = insertIntoAVLTree(tree-&gt;leftChild,data); // 由于是插入到左子树中，因此只可能是左子树的高度大于右子树的高度 if (getHeightOfNode(tree-&gt;leftChild) - getHeightOfNode(tree-&gt;rightChild) == 2) { // 如果需要插入的值根节点的左子树还要小那么说明插入到了左子树的左侧，那就可以判断此时的不平衡状态为左左LL，调用LL旋转即可 if (data &lt; tree-&gt;leftChild-&gt;data) { tree-&gt;leftChild = leftLeftRotation(tree-&gt;leftChild); }else // 否则就说明大于这个节点的值，插入到在左子树的右儿子上，调用LR旋转 { tree-&gt;leftChild = leftRightRotation(tree-&gt;leftChild); } } }else if (data &gt; tree-&gt;data) {//如果要插入的数值比根节点的值要大，那么就插入到其由子树中 tree-&gt;rightChild = insertIntoAVLTree(tree-&gt;rightChild,data); if (getHeightOfNode(tree-&gt;rightChild) - getHeightOfNode(tree-&gt;leftChild) == 2)// 由于插入到右子树中那么就是只有可能右子树的高度大于左子树的高度 { if (data &gt; tree-&gt;rightChild-&gt;data) { tree-&gt;rightChild = rightRightRotation(tree-&gt;rightChild); }else { tree-&gt;rightChild = rightLeftRotation(tree-&gt;rightChild); } } }else { printf(&quot;Don't Insert The Same Node&quot;); } // 更新根节点的高度 int temp = MAX(getHeightOfNode(tree-&gt;leftChild),getHeightOfNode(tree-&gt;rightChild)); if (((MAX(getHeightOfNode(tree-&gt;leftChild),getHeightOfNode(tree-&gt;rightChild))) == 0) &amp;&amp; (tree-&gt;leftChild != NULL || tree-&gt;rightChild != NULL)) { // 其子节点全部都是叶子节点 // 说明两个子树至少存在一个，那么这个根节点的高度就是1 tree-&gt;height = 1; }else if (tree-&gt;leftChild == NULL &amp;&amp; tree-&gt;rightChild == NULL) { // 如果两个子树都不存在那么说明这个节点就是叶子节点，直接返回就好 return tree; }else { tree-&gt;height = (MAX(getHeightOfNode(tree-&gt;leftChild),getHeightOfNode(tree-&gt;rightChild))) + 1; } return tree;}int main(){ Node *root = createAVLTreeNode(10,NULL,NULL); Node *left = createAVLTreeNode(6,NULL,NULL); Node *right = createAVLTreeNode(13,NULL,NULL); root-&gt;leftChild = left; root-&gt;rightChild = right; root = insertIntoAVLTree(root,5); root = insertIntoAVLTree(root,3); return 0;} 测试用例1234567Node *root = createAVLTreeNode(10,NULL,NULL);Node *left = createAVLTreeNode(6,NULL,NULL);Node *right = createAVLTreeNode(13,NULL,NULL);root-&gt;leftChild = left;root-&gt;rightChild = right;root = insertIntoAVLTree(root,5);root = insertIntoAVLTree(root,3); 测试结果 图的表示 图的拓扑排序在图论中，拓扑排序是一个有向无环图的所有顶点的线性序列且该序列必须满足以下两个条件： 每个顶点出现且只出现一次 若存在一条从顶点A到顶点B的路径那么在序列中，A就在B的前面！ 因此只有有向无环图才会有拓扑排序，非有向无环图是没有拓扑排序的！ 求拓扑排序的方法： 从有向无环图中选取一个入度为0(没有前驱)的顶点，并输出 从这个图中删除这个顶点以及所有它指向其他顶点的有向边。也就是删除所有的出边！ 重复1，2直到图为空或者图中不再存在没有入度的顶点，如果到最后是第二种情况，那么就说明有向图中必定存在环（类似于循环结构，有出有入） 由于一个图中，在同一个时间点，可能存在有多个入度为零的顶点，因此一个有向无环图可以有多个不同的拓扑排序序列！ 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#define MAX 5typedef struct _ENode{ int index; // 该边的顶点的位置 struct _ENode *nextEdge; // 指向下一条弧的指针} ENode, *PENode;// _ENode 的变量别名// 邻接表中表的顶点typedef struct _VNode{ int index; // 顶点信息 ENode *firstEdge; // 指向第一条依附该顶点的弧} VNode;// 邻接表typedef struct _LGraph{ int vexNum; // 图的顶点的数目 int edgNum; // 图的边的数目 VNode vexs[MAX];} LGraph;// 边的数据typedef struct _EData{ int start; // 起始顶点 int end; // 结束顶点} EData;static EData gData[] = { {0, 1}, {0, 3}, {1, 2}, {1, 3}, {2, 4}, {3, 2}, {3, 4}};void LinkToTheEnd(ENode *list, ENode *node){ ENode *p = list; while (p-&gt;nextEdge) { p=p-&gt;nextEdge; } p-&gt;nextEdge = node; }// 创建一张图LGraph *createLinkedGraph(){ ENode *node; LGraph *pG; int start,end; if ((pG = (LGraph *)malloc(sizeof(LGraph))) == NULL) return NULL; memset(pG, 0, sizeof(LGraph)); pG-&gt;vexNum = MAX; pG-&gt;edgNum = 7; for (int i = 0; i &lt; pG-&gt;vexNum; i++) { pG-&gt;vexs[i].index = i; pG-&gt;vexs[i].firstEdge = NULL; } // 初始化&quot;邻接表&quot;的边 for (int i = 0; i &lt; pG-&gt;edgNum; i++) { // 读取边的起始顶点,结束顶点 start = gData[i].start; end = gData[i].end; // 初始化node1 node = (ENode *)malloc(sizeof(ENode)); memset(node,0,sizeof(ENode)); node-&gt;index = end; // 将node1链接到&quot;p1所在链表的末尾&quot; if (pG-&gt;vexs[start].firstEdge == NULL) pG-&gt;vexs[start].firstEdge = node; else LinkToTheEnd(pG-&gt;vexs[start].firstEdge, node); } return pG;}// 获取图的出度数组void createInDegree(LGraph *g,int InDegree[]){ ENode *p; for (int i = 0; i &lt; g-&gt;vexNum; i++) { p = g-&gt;vexs[i].firstEdge; while (p) { InDegree[p-&gt;index]++; p = p-&gt;nextEdge; } }}// 更新维护入度数组/** * g 图指针 * InDegree 入度数组 * node 需要改变的节点指针 * 删除节点后把它在入度数组中置为-1 * */void updateInDegree(LGraph *g,int InDegree[],int index){ InDegree[index] = -1; ENode *p; p = g-&gt;vexs[index].firstEdge; while (p) { InDegree[p-&gt;index]--; p = p-&gt;nextEdge; }}// TopologicalSort 拓扑排序void TopologicalSort(LGraph *g){ ENode *node; int InDegree[g-&gt;vexNum]; memset(InDegree,0,sizeof(int)*g-&gt;vexNum); createInDegree(g,InDegree); while (1) { int j = -1; for (int i = 0; i &lt; g-&gt;vexNum; i++) { if (InDegree[i] == 0) { j = i; break; } } if (j == -1) { break; } printf(&quot;%d&quot;,j); updateInDegree(g,InDegree,j); } }int main(int argc, char const *argv[]){ LGraph *g; g = createLinkedGraph(); TopologicalSort(g); return 0;} 测试用例123456789static EData gData[] = { {0, 1}, {0, 3}, {1, 2}, {1, 3}, {2, 4}, {3, 2}, {3, 4}}; 测试结果 最小编辑距离 在有的文章中，替换的代价是2，而在有的文章中，替换的代价是1，本文按照代价为1的来计算。不过个人认为代价为二更加合理。 动态规划表的初始化 D(0,j)=j，空串和长度为j的Y子串间的最小编辑距离（添加或删除对应的次数） D(i,0)=i，长度为i的X子串和空串间的最小编辑距离添加或删除对应的次数） 而最终的表的结果是： 在三个中取最小值作为矩阵的元素！也就是为了找出变成另一个字符串的最小代价 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#define min(a, b) (a &lt; b ? a : b)#define MAX 10/** * res 字符1--原始字符串 * des 字符2--目标字符串 * * */int minEditDistance(char *res, char *des){ //首先初始化动态表--填充相对于空字符的编辑距离，也就是字符长度 int dis[MAX][MAX] = {0}; for (int i = 1; i &lt;= (int)strlen(des); i++) { dis[0][i] = i; } for (int j = 1; j &lt;= (int)strlen(res); j++) { dis[j][0] = j; } //循环遍历整个数组，计算每一个编辑距离 for (int i = 1; i &lt;= (int)strlen(res); i++) { for (int j = 1; j &lt;= (int)strlen(des); j++) { // 如果在该位置的两个元素相同，那么到此的最小编辑距离就等同于不包含这两个元素的最小编辑距离 if (res[i-1] == des[j-1]) { dis[i][j] = dis[i-1][j-1]; } else { /** * 相对而言的！向下走的意思就是多出了一个多余元素，在相对于上面那一格的最小编辑距离而言需要将这个多出来的元素删掉 * 同理，向下走就是目标串多了一个元素，要在左侧编辑的基础下再多加一个元素 * 向右下角走也是差不多的道理，既有一个多余元素，而且目标串也多了一个元素，所以要使用替换操作。 * */ int delEd = dis[i][j-1]+1;//往下走就是删除 int insEd = dis[i-1][j]+1;//往右走是插入 int subEd = dis[i-1][j-1]+1;//向右下角走--对角线走就是替换 在这里替换的代价是1 int minEd = min(min(delEd,insEd),subEd); dis[i][j] = minEd; } } } for(int m = 0; m &lt; MAX; m++){ for(int n = 0; n &lt; MAX; n++){ printf(&quot;%d&quot;,dis[m][n]); } printf(&quot;\\n&quot;); } return dis[(int)strlen(res)][(int)strlen(des)];}int main(int argc, char const *argv[]){ printf(&quot;Min Distance of %s to %s is %d \\n&quot;,&quot;sunny&quot;,&quot;snowy&quot;,minEditDistance(&quot;sunny&quot;,&quot;snowy&quot;)); printf(&quot;Min Distance of %s to %s is %d&quot;,&quot;me&quot;,&quot;ame&quot;,minEditDistance(&quot;me&quot;,&quot;ame&quot;)); return 0;} 测试用例12printf(&quot;Min Distance of %s to %s is %d \\n&quot;,&quot;sunny&quot;,&quot;snowy&quot;,minEditDistance(&quot;sunny&quot;,&quot;snowy&quot;)); printf(&quot;Min Distance of %s to %s is %d&quot;,&quot;me&quot;,&quot;ame&quot;,minEditDistance(&quot;me&quot;,&quot;ame&quot;)); 测试结果 表格表示 · s n o w y · 0 1 2 3 4 5 s 1 0 1 2 3 4 u 2 1 1 2 3 4 n 3 2 1 2 3 4 n 4 3 2 2 3 4 y 5 4 3 3 3 3 所以最终的结论是sunny到snowy的最小编辑距离为3 。 · a m e · 0 1 2 3 m 1 1 1 2 e 2 2 2 1 所以最终的结论是me到ame的最小编辑距离为1 。 霍夫曼编码 由此可以得到字符编码的前缀码，不过使用前缀码的前提是每个字符编码都不是其他编码的前缀！因此每个字符都要放在树的叶子节点上。 这样做就确保了编码没有二义性。 编码的比特数：$$c_i在d_i的深度出现了f_i次，那么这个字符所占用的比特数为：\\begin{equation*} \\sum_{i=1}^Nd_if_i \\end{equation*}$$ 其中深度的数值等于其编码的位数！ Huffman算法算法对一个由树组成的森林进行，该森林中一共有C片叶子，也就是有C个字符需要编码。一棵树的权重等于它的树叶的频率之和。任取最小权重的两棵树$T_1$,$T_2$,并以这两棵树为子树形成新的树，将这样的过程进行C-1次，最终得到的就是Huffman编码的最优树。 为什么需要进行C-1次： ​ 因为森林中最开始有C棵树，也就是一共有C棵只有一个节点的树，每一次选取都会让两棵树合并成一棵树，树的总数减少一，因此从C到1也就需要进行C-1次 示例图： 该算法每一次选取子树都是在当前条件下选取权重最小的子树，因此该算法是贪婪算法。 源代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdfix.h&gt;/*** * 哈夫曼编码树 * */typedef struct HuffmanTree{ char con[2]; // 节点的内容 int f; //节点的频率 struct HuffmanTree *leftChild; //左儿子 struct HuffmanTree *rightChild; //右儿子} * Node;// 创建一个新的节点Node createNode(char con[], int f, Node left, Node right){ // 先创建一个指针 Node newNode; if ((newNode = (Node)malloc(sizeof(Node))) == NULL) { return NULL; } memset(newNode, 0, sizeof(Node)); // strcpy(newNode-&gt;con,con); if (con) { memcpy(newNode-&gt;con,con,2*sizeof(char)); }else { memset(newNode-&gt;con,0,2*sizeof(char)); } // newNode-&gt;con = con; newNode-&gt;f = f; newNode-&gt;leftChild = left; newNode-&gt;rightChild = right; return newNode;}/** * tree 树的数组 * legth 数组的长度 * */Node huffman(Node tree[], int length){ Node tempNode, node1, node2,parent; //如果这个数组里面只剩下了两个元素，那么就说明已经排序完成了 if (length == 2) { node1 = tree[0]; node2 = tree[1]; parent = createNode(NULL,node1-&gt;f+node2-&gt;f,node1,node2); return parent; } // 给这个节点数组排序，找出频率最小的两个点 int j = 0; for (int i = 0; i &lt; length; i++) { tempNode = tree[i]; for (j = i; j &gt; 0 &amp;&amp; tempNode-&gt;f &lt; tree[j - 1]-&gt;f; j--) { tree[j] = tree[j - 1]; } tree[j] = tempNode; } // 频率最小的两个节点 node1 = tree[0]; node2 = tree[1]; parent = createNode(NULL,node1-&gt;f+node2-&gt;f,node1,node2); // 重新构建一个数组 Node newArray[length-1]; for (int i = 0; i &lt; length - 2; i++) { newArray[i] = tree[i+2]; } newArray[length-2] = parent; parent = huffman(newArray,length-1); return parent;}int main(int argc, char const *argv[]){ Node node_a, node_e, node_i, node_s, node_t, node_sp, node_nl,result; node_a = createNode(&quot;a&quot;, 10, NULL, NULL); node_e = createNode(&quot;e&quot;, 15, NULL, NULL); node_i = createNode(&quot;i&quot;, 12, NULL, NULL); node_s = createNode(&quot;s&quot;, 3, NULL, NULL); node_t = createNode(&quot;t&quot;, 4, NULL, NULL); node_sp = createNode(&quot;sp&quot;, 13, NULL, NULL); node_nl = createNode(&quot;nl&quot;, 1, NULL, NULL); Node nodeArray[] = {node_a, node_e, node_i, node_s, node_t, node_sp, node_nl}; result = huffman(nodeArray, 7); return 0;} 测试用例12345678910Node node_a, node_e, node_i, node_s, node_t, node_sp, node_nl,result;node_a = createNode(&quot;a&quot;, 10, NULL, NULL);node_e = createNode(&quot;e&quot;, 15, NULL, NULL);node_i = createNode(&quot;i&quot;, 12, NULL, NULL);node_s = createNode(&quot;s&quot;, 3, NULL, NULL);node_t = createNode(&quot;t&quot;, 4, NULL, NULL);node_sp = createNode(&quot;sp&quot;, 13, NULL, NULL);node_nl = createNode(&quot;nl&quot;, 1, NULL, NULL);Node nodeArray[] = {node_a, node_e, node_i, node_s, node_t, node_sp, node_nl};result = huffman(nodeArray, 7); 测试结果 图的表示","link":"/2019/12/12/547/"},{"title":"我感受到了深深的恶意","text":"只想骂人 为什么固定链接搞得我这么痛苦，已经折磨了我三天了，网上的方法几乎都试了个遍，但还是没有解决。 气得我又去阿里云买了一个WordPress镜像的学生服务器，但为什么这个新买来的也是一堆大坑？？？？？？ 我真的是气的黑人问号。 mmp 老子给你关联了域名，浏览器竟然还会指向前一个博客，里面登录过程也是一个赛一个混乱，老子现在可以退款吗？？？？ 我这两天真的是暴风贫穷，一想到过两天就下个月了就要给奶茶老公还钱我就感到了一分害怕。 nmd，wsm 看到这个标志我又有点火大，买了才想起来国内服务器绑定域名还要去备案mmp，一想到备案就想起来那个神奇的拍照环节，竟然还要搞个特定的背景，站在背景前拍摄才行，mmmmmmp。 真的是气哦，又浪费了一笔钱。 ftp也是，搞了一个下午都没有搞起来，我觉得我这几天是不是有问题，什么坑都没解决还往一个又一个的大坑里面跳。 我死了，没救了","link":"/2019/07/27/%E6%88%91%E6%84%9F%E5%8F%97%E5%88%B0%E4%BA%86%E6%B7%B1%E6%B7%B1%E7%9A%84%E6%81%B6%E6%84%8F/"},{"title":"散列表相关的几个算法","text":"根据算法图解一书写的两个算法：广度优先算法以及狄克斯特拉算法： 散列表散列表在Python中也称作字典，通常的定义方式为： name = dict() 也可以写作： name = {} 散列表中的每一项都由Key(键)和Value(值)组成。散列表的搜寻效率在一般情况下接近O(1)而在最糟糕的情况下为O(n),可见是一个非常好的数据结构。 广度优先算法广度优先算法顾名思义就是优先寻找临近的可能对象，当临近的对象均不是所搜寻的目标时，再去寻找较远的可能对象。 首先创建一张图，并填充对象：下面是广度优先算法 123456789101112131415161718graph = {}graph[&quot;You&quot;] = [&quot;Mike&quot;, &quot;Alice&quot;, &quot;TankNee&quot;]graph[&quot;Mike&quot;] = [&quot;Dem&quot;, &quot;Hans&quot;, &quot;Chem&quot;]graph[&quot;Alice&quot;] = [&quot;Pigh&quot;]graph[&quot;TankNee&quot;] = [&quot;Chem&quot;]graph[&quot;Dem&quot;] = []graph[&quot;Hans&quot;] = []graph[&quot;Pigh&quot;] = []graph[&quot;Chem&quot;] = [] 其中的对应关系为： {'Mike': ['Dem', 'Hans', 'Chem'], 'Pigh': [], 'Alice': ['Pigh'], 'TankNee': ['Chem'], 'Dem': [], 'Hans': [], 'You': ['Mike', 'Alice', 'TankNee'], 'Chem': []} 散列表是随机排布的，所以位置的前后并没有什么联系。并且其中的Key不仅仅可以对应一个值也可以对应一个列表。 我们接下来还需要一个队列来实现FIFO（First in First out）1234567queue = deque() # 生成一个队列queue += graph[&quot;You&quot;] # 将You对应的所有邻居都加入到队列里来searched = [] # 一个列表，用来存放已经检查过的节点count = 0 #一个计数器 接下来再去实现搜寻的函数123456789101112131415161718def personIsTrader(name): if(name[-1] == 'm'): return True else: return Falsewhile(queue): people = queue.popleft() # 将队列最左边的值弹出，然后赋值给people if(people not in searched): if(personIsTrader(people)): print(&quot;He is Trader --&quot;+people) print(count) count = 0 else: queue += graph[people] # 如果这个额peop不是我们要搜寻的目标那么将他的邻居添加到队列的最后面 count += 1 # append 增加一个元素在列表的最末尾 # 标记这个people已经完成检查 searched.append(people) 狄克斯特拉算法原理：找出图中开销最小的节点并且保证没有开销更小的方式到达该节点下面是一个例子： 读者可以试着将这张加权图画出来 12345678910pic = {}pic[&quot;Head&quot;] = {}pic[&quot;Head&quot;][&quot;A&quot;] = 6pic[&quot;Head&quot;][&quot;B&quot;] = 2pic[&quot;A&quot;] = {}pic[&quot;A&quot;][&quot;Tail&quot;] = 1pic[&quot;B&quot;] = {}pic[&quot;B&quot;][&quot;A&quot;] = 3pic[&quot;B&quot;][&quot;Tail&quot;] = 5pic[&quot;Tail&quot;] = {} 123456789101112131415# 下面是开销/权重表# 记录当前到达这几个节点的最小开销infinity = float(&quot;inf&quot;) # 无限大costs = {}costs[&quot;A&quot;] = 6costs[&quot;B&quot;] = 2costs[&quot;Tail&quot;] = infinity# 下面是父节点表# 记录路的父节点parents = {}parents[&quot;A&quot;] = &quot;Head&quot;parents[&quot;B&quot;] = &quot;Head&quot;parents[&quot;Tail&quot;] = None# 记录已经检查过的节点detected = [] 123456789101112# 搜寻距离最短的节点def find_lowest_cost_node(cost): lowest_cost = float(&quot;inf&quot;) lowest_cost_node = None for node in cost: # 遍历cost散列表 cos = cost[node] # 把Key为node代表的值的Value传递给cos变量 # 如果这个值比最小的值还要小并且这个节点没有被检查过那么就替换 if cos &lt;= lowest_cost and node not in detected: lowest_cost = cos lowest_cost_node = node # 将节点的键值作为返回值 return lowest_cost_node 12345678910111213node = find_lowest_cost_node(costs)print (costs)while node is not None: cost = costs[node] neighbors = pic[node] for n in neighbors.keys(): All_cost = cost + neighbors[n] if All_cost &lt;= costs[n]: costs[n] = All_cost parents[n] = node detected.append(node) node = find_lowest_cost_node(costs)print costs[&quot;Tail&quot;] 适用范围：有向无环图用来寻找最小加权路","link":"/2019/08/12/%E6%95%A3%E5%88%97%E8%A1%A8/"},{"title":"数据结构--树（BST）","text":"​ 树是一种简单的数据结构，其插入查找的速度都相对均匀：O(logN)，这里用到的主要是二叉查找树binary search tree。 了解树在文件系统里的应用 计算算术表达式的值，如中缀表达式等 树是如何实现以O(logN)的平均时间进行查找操作，以及最坏时间O(logN)。 树的基本模型 树的构成：​ 每棵树都有根节点和数个非空子树组成 ​ 一棵树是N个节点和N-1条边的集合，原因很简单，除了根节点之外，每个节点都与其父节点有一条边相连接。 树的路径长度，高度与深度： 长度：n1-nk的路径上的边的条数，树上的任意一个节点都有到跟的路径 高度：任意ni节点到根节点的唯一路径的长度看作为该节点的高度，即节点越往下，高度越大，与根节点离得越远高度越大！ 深度：以ni为当前子树的根节点，向下寻找树叶，由该节点到树叶的路径的长度，记作该节点的高度 不管是深度也好，高度也好，基本上都是相对于你选择的根节点而言的，并不是完全固定不变的，是一个相对的数值，不过求出每一个高度和深度的路径都是唯一的 树的代码实现树的节点声明：123456typedef struct TreeNode *PtrToNode;struct TreeNode{ ElementType Element; //抽象数据类型，定义树节点存放的数据 PtrToNode FirstChild; //第一个子树的指针（第一儿子） PtrToNode NextChild; //下一个子树的指针（下一个兄弟）} 因为实现并不知道子树的个数，所以直接在声明里指定个数是不理智的，所以应该换一种方式，使用链表来存储树，具体的图明天再来画吧！ 树的遍历及应用：UNIX文件系统：文件树的遍历 12345678ListD(DirectryOfFile D,int Depth){ //文件目录，目录深度 //D是一个合法的文件入口那么就进行遍历 if(D is a legitimate entry){ for (child C : D){ ListD(C,Depth+1); } }} ​ 经过几次递归之后就可以完全打印出文件目录。 遍历方式： 先序遍历： 在先序遍历中，对节点的处理在处理儿子结点之前！下面是线序遍历的图例，节点的数字代表遍历的顺序。 后序遍历： 在后序遍历中，对节点的处理在处理儿子节点之后！下面是后序遍历的图例。 一些个人理解：不管是先序遍历还是后序遍历还是层序遍历，其本质都是一件事情：递归，通过一种相似的查找方式打印出需要遍历的树中所有的节点。 二叉树定义：​ 二叉树是一种树，其中每个节点的子节点不得多于两个。二叉树的一个重要性质是平均二叉树的深度要比N要小得多为O($\\sqrt{N} $),而二叉查找树的平均深度是O($\\log{N}$)。 实现：1234567typedef struct TreeNode *PtrToNode;typedef struct PtrNode Tree;struct TreeNode{ ElementType Element; //节点的值 Tree left; //左子树 Tree right; //右子树} 每个有N个节点的二叉树都有N+1个NULL空指针 表达式树：​ 利用二叉树实现中缀表达式，前缀表达式等等，还需要结合队列来实现整个数据结构！​ 表达式树的树叶表示表达式的操作数，比如变量或者常量，而其他的根结点代表操作符。 所有的操作符都是二元操作符。下面给出一个例子：1左子树a+(b*c)。右子树(((d*e）+f)*g) 二叉查找树 概念：对于二叉查找树中的任意节点X，它的左子树所有关键字值小于该节点所代表的关键字的值，而其右子树的所有关键字的值大于X的关键字值。因此该二叉树的所有元素都可以用某种统一的方式排序。 这里有一个二叉查找树的查找时间复杂度的计算问题，我之前上课的时候没怎么想明白，刚刚上网查了一下发现是我智障了。其实二叉查找树的原理跟二分法的原理是完全一样的：在N个数据的数组里取第Ｎ／2个元素，将这个元素与输入元素进行对比，如果小与输入元素就去该节点的右子树中查找，如果大于就去左子树。假设查找的次数为x次，那么表达式就是：N*（$1/2$）^X = 1，即最坏情况是查找到首尾元素，最后即可得出查找的时间复杂度为O($\\log{N}$). 增删查改： Insert Delete：删除操作是相对困难的一部分，这里仅仅讨论处理有两个儿子的操作。 一般的删除策略是用其右子树的最小数据（右子树的最左侧的那个节点）代替该节点的数据，并递归地删除那个（被替换掉的）节点。由于该节点不可能有左子树，所以第二次删除要容易。接下来是一个例子 然后被移动的关键字3像之前删除2一样删除！","link":"/2019/10/21/524/"},{"title":"无话可说","text":"好像每天都被我爸我妈催着去干着干那，迟一两分钟便会得到暴躁臭骂一顿。 不活啦，我要回学校 算了算了，活命要紧，毕竟无钱。","link":"/2019/07/29/%E6%97%A0%E8%AF%9D%E5%8F%AF%E8%AF%B4/"},{"title":"昼夜双版Typecho主题SplityRemake-新世界的灰烬","text":"但愿旧世界的火光能够燃尽晦暗 在前端的路上走走停停，玩了快大半年，发现自己确实还没有能力承载一个完成的项目，每次都是做了一半就已经十分的疲倦。 Tribute and Disclaimer本来是想拿着原始的Default主题直接修改，但发现实在是太简陋了…就没有用那个，前两天在一个网站上看到了这个主题的原版(Splity)。 其实这个的原版也是仿照着一个付费的wordpress主题写的，我咨询了Splity的原作者，他许可了我的二次修改与发布，如果上述有任何一方认为我的行为有侵权嫌疑，那么请联系我删除该主题的所有信息。 再次感谢每一位作者的付出与灵感，我不希望我的改动会损害到您的利益，如果实有冒犯，请联系我删除，谢谢 Here is the change log 修复黑暗模式的bug 增加文章目录的输出 调整文章缩略图的输出 去除主页的走马灯效果 去除个人信息栏的简介– 后续准备添加一言api(已完成) 调整最新文章的数量 文章页自动隐藏 最新文章和最热文章两个项目 内置添加图片灯箱效果 调整markdown文章格式 调整header的栏目输出 页首添加了动画 修改了文章中a标签的样式 修改了图片的显示 mobile端文章目录的支持 修复了图片分享的bug 添加了pretag和prebadge的字段支持 徽标和标签支持 详情请前往文章编辑页查看！ 修复了tag输出的问题 添加颜文字的支持 添加了对LaTeX公式的支持 修复OwO颜文字的显示 修改评论区的字体 修复button样式 修复生成分享海报时的问题 修复海报图片跨域问题 修复海报摘要显示问题 添加index界面文章发表时间的显示 添加了评论区UA的显示 加回了走马灯效果，并修改了图片显示逻辑 修复登录按钮显示异常 Download and use 首先你应该前往GitHub或者Gitea的主页下载SplityRemake的压缩包 master分支的版本是较为稳定的版本，一般情况下请下载该版本的主题 develop分支是正在开发中的版本，一般来说每一天会合并一次develop和master 将下载的压缩包上传到typecho的theme文件夹下 解压压缩包，并重命名为splity，这一点十分重要，请务必改对名称，否则会出现不可预知的错误 打开后台的主题页面配置主题 Issue已知的错误是海报生成时有大概率失败，这与您的图片托管服务商有关，请配置跨域信息 To Do 完成归档页面的编写 实现留言板界面的优化 实现评论区表情的输入 实现友链的优化 实现OwO的夜间模式的优化","link":"/2020/04/15/splity-remake/"},{"title":"数据结构入门？这一篇就够了","text":"算法分析运行时间的计算分析上界：$O(f(N))$ 下界：$Ω(g(N))$ 准确表达则为：$Θ(h(N))$ 也就是说都是一个关于N的函数！ 这么做的目的是为了比较两个算法的相对增长速率 求解算法时间复杂度的步骤 找出算法中的基本语句； 算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。 计算基本语句的执行次数的数量级； 只需计算基本语句执行次数的数量级，这就意味着只要保证基本语句执行次数的函数中的最高次幂正确即可，可以忽略所有低次幂和最高次幂的系数。这样能够简化算法分析，并且使注意力集中在最重要的一点上：增长率。 用大Ο记号表示算法的时间性能。 将基本语句执行次数的数量级放入大Ο记号中。 可以忽略末尾带上的常数项 1234567891011121314// 求数组中的子序列的和的最大值int MaxSubsequenceSum(const int A[],int N){ int maxSum = 0; int tempSum = 0; for(int i = 0;i &lt; N;i++){ tempSum += A[i]; if(tempSum &gt; maxSum){ maxSum = tempSum; }else if(tempSum &lt; 0){ tempSum = 0; } } return maxSum;} 复杂度函数的运算规则 抽象数据类型ADT表表分为两种，顺序表与链表。其中顺序表要求系统给其分配的内存单元是连续的，因此，顺序表的访问时间可以做到线性时间，第二种是链表，链表不要求连续的内存空间，但其中的每一块都是与其他链表节点耦合的。 顺序表即数组，内存地址连续。 访问时为线性访问，速度较快。插入删除时代价较大，因为需要更改其后所有元素的信息才能维持当前的顺序表。 链表在C语言中是通过建立结构体然后存储指针的方式来进行访问的。 1234567891011121314// 邻接表中表的顶点typedef struct _VNode{ int index; // 顶点信息 ENode *firstEdge; // 指向第一条依附该顶点的弧} VNode;// 邻接表typedef struct _LGraph{ int vexNum; // 图的顶点的数目 int edgNum; // 图的边的数目 VNode vexs[MAX];} LGraph; 代码片段 循环链表双向链表双向循环链表栈特点：先进后出FILO 只需要一个指针就可以利用链表来实现栈的数据结构，在栈中只有栈顶可以出入数据，栈底的数据只有等其他数据都出去了才能被弹出 两个栈操作：PUSH POP 实例：使用栈数据结构来实现后缀表达式 队列特点：先进先出FIFO 对于队列而言，有两个口可以与外界交换数据，分别是队列头和队列尾部。 只允许在队列尾部入队，在队列头部出队。 两个操作：Enqueue Dequeue 树二叉树二叉查找树 之前写的二叉树博客 本地 AVL树AVL树是带有平衡条件的二叉查找树。 平衡条件必须要相对容易保持，而且必须保证树的深度是$O(logN)$，那么在AVL树中，就是保证节点的左右子树的高度之差小于2，即只能为1或者0 。 下面是AVL树插入的C语言实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAX(a,b) (a &gt; b) ? (a) : (b)/** * AVL树的结构体定义 * */typedef struct AVLTreeNode{ int data; //节点存储的值 int height; //当前节点的高度 struct AVLTreeNode *leftChild; //左儿子 struct AVLTreeNode *rightChild; //右儿子}Node,*AVLTree;/*** * @param data 存储的数据 * @param left 左儿子 * @param right 右儿子 * */static Node *createAVLTreeNode(int data,Node *left,Node *right){ // 为这个新的节点开辟内存空间 Node *node; if (((node = (Node *)malloc(sizeof(Node))) == NULL)){ return NULL; } // 为这个node赋初值 node-&gt;data = data; // 空子树的高度为0 node-&gt;height = 0; node-&gt;leftChild = left; node-&gt;rightChild = right; return node;}// 获取节点的高度int getHeightOfNode(Node *node){ return (node==NULL) ? 0 : node-&gt;height;}/* * LL：左左对应的情况(左单旋转)。 * * 返回值：旋转后的根节点 */static Node* leftLeftRotation(AVLTree k2){ AVLTree k1; k1 = k2-&gt;leftChild; // k2与k1的右子树进行互换 k2-&gt;leftChild = k1-&gt;rightChild; k1-&gt;rightChild = k2; k2-&gt;height = MAX( getHeightOfNode(k2-&gt;leftChild), getHeightOfNode(k2-&gt;rightChild)) + 1; k1-&gt;height = MAX( getHeightOfNode(k1-&gt;leftChild), k2-&gt;height) + 1; // 旋转完成之后的根节点是k1，即k1上浮了而原本的k2下沉为k1的儿子了 return k1;}/* * RR：右右对应的情况(右单旋转)。 * * 返回值：旋转后的根节点 */static Node* rightRightRotation(AVLTree k2){ AVLTree k1; k1 = k2-&gt;rightChild; // k2与k1的右子树进行互换 k2-&gt;rightChild = k1-&gt;leftChild; k1-&gt;leftChild = k2; k2-&gt;height = MAX( getHeightOfNode(k2-&gt;leftChild), getHeightOfNode(k2-&gt;rightChild)) + 1; //此时的k2为k1的左儿子，所以只需要比较k2和k1的右儿子的高度就好了 k1-&gt;height = MAX( getHeightOfNode(k1-&gt;rightChild), k2-&gt;height) + 1; // 旋转完成之后的根节点是k1，即k1上浮了而原本的k2下沉为k1的儿子了 return k1;}/** * * LR * 相当于进行了一次RR旋转一次LL旋转。 * */static Node *leftRightRotation(Node *k3){ //先对k3的左子树进行RR旋转，再对旋转后的k3进行LL旋转 k3-&gt;leftChild = rightRightRotation(k3-&gt;leftChild); return leftLeftRotation(k3);}/** * * RL * 相当于进行了一次LL旋转一次RR旋转。 * */static Node *rightLeftRotation(Node *k3){ //先对k3的右子树进行LL旋转，再对旋转后的k3进行RR旋转 k3-&gt;rightChild = leftLeftRotation(k3-&gt;rightChild); return rightRightRotation(k3);}/** * 传入要插入的树 * 传入要插入的数据 * 返回更新后的树的根节点 * */Node *insertIntoAVLTree(AVLTree tree,int data){ // 如果树是一个空树 if (tree == NULL){ // 那么就建立一个空节点 tree = createAVLTreeNode(data,NULL,NULL); // 如果创建失败的话 if (tree == NULL){ printf(&quot;Create Node Failed&quot;); } } if (data &lt; tree-&gt;data)//如果要插入的数值比根节点的值要小，那么就插入到其左子树中 { // 然后递归调用插入方法，直到找到一个空节点再插入！ tree-&gt;leftChild = insertIntoAVLTree(tree-&gt;leftChild,data); // 由于是插入到左子树中，因此只可能是左子树的高度大于右子树的高度 if (getHeightOfNode(tree-&gt;leftChild) - getHeightOfNode(tree-&gt;rightChild) == 2) { // 如果需要插入的值根节点的左子树还要小那么说明插入到了左子树的左侧，那就可以判断此时的不平衡状态为左左LL，调用LL旋转即可 if (data &lt; tree-&gt;leftChild-&gt;data) { tree-&gt;leftChild = leftLeftRotation(tree-&gt;leftChild); }else // 否则就说明大于这个节点的值，插入到在左子树的右儿子上，调用LR旋转 { tree-&gt;leftChild = leftRightRotation(tree-&gt;leftChild); } } } else if (data &gt; tree-&gt;data) {//如果要插入的数值比根节点的值要大，那么就插入到其由子树中 tree-&gt;rightChild = insertIntoAVLTree(tree-&gt;rightChild,data); if (getHeightOfNode(tree-&gt;rightChild) - getHeightOfNode(tree-&gt;leftChild) == 2)// 由于插入到右子树中那么就是只有可能右子树的高度大于左子树的高度 { if (data &gt; tree-&gt;rightChild-&gt;data) { tree-&gt;rightChild = rightRightRotation(tree-&gt;rightChild); }else { tree-&gt;rightChild = rightLeftRotation(tree-&gt;rightChild); } } }else { printf(&quot;Don't Insert The Same Node&quot;); } // 更新根节点的高度 if (((MAX(getHeightOfNode(tree-&gt;leftChild),getHeightOfNode(tree-&gt;rightChild))) == 0) &amp;&amp; (tree-&gt;leftChild != NULL || tree-&gt;rightChild != NULL)) { // 其子节点全部都是叶子节点 // 说明两个子树至少存在一个，那么这个根节点的高度就是1 tree-&gt;height = 1; }else if (tree-&gt;leftChild == NULL &amp;&amp; tree-&gt;rightChild == NULL) { // 如果两个子树都不存在那么说明这个节点就是叶子节点，直接返回就好 return tree; }else { tree-&gt;height = (MAX(getHeightOfNode(tree-&gt;leftChild),getHeightOfNode(tree-&gt;rightChild))) + 1; } return tree;}int main(){ Node *root = createAVLTreeNode(10,NULL,NULL); Node *left = createAVLTreeNode(6,NULL,NULL); Node *right = createAVLTreeNode(13,NULL,NULL); root-&gt;leftChild = left; root-&gt;rightChild = right; root = insertIntoAVLTree(root,5); // 此时接着插入值为3的节点就会破坏AVL树的平衡条件 root = insertIntoAVLTree(root,3); printf(&quot;Hello world!\\n&quot;); return 0;} 伸展树B-树B-树是为了磁盘存储而设计的一种多叉树，是多叉平衡查找树 用阶数来定义B-树：B 树又叫平衡多路查找树。一棵m阶的B 树具有以下性质： 每个节点的子节点个数为$$M/2 ≤ N ≤ M$$ 并且B树的全部叶子节点在同一高度上 根节点至少有两个子树 由$N$ 个子树的节点一定含有$N-1$个关键字 Ki (i=1...n)为关键字，且关键字按顺序升序排序K(i-1)&lt; Ki。 Pi为指向子树根的接点，且指针P(i-1)指向子树中所有结点的关键字均小于Ki，但都大于K(i-1)。–指针域的定义 树的遍历先序遍历，后序遍历。其中的前/后都是儿子节点相对于父节点而言的！ 先序遍历：对根节点的处理在儿子节点的处理之前 后序遍历：对儿子节点的处理在根节点的处理之前 中序遍历：先遍历左子树再遍历根节点最后遍历右子树。可以生成自然的中缀表达式 树中很重要的一个思想就是递归，因为树，树的子节点，等等结构都是相似的，因此同一种规律/算法就可以不断的反复套用。在遍历，插入，增删查改中都会用到递归的思想。 散列散列的定义散列表的实现被称为散列（Hashing） 散列是一种以常熟平均时间执行插入删除查找的技术。但是散列表中的元素之间的排列顺序是随机的，因此是无法通过线性时间来打印散列表 散列函数：其作用就是将关键字尽可能合适的映射到不同的存储单元中去。 但是毫无疑问，由于存储单元的数目是有限的而关键字的个数是无穷的，在后期的散列分配映射过程中肯定会遇到冲突现象，因此需要解决冲突。 当关键字是整数时，可以通过对单元个数取模来实现散列函数的确定，但是如果散列表的大小为10，而关键字多是以0结尾，那么这种情况下散列分配的结果就不够理想，因此，在设计散列表的大小时应该尽量采用素数大小！ 解决散列冲突问题如果当一个元素被插入时另一个元素已经存在，即两个元素的散列值相同，那么就会产生一个冲突！ 分离链接法分离链接法的做法是将散列到同一个散列值的所有元素都保留到一个表中，并且这些表都有表头，如果空间较为局促，那也可以不使用表头 填装因子$λ$为散列表中的元素个数与散列表大小的比值 装填因子Load factor $λ$=元素个数/哈希表的大小=链表的平均长度 输入规模的大小不用N，而用λ 平均情况分析（λ=O(1),O(1)） 不成功的查找: λ 次比较（ 1+λ ） 成功查找：1+λ/2（ 1+λ ） 插入：1+λ 删除：1+λ/2（ 1+λ ） 最坏情况分析(λ=O(N),所有元素哈希到同一链表，O(N)) 不成功的查找 成功查找 插入 删除 分离链接法的一般法则是使得表的大小尽量与预料的元素个数差不多，即尽量让$λ≈1$,是表的大小尽量是一个素数，且各个冲突处理链表尽可能短。 缺点是分离链接法浪费了大量时间在分配内存空间上。 开放定址法在开放定址法中，不使用指针，而是用了另一种方式，它在遇到冲突时，选择在散列表中寻找其他没有被使用的单元，直到选中了空单元才停止。$$h_i(X) = (Hash(X)+F(i)) \\mod TableSize$$因此开放定址法的空间需求相对分离链接法要更大一般而言$λ≤0.5$。 线性探测法在线性探测法中，函数F是i的线性函数，即F的最高次数为1次，典型情况为$$F(i) = i$$这相当于逐个探测每个散列表单元，并且必要时可以返回循环遍历整个散列表直到查到一个可用的空单元。 容易看出，如果插入的关键字的散列结果较为接近，那么就会出现一次聚集现象。 如果表有超过一半可以被使用的话，那么线性探测法就是一个较好的办法，然而如果$λ = 0.5$，那么平均插入操作只需要探测2.5次，而对于成功的操作只需要探测1.5次。因此我们在使用线性探测法使应该尽量使填充因子小于0.5！ 平方探测法该方式是消除线性探测法中一次聚集问题的冲突解决办法。平方探测法的冲突函数是二次函数，其较为主流的选择为$$F(i) = i^2$$ 规律：使用平方探测法，当表有一半是空的时，并且表的大小为素数，那么我们总能保证此时可以插入一个新的元素。 在开放定址散列表中，标准的删除操作是无法施行的，因为相应的单元可能已经发生了冲突，其元素已经被挪到了其他位置上了。 优先队列-堆在传统的队列结构Queue中，各个元素都是没有指定的优先级的，都遵循严格的先入先出原则，但是这样的原则并不是永远都是合适的，当我们遇到了CPU处理事件的类似问题时，就会出现优先级的考虑，优先级相对较高的问题应该更快更早被考虑和解决。 因此为了应对这个需求，我们更不应该直接使用线性结构–数组，因为如果使用数组的话最坏情况可能会达到$O(N)$,也就是需要出队的那个元素在最末尾，我们需要多次比较才能找到那个元素！于是我们应该采用二叉堆。 二叉堆二叉堆又有最大堆与最小堆的不同类型。其分别对应了最大优先队列和最小优先队列。 二叉堆是一颗被完全填满的二叉树，但是并不是完全二叉树，它在最底层是有可能存在没有完全放满叶子的情况，因此一颗高度为h的二叉树，它的总结点数应该为：2h到2h+1-1​ 并且如果用数组来存储二叉堆，其根节点与子节点有这样的性质： 如果根节点为i，那么它的左儿子的下标就是2*i+1右儿子的下标就是2*i+2 下标为length/2 -1的堆元素肯定存在有左儿子 二叉堆的构造1234567891011121314151617181920212223242526public static void heapAdjust(int[] arr,int root,int length) { // 以 root节点为根节点，遍历这个长度为length的数组，判断其是否满足大顶堆的要求，而且我们只需要判断根节点和其两个子节点是否满足就好了，其他的事情交给循环来做 //这里放一个length是为了保证访问数组的时候不会越界 int child; // 子节点的值 int father; // 父节点的值 for(father = arr[root];2*root+1 &lt; length;root = child){ //只要它的左儿子是存在的，那么就开始构造/重构堆 child = 2*root+1; // 以root节点为根节点的左子树的下标 // 如果这个根节点的左子树不是这个堆的最后一个元素并且左子树小于右子树。那么就把下标指向右子树 // 因为小的元素要下沉就必须要跟两个子树中较大的那个进行交换，否则如果跟较小的节点进行交换的话可能还需要交换两次！ if (child != length-1 &amp;&amp; arr[child] &lt; arr[child+1]) { child++; } // 如果此时的父节点小于子树中的那个较大者，就与之交换！ if (father &lt; arr[child]) { arr[root] = arr[child]; // 父节点的原有值已经记录在father这个变量内了！ //交换之后还需要接着对这个以儿子节点为根节点的子树进行堆判断，也就是进入下一个循环 }else{ // 说明该节点符合大顶堆的标准，退出for循环 break; } } // 由于当前下标为root的节点值可能是废弃的，即已经被交换过，所以这个节点位置的应有值是该移动节点的值，即最初始的父节点 arr[root] = father; } 二叉堆的插入算法 排序插入排序12345678910111213141516void insertSort(int A[],int length){ // 插入排序的主要思想是排过序的前一部分是永远有序的，只需要将当前元素放置到正确位置就好 int temp = 0; int j = 0; for (int i = 1; i &lt; length; i++)//可以选择直接从第一个元素开始 { temp = A[i]; for (j = i; j &gt; 0 &amp;&amp; A[j-1] &gt; temp; j--)// 第一个j=i的元素是还没有被排序的待排元素！所以要从第i-1个元素开始排序 { A[j] = A[j-1]; } // 退出上一个循环的原因要么是找到了该放的正确位置，要么是到了数组的第一位。 // 但是不管是那种情况，此时j就是正确位置的下标！ A[j] = temp; }} 希尔排序12345678910111213141516171819202122232425void shellSort(int A[],int length){ // int A[5] = {7,6,5,9,3}; int temp = 0; int j = 0; for (int increment = length/2; increment &gt; 0; increment /= 2) { for (int i = increment; i &lt; length; i++) { temp = A[i]; // 从下标为increment 的元素开始，由于每次的间隔已知，且开头已知，那么由后向前找较为的方便 // 确保每个元素在这个增量间隔序列中的位置是正确的！ for (j = i; j &gt;= increment; j -= increment) { if (temp &lt; A[j - increment]) { A[j] = A[j - increment]; }else { break; } } A[j] = temp; } }} 堆排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public static void main(String[] args) { int[] arr = { 50, 10, 90, 30, 70, 40, 80, 60, 20 }; System.out.println(&quot;排序之前：&quot;); for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i] + &quot; &quot;); } // 堆排序 heapSort(arr); System.out.println(); System.out.println(&quot;排序之后：&quot;); for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i] + &quot; &quot;); } } public static void heapSort(int[] arr) { // Create a big top heap for (int i = arr.length/2; i &gt;=0; i--) { heapAdjust(arr, i, arr.length);//从中间到开头的所有元素都进行堆的标准判断，确保生成一个完整的堆 } // 将堆顶最大的那个元素和后面的元素进行交换，然后再生成大顶堆 for (int i = arr.length-1; i &gt;= 0; i--) { // 交换堆顶和队列中最后一个元素的值 exchange(arr, 0, i); // 判断这个队列是否能构成大顶堆不能的话就调整 // 这里调整的实质是：只有堆顶一个元素需要调整，因此只需要将堆顶的元素下沉到相应的位置就好了不需要调整太多元素！！ heapAdjust(arr, 0, i);//只排序前i个元素 } } public static void heapAdjust(int[] arr,int root,int length) { // 以 root节点为根节点，遍历这个长度为length的数组，判断其是否满足大顶堆的要求，而且我们只需要判断根节点和其两个子节点是否满足就好了，其他的事情交给循环来做 //这里放一个length是为了保证访问数组的时候不会越界 int child; // 子节点的值 int father; // 父节点的值 for(father = arr[root];2*root+1 &lt; length;root = child){ //只要它的左儿子是存在的，那么就开始构造/重构堆 child = 2*root+1; // 以root节点为根节点的左子树的下标 // 如果这个根节点的左子树不是这个堆的最后一个元素并且左子树小于右子树。那么就把下标指向右子树 // 因为小的元素要下沉就必须要跟两个子树中较大的那个进行交换，否则如果跟较小的节点进行交换的话可能还需要交换两次！ if (child != length-1 &amp;&amp; arr[child] &lt; arr[child+1]) { child++; } // 如果此时的父节点小于子树中的那个较大者，就与之交换！ if (father &lt; arr[child]) { arr[root] = arr[child]; // 父节点的原有值已经记录在father这个变量内了！ //交换之后还需要接着对这个以儿子节点为根节点的子树进行堆判断，也就是进入下一个循环 }else{ // 说明该节点符合大顶堆的标准，退出for循环 break; } } // 由于当前下标为root的节点值可能是废弃的，即已经被交换过，所以这个节点位置的应有值是该移动节点的值，即最初始的父节点 arr[root] = father; } public static void exchange(int[] arr,int began,int end) { int temp = arr[began]; arr[began] = arr[end]; arr[end] = temp; } 归并排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;stdio.h&gt;#define Max_ 10 // 归并排序中的合并算法void Merge(int array[], int left, int m, int right){ int aux[Max_] = {0}; // 临时数组 （若不使用临时数组，将两个有序数组合并为一个有序数组比较麻烦） int i; //第一个数组索引 int j; //第二个数组索引 int k; //临时数组索引 for (i = left, j = m+1, k = 0; k &lt;= right-left; k++) // 分别将 i, j, k 指向各自数组的首部。 { //若 i 到达第一个数组的尾部，将第二个数组余下元素复制到 临时数组中 if (i == m+1) { aux[k] = array[j++]; continue; } //若 j 到达第二个数组的尾部，将第一个数组余下元素复制到 临时数组中 if (j == right+1) { aux[k] = array[i++]; continue; } //如果第一个数组的当前元素 比 第二个数组的当前元素小，将 第一个数组的当前元素复制到 临时数组中 if (array[i] &lt; array[j]) { aux[k] = array[i++]; } //如果第二个数组的当前元素 比 第一个数组的当前元素小，将 第二个数组的当前元素复制到 临时数组中 else { aux[k] = array[j++]; } } //将有序的临时数组 元素 刷回 被排序的数组 array 中， //i = left , 被排序的数组array 的起始位置 //j = 0， 临时数组的起始位置 for (i = left, j = 0; i &lt;= right; i++, j++) { array[i] = aux[j]; }} // 归并排序void MergeSort(int array[], int start, int end){ // 先拆分，直到拆分到最小部分才结束，也就是只剩下一个元素的时候开始递归返回 // 排序是在合并的时候发生的，通过下标来控制拆分后的元素位置，然后将需要排序的元素输出到临时数组中，最后重新覆盖原始数组中的元素列 if (start &lt; end) { int i; i = (end + start) / 2; // 对前半部分进行排序 MergeSort(array, start, i); // 对后半部分进行排序 MergeSort(array, i + 1, end); // 合并前后两部分 Merge(array, start, i, end); }} int main(){ //测试数据 int arr_test[Max_] = { 8, 4, 2, 3, 5, 1, 6, 9, 0, 7 }; MergeSort( arr_test, 0, Max_-1 ); return 0;} 快速排序快排的核心思想就是哨兵，通过两个pivot来实现将所给的数组中的所有元素排序(大致排序，只按照与标兵的大小比较)，最后哨兵会和的时候就是标兵元素的正确存放地址，此时左边为小于标兵的元素，右边是大于标兵的元素。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;/*****************************************************File name：QuicksortAuthor：Zhengqijun Version:1.0 Date: 2016/11/04Description: 对数组进行快速排序Funcion List: 实现快速排序算法*****************************************************/#define BUF_SIZE 12/************************************************** *函数名：display *作用：打印数组元素 *参数：array - 打印的数组，maxlen - 数组元素个数 *返回值：无 **************************************************/void display(int array[], int maxlen){ int i; for (i = 0; i &lt; maxlen; i++) { printf(&quot;%-3d&quot;, array[i]); } printf(&quot;\\n&quot;); return;}/************************************ *函数名：QuickSort *作用：快速排序算法 *参数： *返回值：无 ************************************/void QuickSort(int *arr, int low, int high){ if (low &lt; high) { int i = low; int j = high; int k = arr[low]; while (i &lt; j) { // 此时的K就是这次快速排序的基准值 // 通过不断地左右探测，找到大于k的放在右边，小于k的放在左边。 // 每次只找到第一个大于或者小于k的数，然后直接交换，再去寻找另一边的元素 while (i &lt; j &amp;&amp; arr[j] &gt;= k) // 从右向左找第一个小于k的数 { j--; } if (i &lt; j)// 确保上面的循环是因为arr[i] &lt; k而退出的也就是找到了第一个小于k的数 { arr[i++] = arr[j];//然后把这个数放入到arr[i]中 } while (i &lt; j &amp;&amp; arr[i] &lt; k) // 从左向右找第一个大于等于k的数 { i++; } if (i &lt; j) { arr[j--] = arr[i]; } }// 当i == j时就是k应该放的位置。 // 此时左边全部都是小于k的元素，因为所有大于k的元素都被交换到当时k所在的位置了，所有大于k的元素都被放到右侧了 arr[i] = k; // 递归调用 QuickSort(arr, low, i ); // 排序k左边。排序当前数组的最低位到i位 QuickSort(arr, i + 1, high); // 排序k右边，排序当前数组i之后的所有元素 }}// 主函数int main(){ int array[BUF_SIZE] = {1,5,2,4,3,4564,2345,11,23,3423,4352,0}; int maxlen = BUF_SIZE; printf(&quot;排序前的数组\\n&quot;); display(array, maxlen); QuickSort(array, 0, maxlen - 1); // 快速排序 printf(&quot;排序后的数组\\n&quot;); display(array, maxlen); return 0;} 桶式排序桶排的原理就是归类！基数排序也是类似的原理。直接将元素放入到以该元素的数值为下标的数组单元中，不过实际操作时数组单元记录的是相同大小元素的个数！而在打印的时候只需要将数组下标打印数组元素值次就好了。 Java实现12345678910111213141516171819202122/** * 桶排序 * * @param A * @return */ public static int[] bucketSort(int[] A, int max) { int[] B = new int[max + 1];// 0-max 总共max+1个数 int[] reArray = new int[A.length]; for (int i = 0; i &lt; A.length; i++) { B[A[i]]++; } int k = 0; for (int i = 0; i &lt; B.length; i++) { for (int j = 1; j &lt;= B[i]; j++) { // i 是被排序的数的大小 B[i] 是大小为i的被排序数的个数 reArray[k] = i; k++; } } return reArray; } C语言实现：123456789101112131415void bucketSort(int A[],int length,int max){ int B[max+1];// 根据A中元素的最大值来确定B的元素个数 memset(B,0,(max+1)*sizeof(int));//使用memset时记得引用string.h头文件 for(int i = 0; i &lt; length;i++){ B[A[i]]++; } int k = 0; for (int i = 0; i &lt; max+1; i++) { for (int j = 1; j &lt;= B[i]; j++) { // i 是被排序的数的大小 B[i] 是大小为i的被排序数的个数 A[k] = i; k++; } }} 外部排序排序分析 图论算法图由顶点和边组成，一个图中也包含很多条边和很多个顶点。 根据边是否有向，可以将图分为有向图与无向图。 图的表示 图有两种表示形式：邻接数组和邻接表。 前者是用二维数组来实现图：1Graph[Vertex1][Vertex2] = weight 其中数组的两个下标为这条边的两个顶点，其中存储的值为这条边的权重 后者是用链表的方式来实现图：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include&lt;string.h&gt;#define MAX 5typedef struct _ENode{ int index; // 该边的顶点的位置 struct _ENode *nextEdge; // 指向下一条弧的指针} ENode, *PENode;// 邻接表中表的顶点typedef struct _VNode{ int index; // 顶点信息 ENode *firstEdge; // 指向第一条依附该顶点的弧} VNode;// 邻接表typedef struct _LGraph{ int vexNum; // 图的顶点的数目 int edgNum; // 图的边的数目 VNode vexs[MAX];} LGraph;// 边的数据typedef struct _EData{ int start; // 起始顶点 int end; // 结束顶点} EData;static EData gData[] = {//硬编码的图的数据 {0, 1}, {0, 3}, {1, 2}, {1, 3}, {2, 5}, {3, 2}, {3, 4}};void LinkToTheEnd(ENode *list, ENode *node){ ENode *p = list; while (p-&gt;nextEdge) { p=p-&gt;nextEdge; } p-&gt;nextEdge = node; }// 创建一张图LGraph *createLinkedGraph(){ ENode *node; LGraph *pG; int start,end; if ((pG = (LGraph *)malloc(sizeof(LGraph))) == NULL) return NULL; memset(pG, 0, sizeof(LGraph)); pG-&gt;vexNum = MAX; pG-&gt;edgNum = 7; for (int i = 0; i &lt; pG-&gt;vexNum; i++) { pG-&gt;vexs[i].index = i; pG-&gt;vexs[i].firstEdge = NULL; } // 初始化&quot;邻接表&quot;的边 for (int i = 0; i &lt; pG-&gt;edgNum; i++) { // 读取边的起始顶点,结束顶点 start = gData[i].start; end = gData[i].end; // 初始化node1 node = (ENode *)malloc(sizeof(ENode)); memset(node,0,sizeof(ENode)); node-&gt;index = end; // 将node1链接到&quot;p1所在链表的末尾&quot; if (pG-&gt;vexs[start].firstEdge == NULL) pG-&gt;vexs[start].firstEdge = node; else LinkToTheEnd(pG-&gt;vexs[start].firstEdge, node); } return pG;}int main(int argc, char const *argv[]){ LGraph *g; g = createLinkedGraph(); return 0;} 拓扑排序拓扑排序的核心还是图的构建以及入度数组的维护。 只要每次都找出入度为0的顶点，然后将其输出，再更新入度数组就可以找出图的拓扑排序方式了！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include&lt;string.h&gt;#define MAX 5typedef struct _ENode{ int index; // 该边的顶点的位置 struct _ENode *nextEdge; // 指向下一条弧的指针} ENode, *PENode;// _ENode 的变量别名// 邻接表中表的顶点typedef struct _VNode{ int index; // 顶点信息 ENode *firstEdge; // 指向第一条依附该顶点的弧} VNode;// 邻接表typedef struct _LGraph{ int vexNum; // 图的顶点的数目 int edgNum; // 图的边的数目 VNode vexs[MAX];} LGraph;// 边的数据typedef struct _EData{ int start; // 起始顶点 int end; // 结束顶点} EData;static EData gData[] = { {0, 1}, {0, 3}, {1, 2}, {1, 3}, {2, 4}, {3, 2}, {3, 4}};void LinkToTheEnd(ENode *list, ENode *node){ ENode *p = list; while (p-&gt;nextEdge) { p=p-&gt;nextEdge; } p-&gt;nextEdge = node; }// 创建一张图LGraph *createLinkedGraph(){ ENode *node; LGraph *pG; int start,end; if ((pG = (LGraph *)malloc(sizeof(LGraph))) == NULL) return NULL; memset(pG, 0, sizeof(LGraph)); pG-&gt;vexNum = MAX; pG-&gt;edgNum = 7; for (int i = 0; i &lt; pG-&gt;vexNum; i++) { pG-&gt;vexs[i].index = i; pG-&gt;vexs[i].firstEdge = NULL; } // 初始化&quot;邻接表&quot;的边 for (int i = 0; i &lt; pG-&gt;edgNum; i++) { // 读取边的起始顶点,结束顶点 start = gData[i].start; end = gData[i].end; // 初始化node1 node = (ENode *)malloc(sizeof(ENode)); memset(node,0,sizeof(ENode)); node-&gt;index = end; // 将node1链接到&quot;p1所在链表的末尾&quot; if (pG-&gt;vexs[start].firstEdge == NULL) pG-&gt;vexs[start].firstEdge = node; else LinkToTheEnd(pG-&gt;vexs[start].firstEdge, node); } return pG;}// 获取图的出度数组void createInDegree(LGraph *g,int InDegree[]){ ENode *p; for (int i = 0; i &lt; g-&gt;vexNum; i++) { p = g-&gt;vexs[i].firstEdge; while (p) { InDegree[p-&gt;index]++; p = p-&gt;nextEdge; } }}// 更新维护入度数组/** * g 图指针 * InDegree 入度数组 * node 需要改变的节点指针 * 删除节点后把它在入度数组中置为-1 * */void updateInDegree(LGraph *g,int InDegree[],int index){ InDegree[index] = -1; ENode *p; p = g-&gt;vexs[index].firstEdge; while (p) { InDegree[p-&gt;index]--; p = p-&gt;nextEdge; }}// TopologicalSort 拓扑排序void TopologicalSort(LGraph *g){ ENode *node; int InDegree[g-&gt;vexNum]; memset(InDegree,0,sizeof(int)*g-&gt;vexNum); createInDegree(g,InDegree); while (1) { int j = -1; for (int i = 0; i &lt; g-&gt;vexNum; i++) { if (InDegree[i] == 0) { j = i; break; } } if (j == -1) { break; } printf(&quot;%d&quot;,j); updateInDegree(g,InDegree,j); }}int main(int argc, char const *argv[]){ LGraph *g; g = createLinkedGraph(); TopologicalSort(g); return 0;} 最短路径图的搜索方法 宽度优先BFS（breath-first-search）–队列实现 逐层遍历 访问节点v，再依次访问和v邻接的节点（或v的下一层节点） 深度优先DFS（depth-first-search）–堆栈实现：递归 先序遍历 访问节点v，对v的邻接节点递归DFS Dijkstra算法求两个顶点间的最短路径，是一种贪婪算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167import java.util.*;public class Dijkstra { //定义顶点Vertex类 static class Vertex{ private final static int infinite_dis = Integer.MAX_VALUE; private String name; //节点名字 private boolean known; //此节点是否已知 private int adjuDist; //此节点距离 private Vertex parent; //当前从初始化节点到此节点的最短路径下的父亲节点 public Vertex(){ this.known = false; this.adjuDist = infinite_dis; this.parent = null; } public Vertex(String name){ this(); this.name = name; } public Vertex getParent(){ return parent; } public void setParent(Vertex parent){ this.parent = parent; } public boolean equals(Object obj){ if (this.getName() == ((Vertex)obj).getName()) { return true; } if(this.name == null){ throw new NullPointerException(&quot;name of Vertex to be compared cannot be null!&quot;); }else{ return false; } } } static class Edge{ //此有向边的起始点 private Vertex startVertex; //此有向边的终点 private Vertex endVertex; //此有向边的权值 private int weight; public Edge(Vertex startVertex,Vertex endVertex,int weight){ this.startVertex = startVertex; this.endVertex = endVertex; this.weight = weight; } } private List&lt;Vertex&gt; vertexList; //图的顶点集 private Map&lt;Vertex,List&lt;Edge&gt; &gt; ver_edgeList_map; //图的每个顶点对应的有向边 public Dijkstra(List&lt;Vertex&gt; vertexList, Map&lt;Vertex, List&lt;Edge&gt;&gt; ver_edgeList_map) { this.vertexList = vertexList; this.ver_edgeList_map = ver_edgeList_map; } public void setRoot(Vertex v){ v.setParent(null); v.setAdjuDist(0); } private void updateChildren(Vertex v){ if (v==null){ return; } if (ver_edgeList_map.get(v)==null || ver_edgeList_map.get(v).size()==0){ return; } List&lt;Vertex&gt; childrenList = new LinkedList&lt;Vertex&gt;(); for (Edge e:ver_edgeList_map.get(v)){ Vertex childVertex = e.getEndVertex(); if (!childVertex.isKnown()){ childVertex.setKnown(true); childVertex.setAdjuDist(v.getAdjuDist()+e.getWeight()); childVertex.setParent(v); childrenList.add(childVertex); } int nowDist = v.getAdjuDist() + e.getWeight(); if (nowDist &gt;= childVertex.getAdjuDist()){ continue; }else { childVertex.setAdjuDist(nowDist); childVertex.setParent(v); } } for (Vertex vc:childrenList){ updateChildren(vc); } } public void dijkstraTravasal(int startIndex,int destIndex){ Vertex start = vertexList.get(startIndex); Vertex dest = vertexList.get(destIndex); String path = &quot;[&quot; + dest.getName() + &quot;]&quot;; setRoot(start); updateChildren(vertexList.get(startIndex)); int shortest_length = dest.getAdjuDist(); while ((dest.getParent()!=null)&amp;&amp;(!dest.equals(start))){ path = &quot;[&quot; + dest.getParent().getName() +&quot;] --&gt; &quot;+path; dest = dest.getParent(); } System.out.println(&quot;[&quot;+vertexList.get(startIndex).getName()+&quot;] to [&quot;+ vertexList.get(destIndex).getName()+&quot;] dijkstra shortest path:: &quot;+path); System.out.println(&quot;shortest length::&quot; + shortest_length); } public static void main(String[] args) { Vertex v1= new Vertex(&quot;v1&quot;); Vertex v2= new Vertex(&quot;v2&quot;); Vertex v3= new Vertex(&quot;v3&quot;); Vertex v4= new Vertex(&quot;v4&quot;); Vertex v5= new Vertex(&quot;v5&quot;); Vertex v6= new Vertex(&quot;v6&quot;); Vertex v7= new Vertex(&quot;v7&quot;); List&lt;Vertex&gt; verList = new LinkedList&lt;Dijkstra.Vertex&gt;(); verList.add(v1); verList.add(v2); verList.add(v3); verList.add(v4); verList.add(v5); verList.add(v6); verList.add(v7); Map&lt;Vertex, List&lt;Edge&gt;&gt; vertex_edgeList_map = new HashMap&lt;Vertex, List&lt;Edge&gt;&gt;(); List&lt;Edge&gt; v1List = new LinkedList&lt;Dijkstra.Edge&gt;(); v1List.add(new Edge(v1,v2,2)); v1List.add(new Edge(v1,v4,1)); List&lt;Edge&gt; v2List = new LinkedList&lt;Dijkstra.Edge&gt;(); v2List.add(new Edge(v2,v4,3)); v2List.add(new Edge(v2,v5,10)); List&lt;Edge&gt; v3List = new LinkedList&lt;Dijkstra.Edge&gt;(); v3List.add(new Edge(v3,v1,4)); v3List.add(new Edge(v3,v6,5)); List&lt;Edge&gt; v4List = new LinkedList&lt;Dijkstra.Edge&gt;(); v4List.add(new Edge(v4,v3,2)); v4List.add(new Edge(v4,v5,2)); v4List.add(new Edge(v4,v6,8)); v4List.add(new Edge(v4,v7,4)); List&lt;Edge&gt; v5List = new LinkedList&lt;Dijkstra.Edge&gt;(); v5List.add(new Edge(v5,v7,6)); List&lt;Edge&gt; v6List = new LinkedList&lt;Dijkstra.Edge&gt;(); List&lt;Edge&gt; v7List = new LinkedList&lt;Dijkstra.Edge&gt;(); v7List.add(new Edge(v7,v6,1)); vertex_edgeList_map.put(v1, v1List); vertex_edgeList_map.put(v2, v2List); vertex_edgeList_map.put(v3, v3List); vertex_edgeList_map.put(v4, v4List); vertex_edgeList_map.put(v5, v5List); vertex_edgeList_map.put(v6, v6List); vertex_edgeList_map.put(v7, v7List); Dijkstra g = new Dijkstra(verList, vertex_edgeList_map); g.dijkstraTravasal(0, 6); }} C语言实现Dijkstra算法：Dijkstra 最小生成树Prim算法求图的最小生成树 Prim算法选取新的一条边的原则是其中一个节点必须在已经选取的节点集合中，而另一个节点必须是为选取的节点。最终选定的边还必须要是全部满足条件的未选取边的权值最小值。也就是说prim算法选取的边必须是连续的，不可能是独立的一条边，因为其中的一个顶点必定是已知的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158public class Prims { private static int INF = Integer.MAX_VALUE; private class ENode { int ivex; // 该边所指向的顶点的位置 int weight; // 该边的权 ENode nextEdge; // 指向下一条弧的指针 } private class VNode { char data; ENode firstEdge; }; private VNode[] mVexs; public Prims(char[] vexs, EData[] edges) { int vlen = vexs.length; int elen = edges.length; mVexs = new VNode[vlen]; for (int i = 0; i &lt; mVexs.length; i++) { mVexs[i] = new VNode(); mVexs[i].data = vexs[i]; mVexs[i].firstEdge = null; } // 初始化&quot;边&quot; for (int i = 0; i &lt; elen; i++) { // 读取边的起始顶点和结束顶点 char c1 = edges[i].start; char c2 = edges[i].end; int weight = edges[i].weight; // 读取边的起始顶点和结束顶点 int p1 = getPosition(c1); int p2 = getPosition(c2); // 初始化node1 ENode node1 = new ENode(); node1.ivex = p2; node1.weight = weight; // 将node1链接到&quot;p1所在链表的末尾&quot; if(mVexs[p1].firstEdge == null) mVexs[p1].firstEdge = node1; else linkLast(mVexs[p1].firstEdge, node1); // 初始化node2 ENode node2 = new ENode(); node2.ivex = p1; node2.weight = weight; // 将node2链接到&quot;p2所在链表的末尾&quot; if(mVexs[p2].firstEdge == null) mVexs[p2].firstEdge = node2; else linkLast(mVexs[p2].firstEdge, node2); } } private void linkLast(ENode list, ENode node) { ENode p = list; while(p.nextEdge!=null) p = p.nextEdge; p.nextEdge = node; } private int getPosition(char ch) { for(int i=0; i&lt;mVexs.length; i++) if(mVexs[i].data==ch) return i; return -1; } private int getWeight(int start, int end) { if (start==end) return 0; ENode node = mVexs[start].firstEdge; while (node!=null) { if (end==node.ivex) return node.weight; node = node.nextEdge; } return INF; } public void prim(int start) { int min,i,j,k,m,n,tmp,sum; int num = mVexs.length; int index=0; // prim最小树的索引，即prims数组的索引 char[] prims = new char[num]; // prim最小树的结果数组 int[] weights = new int[num]; // 顶点间边的权值 prims[index++] = mVexs[start].data; for (i = 0; i &lt; num; i++ ) weights[i] = getWeight(start, i); for (i = 0; i &lt; num; i++) { if(start == i) continue; j = 0; k = 0; min = INF; while (j &lt; num) { if (weights[j] != 0 &amp;&amp; weights[j] &lt; min) { min = weights[j]; k = j; } j++; } prims[index++] = mVexs[k].data; weights[k] = 0; for (j = 0 ; j &lt; num; j++) { tmp = getWeight(k, j); if (weights[j] != 0 &amp;&amp; tmp &lt; weights[j]) weights[j] = tmp; } } sum = 0; for (i = 1; i &lt; index; i++) { min = INF; n = getPosition(prims[i]); for (j = 0; j &lt; i; j++) { m = getPosition(prims[j]); tmp = getWeight(m, n); if (tmp &lt; min) min = tmp; } sum += min; } System.out.printf(&quot;PRIM(%c)=%d: &quot;, mVexs[start].data, sum); for (i = 0; i &lt; index; i++) System.out.printf(&quot;%c &quot;, prims[i]); System.out.printf(&quot;\\n&quot;); } private static class EData { char start; // 边的起点 char end; // 边的终点 int weight; // 边的权重 public EData(char start, char end, int weight) { this.start = start; this.end = end; this.weight = weight; } }; public static void main(String[] args) { char[] vexs = {'A', 'B', 'C', 'D', 'E', 'F', 'G'}; EData[] edges = { new EData('A', 'B', 12), new EData('A', 'F', 16), new EData('A', 'G', 14), new EData('B', 'C', 10), new EData('B', 'F', 7), new EData('C', 'D', 3), new EData('C', 'E', 5), new EData('C', 'F', 6), new EData('D', 'E', 4), new EData('E', 'F', 2), new EData('E', 'G', 8), new EData('F', 'G', 9), }; Prims pG; pG = new Prims(vexs, edges); pG.prim(0); // prim算法生成最小生成树 }} Kruskal算法这个算法也是一个最小生成树算法。不过它与上面的Prim算法有所不同。 Prim算法选取新的一条边的原则是其中一个节点必须在已经选取的节点集合中，而另一个节点必须是为选取的节点。最终选定的边还必须要是全部满足条件的未选取边的权值最小值。也就是说prim算法选取的边必须是连续的，不可能是独立的一条边，因为其中的一个顶点必定是已知的。 Kruskal算法是在所有的边中进行。先排序，找出未加入生成树的最小权值的边，然后判断其是否会与已选取的边构成环，如果不会那么就加入到生成树中。 很显然这个算法也是一个贪婪算法。 算法设计技巧 NP完全问题：NP也就是Non-deterministic Polynomial的缩写，非确定性多项式。 多项式时间指的是是时间复杂度为：$O(N)$ ,$O(\\log(N))$等 非多项式时间是指这类算法的时间复杂度已经超过了计算机能够承受的范围了，例如$O(N!)$一类的时间复杂度。 贪婪算法贪婪算法是将任务分成不同的阶段，在每一个可以快速简单寻找到当前最优解的片段中，取用最优解，然后对每一个片段都重复这个过程，最终得到的就是整个任务的最优解或是次优解。 图例 其中的平均完成时间的定义是：完成该任务的时间节点，而不是完成该任务的时间长度！ 所以10-2为：$$(15+23+26+36)/4 = 25$$10-3为:$$(3+11+21+36)/4 = 17.75$$因此可以表明，不是是用事件单调递减的序列的解决方案必然是次优解，只有那些最小运行时间任务最先安排的解决办法才是最优解。 贪婪算法的应用 寻找图中的最短路径–Dijkstra算法 寻找图的最小生成树–Prim算法 还有就是文件压缩–Huffman编码 Huffman编码 由此可以得到字符编码的前缀码，不过使用前缀码的前提是每个字符编码都不是其他编码的前缀！因此每个字符都要放在树的叶子节点上。 这样做就确保了编码没有二义性。 编码的比特数： 其中深度的数值等于其编码的位数！ Huffman算法算法对一个由树组成的森林进行，该森林中一共有C片叶子，也就是有C个字符需要编码。一棵树的权重等于它的树叶的频率之和。任取最小权重的两棵树$T_1$,$T_2$,并以这两棵树为子树形成新的树，将这样的过程进行C-1次，最终得到的就是Huffman编码的最优树。 为什么需要进行C-1次： ​ 因为森林中最开始有C棵树，也就是一共有C棵只有一个节点的树，每一次选取都会让两棵树合并成一棵树，树的总数减少一，因此从C到1也就需要进行C-1次 示例图： 该算法每一次选取子树都是在当前条件下选取权重最小的子树，因此该算法是贪婪算法。 代码实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdfix.h&gt;/*** * 哈夫曼编码树 * */typedef struct HuffmanTree{ char con[2]; // 节点的内容 int f; //节点的频率 struct HuffmanTree *leftChild; //左儿子 struct HuffmanTree *rightChild; //右儿子} * Node;// 创建一个新的节点Node createNode(char con[], int f, Node left, Node right){ // 先创建一个指针 Node newNode; if ((newNode = (Node)malloc(sizeof(Node))) == NULL) { return NULL; } memset(newNode, 0, sizeof(Node)); // strcpy(newNode-&gt;con,con); if (con) { memcpy(newNode-&gt;con,con,2*sizeof(char)); }else { memset(newNode-&gt;con,0,2*sizeof(char)); } // newNode-&gt;con = con; newNode-&gt;f = f; newNode-&gt;leftChild = left; newNode-&gt;rightChild = right; return newNode;}/** * tree 树的数组 * legth 数组的长度 * */Node huffman(Node tree[], int length){ Node tempNode, node1, node2,parent; //如果这个数组里面只剩下了两个元素，那么就说明已经排序完成了 if (length == 2) { node1 = tree[0]; node2 = tree[1]; parent = createNode(NULL,node1-&gt;f+node2-&gt;f,node1,node2); return parent; } // 给这个节点数组排序，找出频率最小的两个点 int j = 0; for (int i = 0; i &lt; length; i++) { tempNode = tree[i]; for (j = i; j &gt; 0 &amp;&amp; tempNode-&gt;f &lt; tree[j - 1]-&gt;f; j--) { tree[j] = tree[j - 1]; } tree[j] = tempNode; } // 频率最小的两个节点 node1 = tree[0]; node2 = tree[1]; parent = createNode(NULL,node1-&gt;f+node2-&gt;f,node1,node2); // 重新构建一个数组 Node newArray[length-1]; for (int i = 0; i &lt; length - 2; i++) { newArray[i] = tree[i+2]; } newArray[length-2] = parent; parent = huffman(newArray,length-1); return parent;}int main(int argc, char const *argv[]){ Node node_a, node_e, node_i, node_s, node_t, node_sp, node_nl,result; node_a = createNode(&quot;a&quot;, 10, NULL, NULL); node_e = createNode(&quot;e&quot;, 15, NULL, NULL); node_i = createNode(&quot;i&quot;, 12, NULL, NULL); node_s = createNode(&quot;s&quot;, 3, NULL, NULL); node_t = createNode(&quot;t&quot;, 4, NULL, NULL); node_sp = createNode(&quot;sp&quot;, 13, NULL, NULL); node_nl = createNode(&quot;nl&quot;, 1, NULL, NULL); Node nodeArray[] = {node_a, node_e, node_i, node_s, node_t, node_sp, node_nl}; result = huffman(nodeArray, 7); return 0;} 分治算法 分(Divide):递归解决较小的问题，基本情况直接返回就好 治(Conquer):从子问题中重构原问题的解 应用 求解最大子序列的和 归并排序 快速排序 幂运算的快速求解 斐波那契数列的递归求和–性能较差 动态规划动态规划的核心思想是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。 斐波那契数列动态规划123456789101112131415161718192021222324#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int fib(int n){ int f1,f2; f1 = f2 = 1; int result = 1; if (n &lt; 3) { return f1; } for (int i = 2; i &lt; n; i++) { result = f1 + f2; f1 = f2; f2 = result; } return result;}int main(int argc, char const *argv[]){ fib(8); return 0;} 最短编辑距离 在有的文章中，替换的代价是2，而在有的文章中，替换的代价是1，本文按照代价为1的来计算。不过个人认为代价为二更加合理。 动态规划表的初始化 D(0,j)=j，空串和长度为j的Y子串间的最小编辑距离（添加或删除对应的次数） D(i,0)=i，长度为i的X子串和空串间的最小编辑距离添加或删除对应的次数） 而最终的表的结果是： 在三个中取最小值作为矩阵的元素！也就是为了找出变成另一个字符串的最小代价 举例 · s n o w y · 0 1 2 3 4 5 s 1 0 1 2 3 4 u 2 1 1 2 3 4 n 3 2 1 2 3 4 n 4 3 2 2 3 4 y 5 4 3 3 3 3 所以最终的结论是sunny到snowy的最小编辑距离为3 。 · a m e · 0 1 2 3 m 1 1 1 2 e 2 2 2 1 所以最终的结论是me到ame的最小编辑距离为1 。 下面是源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#define min(a, b) (a &lt; b ? a : b)#define MAX 10/** * res 字符1--原始字符串 * des 字符2--目标字符串 * * */int minEditDistance(char *res, char *des){ //首先初始化动态表--填充相对于空字符的编辑距离，也就是字符长度 int dis[MAX][MAX] = {0}; for (int i = 1; i &lt;= (int)strlen(des); i++) { dis[0][i] = i; } for (int j = 1; j &lt;= (int)strlen(res); j++) { dis[j][0] = j; } //循环遍历整个数组，计算每一个编辑距离 for (int i = 1; i &lt;= (int)strlen(res); i++) { for (int j = 1; j &lt;= (int)strlen(des); j++) { // 如果在该位置的两个元素相同，那么到此的最小编辑距离就等同于不包含这两个元素的最小编辑距离 if (res[i-1] == des[j-1]) { dis[i][j] = dis[i-1][j-1]; } else { /** * 相对而言的！向下走的意思就是多出了一个多余元素，在相对于上面那一格的最小编辑距离而言需要将这个多出来的元素删掉 * 同理，向右走就是目标串多了一个元素，要在左侧编辑的基础下再多加一个元素 * 向右下角走也是差不多的道理，既有一个多余元素，而且目标串也多了一个元素，所以要使用替换操作。 * */ int delEd = dis[i][j-1]+1;//往下走就是删除 int insEd = dis[i-1][j]+1;//往右走是插入 int subEd = dis[i-1][j-1]+1;//向右下角走--对角线走就是替换 在这里替换的代价是1 int minEd = min(min(delEd,insEd),subEd); dis[i][j] = minEd; } } } for(int m = 0; m &lt; MAX; m++){ for(int n = 0; n &lt; MAX; n++){ printf(&quot;%d&quot;,dis[m][n]); } printf(&quot;\\n&quot;); } return dis[(int)strlen(res)][(int)strlen(des)];}int main(int argc, char const *argv[]){ printf(&quot;Min Distance of %s to %s is %d \\n&quot;,&quot;sunny&quot;,&quot;snowy&quot;,minEditDistance(&quot;sunny&quot;,&quot;snowy&quot;)); printf(&quot;Min Distance of %s to %s is %d&quot;,&quot;me&quot;,&quot;ame&quot;,minEditDistance(&quot;me&quot;,&quot;ame&quot;)); return 0;}","link":"/2019/11/28/datastruct_review/"},{"title":"汇编-1 寻址方式","text":"寻址方式 汇编进行数据操作运算时第一步是要找到对应的操作数。 操作数分为源操作数与目的操作数，一般来说改变的是目的操作数，源操作数在操作或者运算之后是不会发生变化的 操作数有多个存放地址： 寄存器 主存储器 I/O设备端口处 寄存器寻址顾名思义，就是直接通过寄存器来寻找操作数，操作数存放在寄存器中而不是主存或者端口中 举例：1mov ax,bx 将BX中的内容赋值赋到AX中去，而寻找内容的方式，就是去AX这个CPU自带的通用寄存器EAX中寻找低16位的寄存器AX。 特点:操作数的位数决定了操作的类型，例如，16位的寄存器就代表整个操作是字类型，8位代表字节类型 32位 - 双字 16位 - 字 8位 - 字节 相对其他的寻址方式，寄存器由于是CPU内部的存储单元，所以响应速度更快。 寄存器间接寻址寄存器间接寻址本质上不是去往寄存器里寻找所需要的操作数，而是去主存储器中找对应的操作数！在这种方式里，寄存器相对而言只是一个跳板的作用,提供偏移地址！ 举例：1mov ax,[bx] 内在的逻辑与顺序 读取给定的寄存器的内容 以该内容为偏移地址EA 选取对应的段首 组合之后得到物理地址PA 一些默认规定 除了EBP，BP，ESP三个寄存器默认选取的段寄存器是SS之外，其他的32位/16位寄存器选取的段寄存器都默认位DS 注意：这里的寄存器可以选择任意的32位的寄存器(EDI,ESI,EBP,ESP等等都是可以使用的) 或者是四个十六位存储器：BX,DI,SI,BP(少了一个SP，多了一个BX) 但是不可以选择八位的存储器，因为八位存储器只能存储一个字节的内容，而偏移地址至少需要16位两个字节的内容，所以不能使用。 变址寻址变址寻址所搜寻的操作数存放于主存储器中，而事实上，除了寄存器（直接）寻址以为，介绍的全部的寻址方式均是在主存储器中寻找操作数！ 举例：1格式[R*F+V] V[R*F] [R*F]+V 除了带有运算符的两个数外，其他的运算全部都是加法运算，只要全部加起来就好了。 其中F 为比例因子，R为寄存器， V为偏移量。而整个运算操作的对象是R寄存器中的内容！！ 寄存器中的内容读取并不需要通过段地址：偏移地址的方式，因为寄存器的地址都早已经被读取入计算机，因此相对而言速度更快！ 1mov al,[ebx*2+4] 内在逻辑与顺序 读取出ebx中的内容 运算整个表达式ebx*2+4 以这个表达式为偏移地址，选取对应的段地址生成物理地址 注意： 当选取的运算的寄存器是EBP或者16位寄存器时，比例因子F只能为1，并且缩略不写 V偏移量不能过长，否则会被截断 关于偏移量： 由于在内存中默认的单元是字而不是字节！因此一般而言需要跳转到下一个单元时需要改变两个字节，而不是一个字节，当有相对应的操作时也应该乘以二！ 基址加变址寻址相当于上面的变址寻址多了一个基址罢了 举例：格式：V[BR][IR*F] V[IR*F+BR]1mov al,4[ebx*2+ecx] 原理：将变址寄存器IR的内容乘以比例因子F，再与基址寄存器BR的内容还有偏移量V相加，得到的结果作为整个的偏移地址。然后再根据基址寄存器寻找默认的段寄存器。 注意：当使用的基址寄存器为BX或者BP中的一个时，IR只能选择SI或者DI，而且根据变址寻址的规则，当选用16位的寄存器时，比例系数只能为1！ 默认段寄存器的选用： BX - DS BP - SS ESP,EBP - SS 其他的32位寄存器全部使用DS作为默认的段寄存器 立即寻址实际上立即寻址并不用到任何一个主存储器或者寄存器，因为它的操作数已经直接被读入到操作码中，这应该是最快的操作方式？ 举例：1mov word ptr [si],12H 其中的12H就是立即数，它会直接赋值给以si寄存器的内容为偏移地址的内存块（这里的目的操作数使用的是寄存器间接寻址） 注意： 其中有一块代码是word ptr是为了指定操作数的类型为字类型，也就是有两个字节，两块内存单元，即以[SI]为首地址向下寻找一个字单元，然后放入对应的立即数！ 操作的时候会将12H翻译成0012H以适应字类型的操作要求，这里的翻译原因就是前面的word ptr，当使用的是byte ptr时就不会翻译了 其中当遇到负数时会有翻译成补码的要求，而实际上所有的立即数的操作都是以补码的形式进行的，只不过无符号数和正数的补码与原码相同罢了！ 直接寻址这个直接寻址有点类似于上面的寄存器间接寻址，只不过把寄存器的内容换成了立即数，相当于：立即数（间接）寻址。 举例：1mov ds:[20H],cl 相当于把立即数当作偏移地址，然后去指定的段寄存器中寻找需要的操作数。这里的操作数是存放于主存储器中！ 注意：当使用直接寻址给内存单元赋值/运算的时候需要指定操作类型。 1sub word ptr ds:[1000H],55AAH 这里就是指定了为偏移地址为1000H，段寄存器为DS的那个内存单元进行减法操作，操作类型（或者说是范围）是字类型，也就是操作对象是两个字节！ 总结分类而已上六种寻址方式可以分为三大类：寄存器方式，存储器方式以及立即数方式。 寄存器：寄存器寻址 存储器方式： 寄存器间接寻址 变址寻址 基址加变址寻址 直接寻址 立即数方式：立即寻址 操作数来源双操作数的指令中的目的操作数与源操作数的类型必须是以下几种： 寄存器对寄存器 寄存器对存储器 存储器对寄存器 立即方式对寄存器–立即方式只能用于源操作数 立即方式对存储器–立即方式只能用于源操作数 其中绝对不能两个操作数均来自存储器！ 操作数类型不确定类型的操作数： 寄存器间接寻址 立即数 直接寻址 一些规定： 两个操作数至少要有一个操作数的类型是明确的 如果两个操作数的类型都是明确的，那么两个操作数的类型必须都要相同（均是字类型，或者均是字节类型等等） 如果都不明确那么必须要指定一个操作数的类型！","link":"/2019/11/16/assembly_1/"},{"title":"汇编-2 宏汇编语言","text":"宏汇编语言常量与数值表达式常量使用EQU或者=定义常量 确定的数值，主要用于在伪代码中给标量赋初值，或者用作立即寻址中的立即数，还有位移量，比例因子等等作用 数值表达式数值表达式的最终结果实际上是与常量一样的，因为数值表达式在汇编的过程中就被计算完成了，被替换成了常量 算术操作 加减乘除 取余，取模 左移右移 逻辑操作 逻辑乘法 逻辑加法 按位加法 非运算 关系操作 关系操作后的结果是两个特殊的值 True ：0FFFFH False : 0H 变量，标号与地址表达式变量变量是编程时定义在程序中的数据存储单元的名字 变量与常量不同，常量相对而言只是立即数的一个替代品，或者本来就是立即数，常量是没有属性的，而变量有三个属性： 段属性 偏移地址属性 类型属性 变量是通过伪代码来定义的，在定义变量的时候还必须要指明变量的类型属性 1DB--BYTE,DW--WORD,DD--DOUBLE WORDS,DF--THREE WORDS,DQ--FOUR WORDS,DT--TEN BYTES 而变量还可以被定义为多种类型 数值表达式 ASCII字符串–只有使用DB定义变量类型的时候字符串的长度才可以超过两个字节，因此定义字符串一般都是使用DB类型 地址表达式 ？–表示所定义的变量还无法确定初值 重复的子句 1使用了 n DUP(表达式) ;整个语句的作用就是把表达式的内容重复n遍 还可以是多种不同类型组成的序列 标号标号是机器指令语句存放地址的符号表示，也可以是子程序名。 标号也有三种属性： 段属性–标号所在段的段地址–相对于所属段寄存器的偏移地址 偏移地址–标号所在段的段首址到该标号所代表的存储单元的字节距离 标号的类型–NEAR类型与FAR类型 NEAR类型表示该标号只能在定义该标号的段内被使用 FAR无限制 定义方式123456Loop: mov al,[si]subs proc farsubs endpsub2 proc ;默认没有定义类型的话就是为near类型sub2 endp 地址表达式地址表达式其实是对地址进行运算，转移等，而不是类似于数值表达式直接变为一个常数 寻址方式均是地址表达式： 寄存器寻址 寄存器间接寻址 变址寻址 基址加变址寻址 立即寻址 直接寻址 如果地址表达式中出现了变量和标号，那么是取它们的偏移地址来进行运算而不是用内容进行运算！ 1.属性定义算符 类型运算符 PTR 定义类型运算符 THIS 2.属性分离算符 取段址算符 SEG 取偏移地址算符 OFFSET 取类型算符 TYPE,这个运算符返回的是一个值，即操作数的类型的字节数，如果是标号，那么就返回0FFFFH 3.其他算符 获取存储单元个数运算符 LENGTH 获取变量所含数据存储空间大小运算符 SIZE=&gt;(LENGTH 变量)*(TYPE 变量) 字符分离运算符 HIGH LOW 常用机器指令语句机器指令大全","link":"/2019/11/16/assembly_2/"},{"title":"汇编程序设计","text":"完成汇编程序设计课设要求 程序开始有个选项栏，里面有2个选项： 1、输入成绩，以图5.20的形式输入最多N个同学的学号、分数、名次信息，N可以在程序中预定义，输入过程中如果超过这个N，出现超标提示停止输入（上交作业时可预先定义N为10,即最多只能输入10个人的成绩），按回车健停止输入成绩，回到选项栏。 2、查询成绩：按学号查询成绩，显示格式按书中定义；按回车健停止查询成绩，回到选项栏。无论输入成绩或查询成绩过程中，键入‘Q’退出整个程序。 程序设计结构 宏汇编： 12345678910111213141516171819202122print_char macro X mov ah,2 mov dl,X int 21H endm ;结束（end）宏定义（macro）;字符串输出print_string macro X lea dx,X mov ah,9 int 21H endm;字符输入 将字符的ASCII码送入AL中去getinput_char macro mov ah,1 int 21H endm;字符串输入 将字符串送入一个缓冲区中getinput_string macro X lea dx,X mov ah,10 int 21H endm 数据段设计： 123456789101112131415161718192021222324252627data segment use16 ENGLI db 80 dup(20H) ; 3*N个空间，用于存放学号成绩和排名（此处N=10） db 20H ; ENGLI db 20H,31H,20H,33H,39H,20H,38H,20H,31H,33H,20H,35H,37H,20H,36H ; db 80 dup(20H) ; 3*N个空间，用于存放学号成绩和排名（此处N=10） ; db 20H SEARCH_BUF db 30 dup(0) MENU db 13,10 db '*~*~*~*~*~MENU*~*~*~*~*~*~*~*~*~*~*~*~*',13,10 db '@ 1.INPUT @',13,10 db '@ 2.FIND @',13,10 db '@-------------------------------------@',13,10 db '@ Q.QUIT @',13,10 db '*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*',13,10 db 'PLEASE INPUT YOUR CHOICE:$' INPUTNOTICE db 13,10 db 'PLEASE INPUT THE SCORE:',13,10,'$' IDSCORERANK db 'ID SCORE RANK',13,10,'$' FINDNOTICE db 13,10 db 'PLEASE INPUTU THE ID YOU ARE SEARCHING FOR:$' NOTFINDNOTICE db 13,10 db 'THE DATA YOU ARE FINDING ARE NOT EXIST !$' OUTOFBUF db 13,10 db 'THE MAX OF INPUT WAS 10 PEOPLE!!$'data ends 程序段设计（code segment）： 程序初始化 12345start: mov ax,data mov ds,ax mov bx,1 lea di,SEARCH_BUF ; 输入字符的起始地址 菜单显示： 1234menuloop: call showmenu call menuchoice jmp menuloop 退出程序： 123exit: mov ax,4C00H int 21H 输入成绩子程序部分： 123456789101112131415161718192021222324252627282930313233343536373839inputscore proc near mov bx,1 mov cx,0 mov dl,0 print_string INPUTNOTICE print_string IDSCORERANKinputloop: getinput_char cmp al,'q' ; 按下Q退出 je exit cmp al,'Q' je exit cmp al,13 je menuloop cmp al,20H je inputloop_inc mov [bx],al inc bx jmp inputloopinputloop_inc: inc cx mov [bx],al inc bx cmp cx,29 jae inputloop_output jmp inputloopinputloop_output: print_string OUTOFBUF getinput_char cmp al,0DH je menuloop retinputscore endp 成绩查询子程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103; 按学号查找记录子程序findpeople proc near mov bx,1 ; 存储字符的定位指针 mov si,0 ; 输入字符的计数器 print_string FINDNOTICE jmp findloop notfind: print_string NOTFINDNOTICE getinput_char jmp menuloopinc_part: inc bx inc cx cmp cx,4 jae search_complete jb print_dataprint_data: ; mov cx,0 ; 空格计数器，当到达第三个空格时停止输出 print_char [bx] mov dl,20H cmp [bx],dl je inc_part inc bx jmp print_dataoutput: dec bx mov dl,20H ; 让bx自减到上一个为空格的地方 cmp [bx],dl ; 若为空格则开始输出 je print_data jmp outputfindnext_inc: inc cx inc bx jmp findnextfindnext: lea di,SEARCH_BUF cmp cx,3 je checkloop mov dl,20H cmp [bx],dl je findnext_inc inc bx jmp findnextcheckloop_pre: mov dl,20H mov [di],dl lea di,SEARCH_BUF ; 输入字符的起始地址 ; dec di jmp checkloopcheckloop: mov cx,0 mov dh,[di] cmp [bx],dh ; 比较存储的输入字符和数据段的字符 jne findnext ; 若不相等则去寻找下一个学号 mov dl,20H ; 判断是否是空格 cmp [bx],dl je output mov dl,0DH ; 判断是否是回车 cmp [bx],dl je output inc bx inc di cmp bx,50H jb checkloop ; 继续循环的条件是这个单元格里的字符既不是回车也不是空格，并且两个字符相同 jmp notfindfindloop: ; 用两个指针记住查询时输入的查询数据，再进行不断比较 mov cx,0 getinput_char cmp al,'q' ; 按下Q退出 je exit cmp al,'Q' je exit cmp al,20H je checkloop_pre cmp al,0DH je checkloop_pre mov [di],al inc di inc si ; inc bx ; cmp bx,82 jmp findloop retfindpeople endp 输入缓冲区清零子程序： 123456789101112131415161718192021222324search_complete proc near lea di,SEARCH_BUF clearloop: mov dl,00H mov [di],dl inc di cmp di,70H jae complete jmp clearloopcomplete: lea di,SEARCH_BUF getinput_char cmp al,0DH je menuloop cmp al,'q' ; 按下Q退出 je exit cmp al,'Q' je exit retsearch_complete endp 程序运行截图： 初始化界面： 输入程序界面： 每个部分用空格隔开，可以连续输入十个人的学号，成绩，排名 查询成绩界面： 输入学号，查询该同学的成绩排名！ [源代码地址][1]","link":"/2019/10/20/%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"title":"江滩秘境","text":"哈，暑假终于是要结束了。 明天室友就要回来了，在这里一个人住了这么多天，除了电费有点糟心，以及睡觉的时候要自己关灯，其他都还不错，畅想了一下日后的独居生活？ 前两天去探索了武汉第三个（？）江滩，汉阳江滩？应该叫这个名字吧。晴川阁不用收门票，但是人还是很少，或许是因为人太少了所以不用收门票吧。 晴川历历汉阳树，芳草萋萋鹦鹉洲崔颢 禹王庙 江滩景色 然后沿着龟山旁边的一条小路走到了汉阳造，路上皆是墙绘涂鸦，像是古板的武汉江城背上的一笔纹身。 Poker 海绵宝宝 暑假很多事情都只完成了一半。 书没怎么看，课程也没有去预习，学车也没有学完，墙纸也没贴好，摄影也没认真搞明白。 害，真的没那么简单。 夏天也快过去了。","link":"/2019/08/29/%E6%B1%9F%E6%BB%A9%E7%A7%98%E5%A2%83/"},{"title":"漫长的告别","text":"A guy like me has one big moment in his life , one perfect swing on the high trapeze.Then he spends the rest of his time trying not to fall off the sidewalk into the gutter. 今天是8月24号，距离我开博客已经有一个月的时间了。 期间我写了十七篇，有发泄的，有想着口嗨的，也有认真总结写影评的。不知道有多少人在看，或许来来回回只有我一个人吧。 害，多大点事呢。 现在的生活从某种状态来讲还挺好的，虽然不知道好在哪里，未来难期。 总是害怕说出自己期待的东西，担心还没触碰就堪堪消失。 买了三四本书，这么多天了，一本都没有看完，倒是最便宜的那本不要钱的《漫长的告别》看的最快，挺喜欢马洛这个角色，不卑不亢，冷静沉着。总之，在潮湿的破败别墅里，外面的天是阴霾的，落魄的英国绅士倚在发旧的沙发上思索案件的走向，对我有种神秘的吸引力，难道侦探小说不就应该这样吗？ 好了，明天也没什么行程，祝安。","link":"/2019/08/23/%E6%BC%AB%E9%95%BF%E7%9A%84%E5%91%8A%E5%88%AB/"},{"title":"暑假倒计时-48Hours","text":"马上就要回去了。 本来还要去帮我妈把钱存了，但是外面下雨了，不是很想要出门，夏天的温州有点湿热，但也并不难受，如果硬要和武汉的夏天相比较的话。 欸，其实立秋都过了好久。 武汉的夏天至少还有一个月的余额，而我的暑假时长却早早告急了。 谷歌的实习岗位好酷炫，但是翻了一下他们的招聘目标，好像并没有对大二的弱鸡男大学生开放.... 希望明年这个时候能有机会去大公司找点实习吧...虽然现在还是一条咸鱼，没有什么一技之长。 这两天临近开学，莫名其妙的沉迷购置用具，艹，又想买台灯了，米家Pro真尼玛好看，那个充电的也是...回武汉后还准备把武汉的几个没去过的景点都去一遍，顺便给博客加一个画册页面好了，不知道服务器这么点大的内存够不够使... 好好学车 好好睡觉 好好“钓鱼” 新学期冲冲冲！！！","link":"/2019/08/15/%E6%9A%91%E5%81%87%E5%80%92%E8%AE%A1%E6%97%B6-48hours/"},{"title":"算法分析入门系列(一) 排序算法","text":"排序算法main函数代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public static void main(String[] args) { int max = 10; System.out.println(&quot;插入排序-------------------------------------&quot;); int[] num = randomCreate(max); printResult(num); Long bt = System.nanoTime(); int[] temp1 = insertSort(num); Long et = System.nanoTime(); System.out.println(&quot;排序用时：&quot; + (et - bt + &quot;&quot;)); printResult(temp1); System.out.println(&quot;合并排序-------------------------------------&quot;); int[] temp4 = randomCreate(max); printResult(temp4); Long bt2 = System.nanoTime(); mergeSort(temp4); Long et2 = System.nanoTime(); System.out.println(&quot;排序用时：&quot; + (et2 - bt2 + &quot;&quot;)); printResult(temp4); System.out.println(&quot;快速排序-------------------------------------&quot;); int[] temp5 = randomCreate(max); printResult(temp5); Long bt3 = System.nanoTime(); quickSort(temp5, 0, temp5.length - 1, false); Long et3 = System.nanoTime(); System.out.println(&quot;排序用时：&quot; + (et3 - bt3 + &quot;&quot;)); printResult(temp5); System.out.println(&quot;随机化快速排序--------------------------------&quot;); int[] temp9 = randomCreate(max); printResult(temp9); Long bt7 = System.nanoTime(); quickSort(temp9, 0, temp9.length - 1, true); Long et7 = System.nanoTime(); System.out.println(&quot;排序用时：&quot; + (et2 - bt2 + &quot;&quot;)); printResult(temp9); System.out.println(&quot;桶排序---------------------------------------&quot;); int[] temp6 = randomCreate(max); printResult(temp6); Long bt4 = System.nanoTime(); temp6 = bucketSort(temp6, max); Long et4 = System.nanoTime(); System.out.println(&quot;排序用时：&quot; + (et4 - bt4 + &quot;&quot;)); printResult(temp6); System.out.println(&quot;计数排序-------------------------------------&quot;); int[] temp7 = randomCreate(max); printResult(temp7); Long bt5 = System.nanoTime(); temp7 = countSort(temp7); Long et5 = System.nanoTime(); System.out.println(&quot;排序用时：&quot; + (et5 - bt5 + &quot;&quot;)); printResult(temp7); System.out.println(&quot;基数排序-------------------------------------&quot;); int[] temp8 = randomCreate(max); printResult(temp8); Long bt6 = System.nanoTime(); radixSort(temp8, (max + &quot;&quot;).length()); Long et6 = System.nanoTime(); System.out.println(&quot;排序用时：&quot; + (et6 - bt6 + &quot;&quot;)); printResult(temp8); System.out.println(&quot;---------------------------------------------&quot;);} 各个排序的源代码：插入排序：123456789101112131415161718192021222324252627/** * 插入排序 * * @param A * @return */public static int[] insertSort(int[] A) { int temp = 0; for (int i = 1; i &lt; A.length; i++) { /** * 将当前的数存储起来用来在0-i+1的区间内进行排序 */ temp = A[i]; for (int j = i; j &gt; 0; j--) { if (temp &lt; A[j - 1]) { A[j] = A[j - 1]; } else { A[j] = temp; break; } if (j - 1 == 0) { A[0] = temp; } } } return A;} 合并排序：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 合并排序 * * @param original */ private static void mergeSort(int[] original) { if (original == null) { throw new NullPointerException(&quot;The array can not be null !!!&quot;); } int length = original.length; if (length &gt; 1) { int middle = length / 2; int partitionA[] = Arrays.copyOfRange(original, 0, middle);// 拆分问题规模 int partitionB[] = Arrays.copyOfRange(original, middle, length); // 递归调用 mergeSort(partitionA); mergeSort(partitionB); sort(partitionA, partitionB, original); } } private static void sort(int[] partitionA, int[] partitionB, int[] original) { int i = 0; int j = 0; int k = 0; while (i &lt; partitionA.length &amp;&amp; j &lt; partitionB.length) { if (partitionA[i] &lt;= partitionB[j]) { original[k] = partitionA[i]; i++; } else { original[k] = partitionB[j]; j++; } k++; } if (i == partitionA.length) { while (k &lt; original.length) { original[k] = partitionB[j]; k++; j++; } } else if (j == partitionB.length) { while (k &lt; original.length) { original[k] = partitionA[i]; k++; i++; } } } 快速排序与随机快速排序：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 快速排序 * @param arr 数组 * @param low 最低位 * @param high 最高位 * @param random 是否随机化 */public static void quickSort(int[] arr, int low, int high, boolean random) { int i, j, temp, t; if (low &gt; high) { return; } i = low; j = high; // 以第一位为分割中心 if (!random) { temp = arr[low]; } else { int index = (int) Math.random() * high; temp = arr[index]; arr[index] = arr[low]; arr[low] = temp; } while (i &lt; j) { //先看右边，依次往左递减 while (temp &lt;= arr[j] &amp;&amp; i &lt; j) { j--; } //再看左边，依次往右递增 while (temp &gt;= arr[i] &amp;&amp; i &lt; j) { i++; } //如果满足条件则交换 if (i &lt; j) { t = arr[j]; arr[j] = arr[i]; arr[i] = t; } } //最后将基准为与i和j相等位置的数字交换 arr[low] = arr[i]; arr[i] = temp; //递归调用左半数组 quickSort(arr, low, j - 1, random); //递归调用右半数组 quickSort(arr, j + 1, high, random); } 桶排序：1234567891011121314151617181920212223/** * 桶排序 * * @param A * @return */ public static int[] bucketSort(int[] A, int max) { int[] B = new int[max + 1];// 0-max 总共max+1个数 int[] reArray = new int[A.length]; for (int i = 0; i &lt; A.length; i++) { B[A[i]]++; } int k = 0; for (int i = 0; i &lt; B.length; i++) { for (int j = 1; j &lt;= B[i]; j++) { // i 是被排序的数的大小 B[i] 是大小为i的被排序数的个数 reArray[k] = i; k++; } } return reArray; } 计数排序12345678910111213141516171819202122232425262728293031323334/** * 计数排序 * * @param array */ public static int[] countSort(int[] array) { // 首先为所有元素申请足够大的空间 int max = array[0]; int min = array[0]; for (int i = 0; i &lt; array.length; i++) { if (max &lt; array[i]) max = array[i]; if (min &gt; array[i]) min = array[i]; } int maxLength = max - min + 1; int[] timesAndPosition = new int[maxLength]; int[] finalArray = new int[array.length]; for (int i = 0; i &lt; array.length; i++) { timesAndPosition[array[i] - min] += 1; } for (int i = 1; i &lt; maxLength; i++) { timesAndPosition[i] += timesAndPosition[i - 1]; } for (int i = 0; i &lt; array.length; i++) { try { int tempIndex = array[i] - min; finalArray[timesAndPosition[tempIndex] - 1] = array[i]; timesAndPosition[tempIndex]--; } catch (Exception e) { e.printStackTrace(); } } return finalArray; } 基数排序1234567891011121314151617181920212223242526272829303132333435363738/** * 基数排序 * * @param array 待排序的数组 * @param max 数组中最大数的位数 */ public static void radixSort(int[] array, int max) { List&lt;Integer&gt;[] temp = new List[10]; for (int i = 0; i &lt; temp.length; i++) { temp[i] = new ArrayList&lt;&gt;(); } for (int k = 1; k &lt;= max; k++) { for (int i = 0; i &lt; temp.length; i++) { temp[i] = new ArrayList&lt;&gt;(); } for (int i = 0; i &lt; array.length; i++) { temp[getFigure(array[i], k)].add(array[i]); } int j = 0; for (int i = 0; i &lt; temp.length; i++) { for (int t : temp[i]) { array[j] = t; j++; } } } } /** * 获取整型数的第k位的数字 * * @param num 数字 * @param k 第k位 * @return */ public static int getFigure(int num, int k) { // 先除以10的k-1次方，将需要获取的那位数移动到最后一位上，然后和10取余数，得到该位数 return (num / ((int) Math.pow(10, k - 1))) % 10; } 随机数生成函数与打印函数：12345678910111213141516171819202122232425/** * 随机数生成函数 * * @param num * @return */ public static int[] randomCreate(int num) { int[] array = new int[num]; for (int i = 0; i &lt; num; i++) { array[i] = (int) (Math.random() * num); } return array; }/** * 循环打印结果 * * @param arr */ public static void printResult(int[] arr) { for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i]); System.out.print(&quot; &quot;); } System.out.println(); } 实验结果 单位：ns 实验过程使用上文中的随机数生成函数生成1000个随机数字，然后再运行对应的排序算法，计时器使用的是Java原生的System.nanoTime(); 思考题 算法科学解决问题的一般模式是什么？ 用自然语言的方式描述问题 抽象问题的共性，分析问题的特性 选用或者创建合适的数据结构模型 编写算法 确定性算法和随机性算法的差异在那里？随机化对于算法效率的影响如何？ 确定性算法对于随机情况是不稳定的，而随机性算法对于一般的随机情况而言更加的适用。当遇上极端情况时确定性算法就有可能不再适用而随机算法的随机化过程能较大程度的减少极端情况的影响。 能够普遍地提高算法的效率。如在随机化快速排序中，通过基准节点的随机化选择，就能较好的避免已经排好序/逆序的情况下的低效率。 如何理解算法效率分析的渐近特征和相对性？ 因为算法每次面对的信息量都不相同，所以就不能用一个准确的值去描述算法的绝对效率，于是就应该选择相对的N，也就是每个元操作（此处是我给出的概念，也就是抽象认知下不可分割的最小操作节点），单次元操作记作1，所有元操作的和最大值就是该算法的上界。 同样的，因为数据量的不尽相同，所以最终的效率只能逼近靠近理论的算法效率，也就是渐近特征","link":"/2020/04/15/algorithmanalysis_1/"},{"title":"算法分析入门系列(三) 动态规划算法","text":"作业排程问题问题描述 Automobile factory with two assembly lines(汽车厂两条装配线) – Each line has n stations: S1,1, . . . , S1,n and S2,1, . . . , S2,n(每条装 配线有n个工序站台) – Corresponding stations S1, j and S2, j perform the same function but can take different amounts of time a1, j and a2, j (每条装配线的 第j个站台的功能相同,但是效率不一致) – Entry times e1 and e2 and exit times x1 and x2(上线和下线时间) 描述并实现动态规划的作业排程算法，并显示下图的排程结果。 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.List;/** * OperationSequencing * 作业排程算法实现 *//** * int arrayA[2][5] = { 7,9,3,4,8,8,5,6,4,5 }; int arrayT[2][4] = { * 2,3,1,3,2,1,2,2 }; */public class OperationSequencing { public static List&lt;Route&gt; routes = new ArrayList&lt;&gt;(); public void addToRoutes(Node node, Integer costTime) { boolean flag = false; for (Route route : routes) { if (route.getWorkIndex() == node.getWorkIndex() &amp;&amp; costTime &lt; route.getCostTime()) { route.setLineIndex(node.getLineIndex()); route.setCostTime(costTime); flag = true; } else if (route.getWorkIndex() == node.getWorkIndex()) { flag = true; } } if (!flag) { routes.add(new Route(node.getLineIndex(), node.getWorkIndex(), costTime)); } } public void printRoutes() { Collections.sort(routes, new Comparator&lt;Route&gt;() { @Override public int compare(Route r1, Route r2) { return r1.getWorkIndex() - r2.getWorkIndex(); } }); System.out.print(&quot;enter--&gt;&quot;); for (Route route : routes) { System.out.print(&quot;(&quot; + route.getLineIndex() + &quot;,&quot; + route.getWorkIndex() + &quot;)--&gt;&quot;); } System.out.print(&quot;exit&quot;); } public Integer getShortestTime(WorkingGraph workingGraph, Node endNode) { WorkingGraph _workingGraph = new WorkingGraph(workingGraph); if (endNode.getParents().size() == 1) { return Edge.getEdgeWeight(_workingGraph.getEnterNode(), endNode, _workingGraph.getEdges()) + endNode.getWorkTime(); } Integer leftParentTime = Edge.getEdgeWeight(endNode.getParents().get(0), endNode, _workingGraph.getEdges()); Integer rightParentTime = Edge.getEdgeWeight(endNode.getParents().get(1), endNode, _workingGraph.getEdges()); // 去掉与末尾节点相关的边 Edge.removeEdgeWithNode(endNode, _workingGraph.getEdges()); _workingGraph.getNodes().remove(endNode); Integer leftTime = getShortestTime(_workingGraph, endNode.getParents().get(0)) + leftParentTime; Integer rightTime = getShortestTime(_workingGraph, endNode.getParents().get(1)) + rightParentTime; addToRoutes(endNode.getParents().get(leftTime &gt; rightTime ? 1 : 0), leftTime &gt; rightTime ? rightTime : leftTime); return Math.min(leftTime, rightTime) + endNode.getWorkTime(); } public static void main(String[] args) { WorkingGraph workingGraph = new WorkingGraph(); // -1-1代表起始节点，-2-2代表离开节点 Node enter = new Node(-1, -1, 0); Node exit = new Node(-2, -2, 0); Node a11 = new Node(1, 1, 7); Node a12 = new Node(1, 2, 9); Node a13 = new Node(1, 3, 3); Node a14 = new Node(1, 4, 4); Node a15 = new Node(1, 5, 8); Node a21 = new Node(2, 1, 8); Node a22 = new Node(2, 2, 5); Node a23 = new Node(2, 3, 6); Node a24 = new Node(2, 4, 4); Node a25 = new Node(2, 5, 5); enter.addToChildren(a11); enter.addToChildren(a21); a11.addToParents(enter); a11.addToChildren(a12); a11.addToChildren(a22); a21.addToParents(enter); a21.addToChildren(a12); a21.addToChildren(a22); a12.addToParents(a11); a12.addToParents(a21); a12.addToChildren(a13); a12.addToChildren(a23); a22.addToParents(a11); a22.addToParents(a21); a22.addToChildren(a13); a22.addToChildren(a23); a13.addToParents(a12); a13.addToParents(a22); a13.addToChildren(a14); a13.addToChildren(a24); a23.addToParents(a12); a23.addToParents(a22); a23.addToChildren(a14); a23.addToChildren(a24); a14.addToParents(a13); a14.addToParents(a23); a14.addToChildren(a15); a14.addToChildren(a25); a24.addToParents(a13); a24.addToParents(a23); a24.addToChildren(a15); a24.addToChildren(a25); a15.addToParents(a14); a15.addToParents(a24); a15.addToChildren(exit); a25.addToParents(a14); a25.addToParents(a24); a25.addToChildren(exit); exit.addToParents(a15); exit.addToParents(a25); List&lt;Node&gt; nodes = new ArrayList&lt;&gt;(); nodes.add(enter); nodes.add(a11); nodes.add(a12); nodes.add(a13); nodes.add(a14); nodes.add(a15); nodes.add(a21); nodes.add(a22); nodes.add(a23); nodes.add(a24); nodes.add(a25); nodes.add(exit); List&lt;Edge&gt; edges = new ArrayList&lt;&gt;(); edges.add(new Edge(enter, a11, 2)); edges.add(new Edge(a11, a12, 0)); edges.add(new Edge(a12, a13, 0)); edges.add(new Edge(a13, a14, 0)); edges.add(new Edge(a14, a15, 0)); edges.add(new Edge(a15, exit, 3)); edges.add(new Edge(enter, a21, 4)); edges.add(new Edge(a21, a22, 0)); edges.add(new Edge(a22, a23, 0)); edges.add(new Edge(a23, a24, 0)); edges.add(new Edge(a24, a25, 0)); edges.add(new Edge(a25, exit, 6)); edges.add(new Edge(a11, a22, 2)); edges.add(new Edge(a21, a12, 2)); edges.add(new Edge(a12, a23, 3)); edges.add(new Edge(a22, a13, 1)); edges.add(new Edge(a13, a24, 1)); edges.add(new Edge(a23, a14, 2)); edges.add(new Edge(a14, a25, 3)); edges.add(new Edge(a24, a15, 2)); workingGraph.setNodes(nodes); workingGraph.setEdges(edges); workingGraph.setEnterNode(enter); workingGraph.setExitNode(exit); OperationSequencing operationSequencing = new OperationSequencing(); System.out.println(operationSequencing.getShortestTime(workingGraph, exit)); operationSequencing.printRoutes(); }}/** * 图上的节点类 */class Node { // 父节点 private List&lt;Node&gt; parents; // 子节点 private List&lt;Node&gt; children; // 流水线编号 private Integer lineIndex; // 工作顺序编号 private Integer workIndex; // 加工时间 private Integer workTime; public Node() { } public Node(Integer lineIndex, Integer workIndex, Integer workTime) { this.children = new ArrayList&lt;&gt;(); this.parents = new ArrayList&lt;&gt;(); this.lineIndex = lineIndex; this.workIndex = workIndex; this.workTime = workTime; } public List&lt;Node&gt; getParents() { return parents; } public void setParents(List&lt;Node&gt; parents) { this.parents = parents; } public void addToParents(Node parent) { this.parents.add(parent); } public List&lt;Node&gt; getChildren() { return children; } public void setChildren(List&lt;Node&gt; children) { this.children = children; } public void addToChildren(Node child) { this.children.add(child); } public Integer getLineIndex() { return lineIndex; } public void setLineIndex(Integer lineIndex) { this.lineIndex = lineIndex; } public Integer getWorkIndex() { return workIndex; } public void setWorkIndex(Integer workIndex) { this.workIndex = workIndex; } public Integer getWorkTime() { return workTime; } public void setWorkTime(Integer workTime) { this.workTime = workTime; }}/** * 边类 */class Edge { // 起始节点 private Node startNode; // 结束节点 private Node endNode; // 边的权重 private Integer weight; public Edge() { } public Edge(Node startNode, Node endNode, Integer weight) { this.startNode = startNode; this.endNode = endNode; this.weight = weight; } /** * 获取两个顶点之间的直线距离 * * @param n1 起始节点 * @param n2 结束节点 * @param edges * @return */ public static Integer getEdgeWeight(Node n1, Node n2, List&lt;Edge&gt; edges) { for (Edge edge : edges) { if (edge.getStartNode().equals(n1) &amp;&amp; edge.getEndNode().equals(n2)) return edge.weight; } return 0; } /** * 移除与指定节点相关的边 * * @param Node * @param edges */ public static void removeEdgeWithNode(Node Node, List&lt;Edge&gt; edges) { List&lt;Edge&gt; _removeEdges = new ArrayList&lt;&gt;(); for (Edge edge : edges) { if (edge.getStartNode().equals(Node) || edge.getEndNode().equals(Node)) { _removeEdges.add(edge); } } for (Edge edge : _removeEdges) { edges.remove(edge); } } public Node getStartNode() { return startNode; } public void setStartNode(Node startNode) { this.startNode = startNode; } public Node getEndNode() { return endNode; } public void setEndNode(Node endNode) { this.endNode = endNode; } public Integer getWeight() { return weight; } public void setWeight(Integer weight) { this.weight = weight; }}class Route { private Integer lineIndex; private Integer workIndex; private Integer costTime; public Integer getLineIndex() { return lineIndex; } public void setLineIndex(Integer lineIndex) { this.lineIndex = lineIndex; } public Integer getWorkIndex() { return workIndex; } public void setWorkIndex(Integer workIndex) { this.workIndex = workIndex; } public Integer getCostTime() { return costTime; } public void setCostTime(Integer costTime) { this.costTime = costTime; } public Route(Integer lineIndex, Integer workIndex, Integer costTime) { this.lineIndex = lineIndex; this.workIndex = workIndex; this.costTime = costTime; }}/** * 工作图类 */class WorkingGraph implements Cloneable { private List&lt;Node&gt; nodes; private List&lt;Edge&gt; edges; private Node enterNode; private Node exitNode; public WorkingGraph() { } public WorkingGraph(WorkingGraph workingGraph) { this.nodes = new ArrayList&lt;&gt;(workingGraph.getNodes()); this.edges = new ArrayList&lt;&gt;(workingGraph.getEdges()); this.enterNode = workingGraph.getEnterNode(); this.exitNode = workingGraph.getExitNode(); } @Override public WorkingGraph clone() { WorkingGraph o = null; try { o = (WorkingGraph) super.clone(); } catch (CloneNotSupportedException e) { e.printStackTrace(); } return o; } public List&lt;Node&gt; getNodes() { return nodes; } public void setNodes(List&lt;Node&gt; nodes) { this.nodes = nodes; } public List&lt;Edge&gt; getEdges() { return edges; } public void setEdges(List&lt;Edge&gt; edges) { this.edges = edges; } public Node getEnterNode() { return enterNode; } public void setEnterNode(Node enterNode) { this.enterNode = enterNode; } public Node getExitNode() { return exitNode; } public void setExitNode(Node exitNode) { this.exitNode = exitNode; }} 实验分析使用动态规划的思想，从上至下，从出口到入口。我这里还用了贪婪的策略，只需要保证每一次都是最短的工作耗时即可。 最长子序列问题问题描述 描述并实现最长共同子序列动态规 划 算 法 ， 并 显 示 S1= ACCGGTCGAGATGCAG，S2 = GTCGTTCGGAATGCAT *的最长共同子序列。 * 共同子序列可以是不连续的，且每个元素在母串中的位置也是可以不相同，但是顺序必须一致 源代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import java.util.ArrayList;import java.util.List;/** * MaxSubsequence *//** * 描述并实现最长共同子序列动态规 划 算 法 ， 并 显 示 S1= ACCGGTCGAGATGCAG，S2 = GTCGTTCGGAATGCAT * 的最长共同子序列。 共同子序列可以是不连续的，且每个元素在母串中的位置也是可以不相同，但是顺序必须一致 */public class MaxSubsequence { /** * 求解最长子序列 * * @param str1 字符串1 * @param str2 字符串2 * @return */ public static String lcs(String str1, String str2) { int len1 = str1.length(); int len2 = str2.length(); StringBuffer sb = new StringBuffer(); int c[][] = new int[len1 + 1][len2 + 1]; for (int i = 0; i &lt;= len1; i++) { for (int j = 0; j &lt;= len2; j++) { if (i == 0 || j == 0) { c[i][j] = 0; } else if (str1.charAt(i - 1) == str2.charAt(j - 1)) { c[i][j] = c[i - 1][j - 1] + 1; } else { c[i][j] = Math.max(c[i - 1][j], c[i][j - 1]); } } } for (int m = 0; m &lt; Math.max(len1, len2); m++) { for (int n = 0; n &lt; Math.max(len1, len2); n++) { System.out.print(c[m][n] + &quot;\\t&quot;); } System.out.println(); } int m = len1; int n = len2; while (c[m][n] &gt; 0) { if (str1.charAt(m - 1) == str2.charAt(n - 1)) { sb.append(str1.charAt(m - 1)); m--; n--; } else if (c[m][n] == c[m][n - 1]) { n--; } else if (c[m][n] == c[m - 1][n]) { m--; } } return sb.reverse().toString(); } /** * 生成最长子序列的字符串 * * @param arr 比较矩阵 * @param str1 字符串1 * @param str2 字符串2 */ public void generateLcs(int[][] arr, String str1, String str2) { int m = arr.length - 1; int n = arr[0].length - 1; StringBuffer sb = new StringBuffer(); while (arr[m][n] &gt; 0) { if (str1.charAt(m) == str2.charAt(n)) { sb.append(str1.charAt(m)); m--; n--; } else if (arr[m][n] == arr[m][n - 1]) { n--; } else if (arr[m][n] == arr[m - 1][n]) { m--; } } System.out.println(sb.reverse().toString()); } public static void main(String[] args) { MaxSubsequence maxSubsequence = new MaxSubsequence(); String ms = maxSubsequence.lcs(&quot;ACCGGTCGAGATGCAG&quot;, &quot;GTCGTTCGGAATGCAT&quot;); System.out.println(ms); }} 实验结果生成的子序列矩阵 查找到的最长子序列 实验分析实现最长子序列的关键在于创建最长子序列矩阵，这里是使用二维数组来实现的，每一个点都与其上方，左边，左上方这三个点相关，是在判断对应字符相等于否的基础上，根据这几个点来确定当前点的值。当到达最右下角的点时，也就是点dist[dist.length-1][dist.lenght-1]时，也就得到了最长共同子序列的长度，然后再使用逆向思维获取最终的序列。 并且最长子序列并不是唯一的，可能有多个值，这取决于你选择的打印方式。 思考题 动态规划算法范式是什么？ 动态规划与分治法相似，但是动态规划所划分的子问题并不是完全相互独立的，是有可能相互关联的，如果使用分治法来实现就有可能重复处理子问题，造成资源浪费。 动态规划需要将问题分为子问题，前一个子问题为后一个子问题提供信息，并且每一次求解时需要存储之前的结果，以期得到最佳答案。 利用动态规划算法设计方法解决矩阵链相乘问题？ 矩阵链相乘问题在于寻找最好的括号加法，对于$A_{i~j}(使用该符号来代表矩阵A_iA_{i+1}..*A_j的最佳值)$可以选取一个数k,其中$i≤k≤j$成立,并且k是i到j中的最佳分割点，即括号的所在处，那么我们的乘法矩阵m[][]就可以表示为： 123456if(i==j){ m[i][i] = 0;}else{ m[i][j]=min{m[i][k] + m[k+1][j] + Pi-1PkPj}} 然后使用自底向上的思想就可以计算出最佳括号加法获得问题的解","link":"/2020/04/15/alogrithmanalysis_3/"},{"title":"算法分析入门系列(四) 最短路径算法","text":"单源最短路径算法 问题描述从s点出发到达其他点的最短路径 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219import java.util.*;public class ShortestPath { // 定义顶点Vertex类 static class Vertex { private final static int infinite_dis = Integer.MAX_VALUE; private String name; // 节点名字 private boolean known; // 此节点是否已知 private int adjuDist; // 此节点距离 private Vertex parent; // 当前从初始化节点到此节点的最短路径下的父亲节点 public Vertex() { this.known = false; this.adjuDist = infinite_dis; this.parent = null; } public Vertex(String name) { this(); this.name = name; } public Vertex getParent() { return parent; } public void setParent(Vertex parent) { this.parent = parent; } public boolean equals(Object obj) { if (this.getName() == ((Vertex) obj).getName()) { return true; } if (this.name == null) { throw new NullPointerException(&quot;name of Vertex to be compared cannot be null!&quot;); } else { return false; } } public static int getInfiniteDis() { return infinite_dis; } public String getName() { return name; } public void setName(String name) { this.name = name; } public boolean isKnown() { return known; } public void setKnown(boolean known) { this.known = known; } public int getAdjuDist() { return adjuDist; } public void setAdjuDist(int adjuDist) { this.adjuDist = adjuDist; } } static class Edge { // 此有向边的起始点 private Vertex startVertex; // 此有向边的终点 private Vertex endVertex; // 此有向边的权值 private int weight; public Edge(Vertex startVertex, Vertex endVertex, int weight) { this.startVertex = startVertex; this.endVertex = endVertex; this.weight = weight; } public Vertex getStartVertex() { return startVertex; } public void setStartVertex(Vertex startVertex) { this.startVertex = startVertex; } public Vertex getEndVertex() { return endVertex; } public void setEndVertex(Vertex endVertex) { this.endVertex = endVertex; } public int getWeight() { return weight; } public void setWeight(int weight) { this.weight = weight; } } private List&lt;Vertex&gt; vertexList; // 图的顶点集 private Map&lt;Vertex, List&lt;Edge&gt;&gt; ver_edgeList_map; // 图的每个顶点对应的有向边 public ShortestPath(List&lt;Vertex&gt; vertexList, Map&lt;Vertex, List&lt;Edge&gt;&gt; ver_edgeList_map) { this.vertexList = vertexList; this.ver_edgeList_map = ver_edgeList_map; } public void setRoot(Vertex v) { v.setParent(null); v.setAdjuDist(0); } private void updateChildren(Vertex v) { if (v == null) { return; } if (ver_edgeList_map.get(v) == null || ver_edgeList_map.get(v).size() == 0) { return; } List&lt;Vertex&gt; childrenList = new LinkedList&lt;Vertex&gt;(); for (Edge e : ver_edgeList_map.get(v)) { Vertex childVertex = e.getEndVertex(); if (!childVertex.isKnown()) { childVertex.setKnown(true); childVertex.setAdjuDist(v.getAdjuDist() + e.getWeight()); childVertex.setParent(v); childrenList.add(childVertex); } int nowDist = v.getAdjuDist() + e.getWeight(); if (nowDist &gt;= childVertex.getAdjuDist()) { continue; } else { childVertex.setAdjuDist(nowDist); childVertex.setParent(v); } } for (Vertex vc : childrenList) { updateChildren(vc); } } public void shortestPathTravasal(int startIndex, int destIndex) { Vertex start = vertexList.get(startIndex); Vertex dest = vertexList.get(destIndex); String path = &quot;[&quot; + dest.getName() + &quot;]&quot;; setRoot(start); updateChildren(vertexList.get(startIndex)); int shortest_length = dest.getAdjuDist(); while ((dest.getParent() != null) &amp;&amp; (!dest.equals(start))) { path = &quot;[&quot; + dest.getParent().getName() + &quot;] --&gt; &quot; + path; dest = dest.getParent(); } System.out.println(&quot;[&quot; + vertexList.get(startIndex).getName() + &quot;] to [&quot; + vertexList.get(destIndex).getName() + &quot;] ShortestPath shortest path: &quot; + path); System.out.println(&quot;shortest length:&quot; + shortest_length); } public static void main(String[] args) { Vertex s = new Vertex(&quot;s&quot;); Vertex t = new Vertex(&quot;t&quot;); Vertex x = new Vertex(&quot;x&quot;); Vertex y = new Vertex(&quot;y&quot;); Vertex z = new Vertex(&quot;z&quot;); List&lt;Vertex&gt; verList = new LinkedList&lt;ShortestPath.Vertex&gt;(); verList.add(s); verList.add(t); verList.add(x); verList.add(y); verList.add(z); Map&lt;Vertex, List&lt;Edge&gt;&gt; vertex_edgeList_map = new HashMap&lt;Vertex, List&lt;Edge&gt;&gt;(); List&lt;Edge&gt; sList = new LinkedList&lt;ShortestPath.Edge&gt;(); sList.add(new Edge(s, t, 6)); sList.add(new Edge(s, y, 7)); List&lt;Edge&gt; tList = new LinkedList&lt;ShortestPath.Edge&gt;(); tList.add(new Edge(t, y, 8)); tList.add(new Edge(t, x, 5)); List&lt;Edge&gt; xList = new LinkedList&lt;ShortestPath.Edge&gt;(); xList.add(new Edge(x, t, -2)); List&lt;Edge&gt; yList = new LinkedList&lt;ShortestPath.Edge&gt;(); yList.add(new Edge(y, x, -3)); yList.add(new Edge(y, z, 9)); List&lt;Edge&gt; zList = new LinkedList&lt;ShortestPath.Edge&gt;(); zList.add(new Edge(z, x, 7)); vertex_edgeList_map.put(s, sList); vertex_edgeList_map.put(t, tList); vertex_edgeList_map.put(x, xList); vertex_edgeList_map.put(y, yList); vertex_edgeList_map.put(z, zList); ShortestPath g = new ShortestPath(verList, vertex_edgeList_map); g.shortestPathTravasal(0, 1); g.shortestPathTravasal(0, 2); g.shortestPathTravasal(0, 3); g.shortestPathTravasal(0, 4); }} 实验结果 全点对最短路径 问题描述单点到另外一个点的最短距离 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104import java.util.ArrayList;import java.util.List;/** * 全点对最短路径算法 */public class FullPointPairShortestPath { public static void main(String[] args) { List&lt;InnerEdge&gt; innerEdges = new ArrayList&lt;&gt;(); innerEdges.add(new InnerEdge(1, 2, 3)); innerEdges.add(new InnerEdge(1, 3, 8)); innerEdges.add(new InnerEdge(1, 5, -4)); innerEdges.add(new InnerEdge(2, 5, 7)); innerEdges.add(new InnerEdge(2, 4, 1)); innerEdges.add(new InnerEdge(3, 2, 4)); innerEdges.add(new InnerEdge(4, 1, 2)); innerEdges.add(new InnerEdge(4, 3, -5)); innerEdges.add(new InnerEdge(5, 4, 6)); int[][] dist = new int[5][5]; for (int i = 0; i &lt; dist.length; i++) { for (int j = 0; j &lt; dist[i].length; j++) { if (i == j) { dist[i][j] = 0; continue; } dist[i][j] = Integer.MAX_VALUE / 3; } } for (InnerEdge innerEdge : innerEdges) { dist[innerEdge.getStartIndex() - 1][innerEdge.getEndIndex() - 1] = innerEdge.getWeight(); } getFullPointPairShortestPath(dist); } public static void getFullPointPairShortestPath(int[][] dist) { for (int k = 0; k &lt; dist.length; k++) { for (int i = 0; i &lt; dist.length; i++) { for (int j = 0; j &lt; dist.length; j++) { if (dist[i][j] &gt; dist[i][k] + dist[k][j]) { dist[i][j] = dist[i][k] + dist[k][j]; } } } } System.out.print(&quot;\\t&quot;); for (int i = 0; i &lt; dist.length; i++) { System.out.print(i + 1 + &quot;\\t&quot;); } System.out.println(); for (int i = 0; i &lt; dist.length; i++) { System.out.print(i + 1 + &quot;\\t&quot;); for (int j = 0; j &lt; dist.length; j++) { System.out.print(dist[i][j] + &quot;\\t&quot;); } System.out.println(); } }}/** * InnerEdge */class InnerEdge { private Integer startIndex; private Integer endIndex; private Integer weight; public InnerEdge() { } public Integer getStartIndex() { return startIndex; } public void setStartIndex(Integer startIndex) { this.startIndex = startIndex; } public Integer getEndIndex() { return endIndex; } public void setEndIndex(Integer endIndex) { this.endIndex = endIndex; } public Integer getWeight() { return weight; } public void setWeight(Integer weight) { this.weight = weight; } public InnerEdge(Integer startIndex, Integer endIndex, Integer weight) { this.startIndex = startIndex; this.endIndex = endIndex; this.weight = weight; }} 实验结果 思考题 全点对最短路径算法动态规划算法范式 寻找两点间的最佳中转点 图的存储方式和运算效率之间的关系 使用数组来存储更加高效，使用Java对象来存储更加清晰明了","link":"/2020/04/15/alogrithmanalysis_4/"},{"title":"算法分析入门系列(二) 分治算法","text":"Strassen矩阵算法矩阵分割将 $$N*N$$ 的矩阵转成 $$\\frac{N}{2}*\\frac{N}{2}$$ 的矩阵，在这个相乘的过程中我们发现一共有四次加法，八次乘法。 而后就可以获得这个算法的递推公式：$$T(N) = 8*T(\\frac{N}{2}) + Θ(N^2)$$ 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178/** * StrassenMatrix */public class StrassenMatrix { public void printMatrix(Matrix matrix, int n) { for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { System.out.print(matrix.matrix[i][j] + &quot; &quot;); } System.out.println(); } } /** * 矩阵分割 * * @param M * @param M11 * @param M12 * @param M21 * @param M22 * @param n */ public void Divide(Matrix M, Matrix M11, Matrix M12, Matrix M21, Matrix M22, int n) { /** * 遍历整个M矩阵，将M的不同区域分割给不同的四个矩阵 通过一个常数n来划分，每个矩阵的数之间都隔了n，所以 不会有重复出现 */ for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { M11.matrix[i][j] = M.matrix[i][j]; M12.matrix[i][j] = M.matrix[i][j + n]; M21.matrix[i][j] = M.matrix[i + n][j]; M22.matrix[i][j] = M.matrix[i + n][j + n]; } } } /*** * 矩阵合并 * * @param M * @param M11 * @param M12 * @param M21 * @param M22 * @return */ public Matrix MergeMatrix(Matrix M11, Matrix M12, Matrix M21, Matrix M22, int n) { Matrix _return = new Matrix(); for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { _return.matrix[i][j] = M11.matrix[i][j]; _return.matrix[i][j + n] = M12.matrix[i][j]; _return.matrix[i + n][j] = M21.matrix[i][j]; _return.matrix[i + n][j + n] = M22.matrix[i][j]; } } return _return; } /** * 阶数为2的矩阵乘法--Strassen法 * * @param x * @param y * @return */ public Matrix MatrixMultiplication(Matrix x, Matrix y) { int M1, M2, M3, M4, M5, M6, M7; M1 = x.matrix[0][0] * (y.matrix[0][1] - y.matrix[1][1]); M2 = y.matrix[1][1] * (x.matrix[0][0] + x.matrix[0][1]); M3 = y.matrix[0][0] * (x.matrix[1][0] + x.matrix[1][1]); M4 = x.matrix[1][1] * (y.matrix[1][0] - y.matrix[0][0]); M5 = (x.matrix[0][0] * y.matrix[0][0] + x.matrix[0][0] * y.matrix[1][1]) + (x.matrix[1][1] * y.matrix[0][0] + x.matrix[1][1] * y.matrix[1][1]); M6 = (x.matrix[0][1] * y.matrix[1][0] + x.matrix[0][1] * y.matrix[1][1]) - (x.matrix[1][1] * y.matrix[1][0] + x.matrix[1][1] * y.matrix[1][1]); M7 = (x.matrix[0][0] * y.matrix[0][0] + x.matrix[0][0] * y.matrix[0][1]) - (x.matrix[1][0] * y.matrix[0][0] + x.matrix[1][0] * y.matrix[0][1]); Matrix _return = new Matrix(); _return.matrix[0][0] = M5 + M4 - M2 + M6; _return.matrix[1][0] = M1 + M2; _return.matrix[0][1] = M3 + M4; _return.matrix[1][1] = M5 + M1 - M3 - M7; return _return; } /** * 矩阵乘法，阶数大于2 * * @param x * @param y * @param n * @return */ public Matrix MatrixMultiplication(Matrix x, Matrix y, int n) { Matrix A11 = new Matrix(); Matrix A12 = new Matrix(); Matrix A21 = new Matrix(); Matrix A22 = new Matrix(); Matrix B11 = new Matrix(); Matrix B12 = new Matrix(); Matrix B21 = new Matrix(); Matrix B22 = new Matrix(); Matrix C11 = new Matrix(); Matrix C12 = new Matrix(); Matrix C21 = new Matrix(); Matrix C22 = new Matrix(); Matrix M1, M2, M3, M4, M5, M6, M7; if (n == 2) { return MatrixMultiplication(x, y); } else { Matrix C = null; Divide(x, A11, A12, A21, A22, n / 2); Divide(y, B11, B12, B21, B22, n / 2); // Divide(C, C11, C12, C21, C22, n / 2); n /= 2; M1 = MatrixMultiplication(A11, MatrixModified(B12, B22, n, false), n); M2 = MatrixMultiplication(MatrixModified(A11, A12, n, true), B22, n); M3 = MatrixMultiplication(MatrixModified(A21, A22, n, true), B11, n); M4 = MatrixMultiplication(A22, MatrixModified(B21, B11, n, false), n); M5 = MatrixMultiplication(MatrixModified(A11, A22, n, true), MatrixModified(B11, B22, n, true), n); M6 = MatrixMultiplication(MatrixModified(A12, A22, n, false), MatrixModified(B21, B22, n, true), n); M7 = MatrixMultiplication(MatrixModified(A11, A21, n, false), MatrixModified(B11, B12, n, true), n); C11 = MatrixModified(MatrixModified(M5, M4, n, true), MatrixModified(M2, M6, n, false), n, false); C12 = MatrixModified(M1, M2, n, true); C21 = MatrixModified(M3, M4, n, true); C22 = MatrixModified(MatrixModified(M5, M1, n, true), MatrixModified(M3, M7, n, true), n, false); C = MergeMatrix(C11, C12, C21, C22, n); return C; } } /** * 矩阵加减法 * * @param x * @param y * @return */ public Matrix MatrixModified(Matrix x, Matrix y, int n, Boolean isPlus) { Matrix _return = new Matrix(); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) if (isPlus) { _return.matrix[i][j] = x.matrix[i][j] + y.matrix[i][j]; } else { _return.matrix[i][j] = x.matrix[i][j] - y.matrix[i][j]; } return _return; } public static void main(String[] args) { StrassenMatrix strassenMatrix = new StrassenMatrix(); // int[][] M_X = { { 1, 1 }, { 1, 1 } }; // int[][] M_Y = { { 1, 1 }, { 1, 1 } }; int[][] M_X = { { 1, 1, 1, 1, 1, 1, 1, 1 }, { 1, 1, 1, 1, 1, 1, 1, 1 }, { 1, 1, 1, 1, 1, 1, 1, 1 }, { 1, 1, 1, 1, 1, 1, 1, 1 }, { 1, 1, 1, 1, 1, 1, 1, 1 }, { 1, 1, 1, 1, 1, 1, 1, 1 }, { 1, 1, 1, 1, 1, 1, 1, 1 }, { 1, 1, 1, 1, 1, 1, 1, 1 } }; int[][] M_Y = { { 1, 1, 1, 1, 1, 1, 1, 1 }, { 1, 1, 1, 1, 1, 1, 1, 1 }, { 1, 1, 1, 1, 1, 1, 1, 1 }, { 1, 1, 1, 1, 1, 1, 1, 1 }, { 1, 1, 1, 1, 1, 1, 1, 1 }, { 1, 1, 1, 1, 1, 1, 1, 1 }, { 1, 1, 1, 1, 1, 1, 1, 1 }, { 1, 1, 1, 1, 1, 1, 1, 1 } }; Matrix x = new Matrix(); Matrix y = new Matrix(); x.matrix = M_X; y.matrix = M_Y; Matrix result = strassenMatrix.MatrixMultiplication(x, y, 8); strassenMatrix.printMatrix(result, 8); }}class Matrix { public int[][] matrix = new int[32][32]; public Matrix() { }} 实验数据两个$8*8$的单位矩阵相乘 12345678910int[][] M_X = { { 1, 1, 1, 1, 1, 1, 1, 1 }, { 1, 1, 1, 1, 1, 1, 1, 1 }, { 1, 1, 1, 1, 1, 1, 1, 1 }, { 1, 1, 1, 1, 1, 1, 1, 1 }, { 1, 1, 1, 1, 1, 1, 1, 1 }, { 1, 1, 1, 1, 1, 1, 1, 1 }, { 1, 1, 1, 1, 1, 1, 1, 1 }, { 1, 1, 1, 1, 1, 1, 1, 1 } }; 实验分析原始算法中矩阵乘法的时间复杂度为$O(n^3)$,而在Strassen算法中降低到$O(n^{\\log_2^7})$。 因为在普通的矩阵乘法中，需要进行8次阶数减半的子矩阵递归相乘，再加上矩阵相加与合并的时间，就会使得简单的矩阵乘法变得极为缓慢，而最主要的时间是用在8次矩阵相乘。$$T(N) = 8*T(\\frac{N}{2}) + Θ(N^2)$$Strassen算法最主要的贡献就是将8次矩阵乘法减少到了7次，使得整个算法的复杂度有所降低。 实验结果 最近点对算法问题描述求出平面中所有点对里欧几里得距离最短的点对。 欧几里得距离：$$h = \\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$$ 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.List;/** * NearestDots 最近点对算法 */public class NearestDots { /** * generate random dots * * @param num * @return */ public List&lt;Dot&gt; generateDots(int num) { List&lt;Dot&gt; dots = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; num; i++) { Dot dot = new Dot(Math.random() * (num + 2), Math.random() * (num + 5)); dots.add(dot); } return dots; } /** * get distance between tow dots * * @param dot1 * @param dot2 * @return */ public double getDistance(Dot dot1, Dot dot2) { return (double) Math.sqrt(Math.pow(dot1.getX() - dot2.getX(), 2.0) + Math.pow(dot1.getY() - dot2.getY(), 2.0)); } /** * divide a dot list into a half length list as well as it's sorted bt dot.x * * @param dots * @param isLeft * @return */ public List&lt;Dot&gt; getDividePart(List&lt;Dot&gt; dots, boolean isLeft) { List&lt;Dot&gt; _return = new ArrayList&lt;&gt;(); if (isLeft) { for (int i = 0; i &lt; dots.size() / 2; i++) { _return.add(dots.get(i)); } } else { for (int i = dots.size() / 2; i &lt; dots.size(); i++) { _return.add(dots.get(i)); } } return _return; } /** * get the min distance violently * * @param dots * @return */ public double violentResolver(List&lt;Dot&gt; dots) { double minDistance = Double.MAX_VALUE; for (Dot dot1 : dots) { for (Dot dot2 : dots) { if (dot1.equals(dot2)) { continue; } double distance = getDistance(dot1, dot2); if (distance &lt; minDistance) { minDistance = distance; } } } return minDistance; } /** * get min distance by dividing * * @param dots * @return */ public double divideResolver(List&lt;Dot&gt; dots) { double minDistance = Double.MAX_VALUE; int midIndex = dots.size() / 2; // End condition of Recursion if (dots.size() == 2) { return getDistance(dots.get(0), dots.get(1)); } else if (dots.size() == 3) { double d1 = getDistance(dots.get(0), dots.get(1)); double d2 = getDistance(dots.get(0), dots.get(2)); double d3 = getDistance(dots.get(1), dots.get(2)); return Math.min(d1, Math.min(d2, d3)); } Collections.sort(dots, new Comparator&lt;Dot&gt;() { @Override public int compare(Dot d1, Dot d2) { if (d1.getX() &lt; d2.getX()) { return -1; } else if (d1.getX() &gt; d2.getX()) { return 1; } return 0; } }); List&lt;Dot&gt; leftUnion = getDividePart(dots, true); List&lt;Dot&gt; rightUnion = getDividePart(dots, false); minDistance = Math.min(divideResolver(leftUnion), divideResolver(rightUnion)); Dot midDot = dots.get(midIndex); for (int i = midIndex - 4 &gt; 0 ? midIndex - 4 : 0; i &lt; (midIndex + 3 &gt; dots.size() ? dots.size() : midIndex + 3) &amp;&amp; i != midIndex; i++) { minDistance = Math.min(getDistance(midDot, dots.get(i)), minDistance); } return minDistance; } public static void main(String[] args) { NearestDots nearestDots = new NearestDots(); int num = 10; List&lt;Dot&gt; dots = nearestDots.generateDots(num); double min = nearestDots.violentResolver(dots); double min2 = nearestDots.divideResolver(dots); System.out.println(min); System.out.println(min2); } /** * 点的数据结构 */ public class Dot { private double x; private double y; public Dot(double x, double y) { this.x = x; this.y = y; } public double getX() { return x; } public void setX(double x) { this.x = x; } public double getY() { return y; } public void setY(double y) { this.y = y; } }} 实验分析该算法主要是使用了分治递归的思想，难点在于处理两段分划合并时的情况。 合并的情况此时左侧导出的点对是所有点对中距离最短的点对，右边的点对也是，接下来需要判断靠近分割线的两个点是也是最短的点对，如果是，那么这个点对就是该段合并后的点中最短距离的点对！ 合并中还会出现极端情况，也就是有点在分界线上，所以我们应该人为规定在分界线上的点应该归属为左半边还是右半边。 而后我们可以根据上面这个图得出：在分界线$x=x_i$处，周围最多有七个点有可能比分治时的最小值要小，因此只需要在合并时比较这几个点之间的距离就可以了。 实验结果 思考题 分治法算法设计思想的三个基本步骤是什么？如何证明分治算法的正确性？ 问题划分 递归求解 合并子问题的解 使用数学归纳法来证明算法的正确性 利用主方式求解 Strassen’s 矩阵乘法和最近点对算法效率的递归分析结果。 Strassen’s算法$$Strassen’s算法: T(n) = 7T(\\frac{n}{2}) + Θ(n^2)$$根据主方式得出$f(n) = Θ(n^{\\log_2{7-3}})$所以其时间复杂度就是$$T(n) = \\Theta(n^{\\log_27})$$*最近点对算法**$$T(n)=2*T(\\frac{n}{2})+\\Theta(n)$$根据主方式得出$f(n) = \\Theta(n)$所以其时间复杂度就是$$T(n)=\\Theta(n\\log{n})$$ 解释怎样修改 Strassen’s 矩阵乘法算法，使得它也可以用于大小不必为 2 的幂的矩阵？ 对半分割矩阵，只要能求解最小单元矩阵就能实现","link":"/2020/04/15/algorithmanalysis_1-1/"},{"title":"线性回归的简洁实现","text":"线性回归个人理解是通过建立反馈机制,逐层优化筛选最优的权重参数,以达到对最佳算法的逼近.也就是通过数值解逼近解析解. 预测二手房价格设房屋的面积为$x_1$，房龄为$x_2$，售出价格为$y$。我们需要建立基于输入$x_1$和$x_2$来计算输出$y$的表达式，也就是模型（model）。顾名思义，线性回归假设输出与各个输入之间是线性关系： $$\\hat{y} = x_1 w_1 + x_2 w_2 + b$$很明显我们能看到这是一个线性表达式，其中有两个参数会影响最终的输出结果，我们要做的事情就是找出最佳的$w_1$与$w_2$来实现对$y$的预测! 训练数据(Train Data)我们通常收集一系列的真实数据，例如多栋房屋的真实售出价格和它们对应的面积和房龄。我们希望在这个数据上面寻找模型参数来使模型的预测价格与真实价格的误差最小。在机器学习术语里，该数据集被称为训练数据集（training data set）或训练集（training set），一栋房屋被称为一个样本（sample），其真实售出价格叫作标签（label），用来预测标签的两个因素叫作特征（feature）。特征用来表征样本的特点。 假设我们采集的样本数为$n$，索引为$i$的样本的特征为$x_1^{(i)}$和$x_2^{(i)}$，标签为$y^{(i)}$。对于索引为$i$的房屋，线性回归模型的房屋价格预测表达式为 $$\\hat{y}^{(i)} = x_1^{(i)} w_1 + x_2^{(i)} w_2 + b.$$ 损失函数(Loss Function)在模型训练中，我们需要衡量价格预测值与真实值之间的误差。通常我们会选取一个非负数作为误差，且数值越小表示误差越小。一个常用的选择是平方函数。它在评估索引为$i$的样本误差的表达式为 $$\\ell^{(i)}(w_1, w_2, b) = \\frac{1}{2} \\left(\\hat{y}^{(i)} - y^{(i)}\\right)^2,$$ 其中常数$\\frac{1}{2}$使对平方项求导后的常数系数为1，这样在形式上稍微简单一些。显然，误差越小表示预测价格与真实价格越相近，且当二者相等时误差为0。给定训练数据集，这个误差只与模型参数相关，因此我们将它记为以模型参数为参数的函数。在机器学习里，将衡量误差的函数称为损失函数（loss function）。这里使用的平方误差函数也称为平方损失（square loss）。 通常，我们用训练数据集中所有样本误差的平均来衡量模型预测的质量，即 $$\\ell(w_1, w_2, b) =\\frac{1}{n} \\sum_{i=1}^n \\ell^{(i)}(w_1, w_2, b) =\\frac{1}{n} \\sum_{i=1}^n \\frac{1}{2}\\left(x_1^{(i)} w_1 + x_2^{(i)} w_2 + b - y^{(i)}\\right)^2.$$ 在模型训练中，我们希望找出一组模型参数，记为 $w_1^*, w_2^*, b^*$ ，来使训练样本平均损失最小： $$w_1^*, w_2^*, b^* = \\operatorname*{argmin}_{w_1, w_2, b}\\ \\ell(w_1, w_2, b).$$ 优化算法当模型和损失函数形式较为简单时，上面的误差最小化问题的解可以直接用公式表达出来。这类解叫作解析解（analytical solution）。本节使用的线性回归和平方误差刚好属于这个范畴。然而，大多数深度学习模型并没有解析解，只能通过优化算法有限次迭代模型参数来尽可能降低损失函数的值。这类解叫作数值解（numerical solution）。 在求数值解的优化算法中，小批量随机梯度下降（mini-batch stochastic gradient descent）在深度学习中被广泛使用。它的算法很简单：先选取一组模型参数的初始值，如随机选取；接下来对参数进行多次迭代，使每次迭代都可能降低损失函数的值。在每次迭代中，先随机均匀采样一个由固定数目训练数据样本所组成的小批量（mini-batch）$\\mathcal{B}$，然后求小批量中数据样本的平均损失有关模型参数的导数（梯度），最后用此结果与预先设定的一个正数的乘积作为模型参数在本次迭代的减小量。 在训练本节讨论的线性回归模型的过程中，模型的每个参数将作如下迭代： $$\\begin{aligned}w_1 &amp;\\leftarrow w_1 - \\frac{\\eta}{|\\mathcal{B}|} \\sum_{i \\in \\mathcal{B}} \\frac{ \\partial \\ell^{(i)}(w_1, w_2, b) }{\\partial w_1} = w_1 - \\frac{\\eta}{|\\mathcal{B}|} \\sum_{i \\in \\mathcal{B}}x_1^{(i)} \\left(x_1^{(i)} w_1 + x_2^{(i)} w_2 + b - y^{(i)}\\right),\\w_2 &amp;\\leftarrow w_2 - \\frac{\\eta}{|\\mathcal{B}|} \\sum_{i \\in \\mathcal{B}} \\frac{ \\partial \\ell^{(i)}(w_1, w_2, b) }{\\partial w_2} = w_2 - \\frac{\\eta}{|\\mathcal{B}|} \\sum_{i \\in \\mathcal{B}}x_2^{(i)} \\left(x_1^{(i)} w_1 + x_2^{(i)} w_2 + b - y^{(i)}\\right),\\b &amp;\\leftarrow b - \\frac{\\eta}{|\\mathcal{B}|} \\sum_{i \\in \\mathcal{B}} \\frac{ \\partial \\ell^{(i)}(w_1, w_2, b) }{\\partial b} = b - \\frac{\\eta}{|\\mathcal{B}|} \\sum_{i \\in \\mathcal{B}}\\left(x_1^{(i)} w_1 + x_2^{(i)} w_2 + b - y^{(i)}\\right).\\end{aligned}$$迭代以获取最优的参数 数据归一化和标准化不同数值的差异对结果的影响是完全不同的.例如身高从1.6到1.8那么他的体重可能就会从50到100,可见身高变化的幅度相对体重要小得多,也就是说体重拥有更好的非线性决断能力! 因此我们需要通过归一化与标准化,让我们所有的特征值都统一到一个标准的区间! 线性函数归一化$$X_{normal}=\\frac{X-X_{min}}{X_{max}-X{min}}$$ $X$原始特征数据 $X_{min},X_{max}$所有样本中的最小值与最大值 $X_{normal}$归一化之后的数据,在$[0,1]$之间 零均值标准化$$X_{normal}=\\frac{X-\\mu}{\\sigma}$$ $\\mu$均值 $\\sigma$标准差,一般设为1 $X_{normal}$归一化之后的数据 数学基础附录满秩的概念定义一使用初等行变化将矩阵化简为阶梯型矩阵,则矩阵中非零行的个数就是该矩阵的秩。 当矩阵的秩等于矩阵的行数时，就称该矩阵为满秩矩阵。 定义二若该矩阵的某一r阶子式的行列式不为零,并且所有大于r阶的子式的行列式全为0,那么就称该矩阵的秩为r,使用符号记为:$$A_{m*n}:R(A)=r$$如果有以下的等式$$R(A)=m$$ $$R(A)=n$$ 那就称之为行满秩矩阵或者是列满秩矩阵! 若有$m=n$则称之为满秩矩阵,可逆矩阵,非奇异矩阵. 似然函数对于函数$p=(x|\\theta)$而言,如果我们将$\\theta$设为常量,那么我们将得到一个关于$x$的函数,也就是关于$x$的概率分布. 而当我们将$\\theta$当作变量,将$x$当作常量时,我们就得到了关于$\\theta$的极大似然函数! 对于极大似然函数,我们可以给出一个简单的示例: 对一枚硬币随机抛掷十次,得到一个结果组:$x=HHTTHTHHHH$,也就是一组正反序列,很显然,对于抛掷硬币的实验,其分布是一组二项分布,不是正面就是反面,那么我们可以很简单的得到一个表达式:$x=\\theta^7(1-\\theta)^3$,对于$\\theta$的不同取值,表达式也会有不同的结果,但其变量是在$[0,1]$上的,所以我们可以取遍其所有的值,获得一张表: 可以看到在0.7时取到最大值,也就是最大似然估计值.显然,由于样本数过少,这个值是不太可能的一个值. 所有我们可以认为,这个等式的核心意思都是在给一个theta和一个样本x的时候，整个事件发生的可能性多大 贝叶斯公式(Bayes’ theorem)$$P(A|B)=\\frac{P(A)P(B|A)}{P(B)}$$ 凹函数与凸函数凸函数$$f(\\frac{x_1+x_2}{2})&gt;\\frac{f(x_1)+f(x_2)}{2}$$ 上面是一个特殊的定义,更加一般的定义是:$$f(ax_1+bx_2)&gt;af(x_1)+bf(x_2)。 a+b=1$$那么凹函数也就是凸函数取反，即可得到。 凹函数$$f(ax_1+bx_2)&lt;af(x_1)+bf(x_2)。 a+b=1$$","link":"/2020/07/07/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E7%9A%84%E7%AE%80%E6%B4%81%E5%AE%9E%E7%8E%B0/"},{"title":"能够占有生活的只能是生活","text":"生活总是稀疏而繁忙的，不可能每时每刻都有要紧的事情需要去做，也不是永远都无所事事。 所谓的无所事事，不过是过分地期待而不得罢了。 我想不会有那么一件单一的事情永远的占用我的日子，我想这也是应该的，而不应该像以前那样由于某些事情的失败或者挫折，而整日长久地沉沦与自责。 生活需要进步。 只要我还活着，那么人生就不会无意义。","link":"/2019/09/05/%E8%83%BD%E5%A4%9F%E5%8D%A0%E6%9C%89%E7%94%9F%E6%B4%BB%E7%9A%84%E5%8F%AA%E8%83%BD%E6%98%AF%E7%94%9F%E6%B4%BB/"},{"title":"自主搭建SS服务器","text":"本文是依托阿里云香港服务器搭建SS服务器，便于我在学校之外访问学术网站。我选择的服务器是最便宜的轻量级应用服务器 系统我选择的是centOS7.3，我之前并没有很深入的去了解Linux，所以我也是摸爬滚打现学现用 阿里云的配置网上很多我就不在这里写了 Mac用终端连接服务器，win可以用XShell。 输入密码后即可进入阿里云服务器的命令行界面然后执行下面三条语句： 123$ wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh$ chmod +x shadowsocks-all.sh$ ./shadowsocks-all.sh 2&amp;gt;&amp;amp;1 | tee shadowsocks-all.log&lt;/pre&gt; 1wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; sudo bash ssr.sh&lt;/pre&gt; 执行之后会提示你需要输入语言密码端口等 这里有一个坑，就是我是根据网上一个博客进行操作的，但是那篇博客里是用的go语言，那么最后ss的全称是shadowsocks-go，而不是shadowsaocks，需要记住这点，不然的话后期添加多用户会遇到一些麻烦。 改用第二个代码就可以中文安装了 在设置完端口和密码之后回到阿里云的防火墙，打开之前设置的端口。最后Enjoy it","link":"/2019/07/24/%E8%87%AA%E4%B8%BB%E6%90%AD%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"title":"自建云盘cloudreve","text":"起因因为看到iPad上面有挺多的app支持用webdav备份查找文件，所以一直想自己搭建一个webdav服务。毕竟onedrive真的是太坑了，同步速度巨慢，还经常打开失败，出现奇奇怪怪的错误。 过程起初我以为是要安装什么命令行之类的。最初的设想是使用ngnix的webdav模块，不过之后找到了更好一点的解决办法！ 那就是用cloudreve！ 这个是树洞外链作者的一个新作品，虽然我不知道树洞外链是什么，有机会再去看看，应该比较有趣！cloudreve←这个是作者的网址。 安装 我的云主机用的是宝塔面板，所以很多部分都比较简略，命令行基本在这里没怎么用到。 下载安装包(点击即可下载)，你也可以去上面的官网下载最新的安装包。 解压缩 在宝塔面板创建一个新的网站 用phpmyadmin将压缩包的根目录下的sql文件导入到该数据库里 在application文件夹里找到databse_sample.php文件，更改里面的数据库设置，然后重命名保存为database.php文件。 重新打包，上传到宝塔面板创建的网站的根目录下面。 这个时候应该已经可以打开界面了，但是点击按钮均会404，所以还需要配置伪静态。 配置伪静态 宝塔面板可以在这里直接设置。 由于cloudreve是基于thinkphp创建的，所以可以直接选择模板里的thinkphp模板，没有的话也可以直接用这个 12345location / { if (!-e $request_filename){ rewrite ^(.*)$ /index.php?s=$1 last; break; }} 最后应该就可以了。 cloudreve中有相应的webdav选项。","link":"/2019/10/17/%E8%87%AA%E5%BB%BA%E4%BA%91%E7%9B%98cloudreve/"},{"title":"观看中华人民共和国七十周年阅兵仪式有感","text":"还有印象的阅兵就是前几年的抗战胜利七十周年的阅兵大典了，再往前就是六十周年的十一阅兵，诚然，阅兵一年比一年壮观，气势也是越来越宏伟壮阔，东风系列的导弹也从只是耳闻到大众亮相，我们国家的硬实力确实是越来越强了，天安门前，十里长街，茫茫军绿色，是我们的国防的守卫色，每次见到，都会心生崇敬与自豪之情。 近几日国际争锋也是丝毫没有停歇，肖华莫雷的言论也是令人心生不悦，网上有句话说的挺好： “我喜欢看NBA，但我更清楚我是凭什么有资格有机会躺在沙发上舒舒服服地看球赛” 致敬每一位捍卫我国国防安全的同胞。","link":"/2019/10/10/%E8%A7%82%E7%9C%8B%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E4%B8%83%E5%8D%81%E5%91%A8%E5%B9%B4%E9%98%85%E5%85%B5%E4%BB%AA%E5%BC%8F%E6%9C%89%E6%84%9F/"},{"title":"规则星空，无尽下坠","text":"我活在0-10秒 死在30-34秒 这一次，让我落下去。 就像所有结局期许的开头一样","link":"/2019/09/07/%E8%A7%84%E5%88%99%E6%98%9F%E7%A9%BA-%E6%97%A0%E5%B0%BD%E4%B8%8B%E5%9D%A0/"},{"title":"这几天","text":"这几天，怎么说呢，过的也还好吧 快到深夜的时候总会很难受，害，我以为我都已经忘了。 今天终于记得去取军运会的门票了，说实话，还是有一点去看热闹的感觉，如果明年的S10也在武汉就好了，不知道那是有没有钱去看，我真的好想去现场看一次比赛！ 不过女篮好像也挺好的，正好碰上中国VS加拿大。 我不知道是不是chevereto这个软件的问题，反正我自己的图床网站已经崩溃了，一直打不开，我很烦，然后又去寻找了很多办法，最后决定买了阿里云的OSS。虽然我知道还有很多免费的图床，不至于要去买阿里的云存储，但是我有点想探索一下，所以思考再三还是买了。 我真的好能花钱一人。 呼，我好像已经好久好久没有出学校吃饭了，最近事情比较多，前有JAVA课程设计，后有汇编课程设计，我真的是吐了，最近如果能做完的话我会发到github上的,hhh，我尽量写的完整一点 图床崩了之后我也去找了替代的方法，不过之前的域名在我反复胡乱解析之后终于是出现了大问题，我也不知道什么情况，反正就是一直用不了，所以我现在用的图床域名是img别的不说，有自己的域名真的很爽哈哈哈 好久好久之前的马歇尔的白嫖活动终于给我寄过来了，不过我不是很需要这件衣服，我真的有很多衣服了，有点想把这个捐掉，要是能送我个耳机就好了（每天做梦..） 好像没有了，那么生活愉快吧。 脱水APP好像还挺好玩的！","link":"/2019/10/17/%E8%BF%99%E5%87%A0%E5%A4%A9/"},{"title":"阿里云Ai训练营DayTwo","text":"主题今天的主题是使用springboot starter和阿里云的AI识别sdk构建一个身份证识别应用。 主要依赖项 spring-boot-starter-web 页面模板spring-boot-starter-thymeleaf 阿里云识别组件与json组件 12345&lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;ocr&lt;/artifactId&gt; &lt;version&gt;1.0.3&lt;/version&gt; &lt;/dependency&gt; 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.67&lt;/version&gt;&lt;/dependency&gt; 主要逻辑用户在web端上传身份证的正反面的照片，然后传递到springboot，然后由后端将图像传递到阿里云的识别服务，等待识别服务响应识别结果，最后将结果渲染到thymeleaf模板中返还给用户实现完整逻辑。 代码实现分析解读Controller层上传文件部分12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@PostMapping(&quot;/upload&quot;) public String uploadFile(@RequestParam(&quot;face&quot;) MultipartFile face, @RequestParam(&quot;back&quot;) MultipartFile back, RedirectAttributes attributes) { // 判断是否上传了空文件 if (face.isEmpty() || back.isEmpty()) { // 显示报错信息 attributes.addFlashAttribute(&quot;message&quot;, &quot;Please select a file to upload.&quot;); // 路由跳转 return &quot;redirect:/&quot;; } // 初始化错误信息 String errorMessage = null; try { // 根据相对路径获取上传目录的绝对路径 Path dir = Paths.get(uploadDirectory); // 检测路径的存在性，避免因为路径不存在而报错 if (!Files.exists(dir)) { Files.createDirectories(dir); } // 个人感觉下面两部分的空检测是不必要的，上面已经检测过一遍了 if (!face.isEmpty()) { // 将文本流保存到本地，并获取对应的文件名。文件名是随机ID String filename = saveFile(face); // 调用OCR服务，获取识别人脸面的识别信息 Map&lt;String, String&gt; res = ocrService.RecognizeIdCard(uploadDirectory + filename, &quot;face&quot;); // 在缓存中加入识别成功的文件 faceImages.add(&quot;/images/&quot; + filename); // 在缓存中加入识别结果 faceResults.add(res); } // 背部的识别同上 if (!back.isEmpty()) { String filename = saveFile(back); Map&lt;String, String&gt; res = ocrService.RecognizeIdCard(uploadDirectory + filename, &quot;back&quot;); backImages.add(&quot;/images/&quot; + filename); backResults.add(res); } } catch (TeaException e) { // 错误捕捉 e.printStackTrace(); errorMessage = JSON.toJSONString(e.getData()); } catch (Exception e) { e.printStackTrace(); errorMessage = e.getMessage(); } // 判断是否有错误报出 if (StringUtils.isNotBlank(errorMessage)) { attributes.addFlashAttribute(&quot;message&quot;, errorMessage); } // 路由跳转 return &quot;redirect:/&quot;; } OCR服务1234567891011121314151617181920212223/** * 身份证识别 * @param filePath 文件路径 * @param side 身份证的面 * @return 识别结果 * @throws Exception */ public Map&lt;String, String&gt; RecognizeIdCard(String filePath, String side) throws Exception { // 实例化请求 RecognizeIdentityCardAdvanceRequest request = new RecognizeIdentityCardAdvanceRequest(); // 加载需要识别的图像流 request.imageURLObject = Files.newInputStream(Paths.get(filePath)); // 加载对应的面：人像面或者是国徽面 request.side = side; // 发送请求并获取响应 RecognizeIdentityCardResponse response = ocrClient.recognizeIdentityCardAdvance(request, runtime); if (&quot;face&quot;.equals(side)) { return JSON.parseObject(JSON.toJSONString(response.data.frontResult), new TypeReference&lt;Map&lt;String, String&gt;&gt;() {}); } else { return JSON.parseObject(JSON.toJSONString(response.data.backResult), new TypeReference&lt;Map&lt;String, String&gt;&gt;() {}); } } 下面是完整代码地址源码地址: https://github.com/aliyun/alibabacloud-viapi-demo/tree/master","link":"/2020/06/05/aliyunAiDayTwo/"},{"title":"阿里云Ai训练营DayThree","text":"主题今天的主题是制作AI识别相册. 实例截图 主要是实现对图片内容的解析识别,然后提取标签做一个双向分类. 主要依赖项123456789101112131415161718192021222324252627282930 &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.67&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/commons-codec/commons-codec --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.14&lt;/version&gt; &lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/com.aliyun/aliyun-java-sdk-core --&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt; &lt;version&gt;4.4.9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.aliyun/facebody --&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;facebody&lt;/artifactId&gt; &lt;version&gt;0.0.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.aliyun/imagerecog --&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;imagerecog&lt;/artifactId&gt; &lt;version&gt;0.0.5&lt;/version&gt; &lt;/dependency&gt; 前端是由简单的Vue来实现的. 这里没有用SSR这些后端渲染的方法来实现,而是使用AXIOS来实现数据请求 主要逻辑在web端上传图片,通过upload组件将图片传到后端,后端将图片通过阿里云SDK传到对应的处理服务,然后获取识别结果,存入到本地,再做对前台的响应. 当前端点击网页上的标签时就会发起请求,后端服务从存在本地的JSON文件读取出数据,再进行响应. 主要业务代码分析1234567891011121314151617181920212223public List&lt;String&gt; recognizeScene(InputStream inputStream) throws Exception { // 实例化图像识别请求 RecognizeSceneAdvanceRequest request = new RecognizeSceneAdvanceRequest(); // 将图像流挂载到请求上 request.imageURLObject = inputStream; // 实例化一个标签缓冲区 List&lt;String&gt; labels = new ArrayList&lt;&gt;(); try { // 实例化图像识别请求client com.aliyun.imagerecog.Client client = getImageRecogClient(imageRecogEndpoint); // 获取识别结果 RecognizeSceneResponse resp = client.recognizeSceneAdvance(request, new RuntimeObject()); for (RecognizeSceneResponse.RecognizeSceneResponseDataTags tag: resp.data.tags) { // 将识别结果加入到缓冲区中 labels.add(tag.value); } } catch (ClientException e) { // 错误处理 log.error(&quot;ErrCode:{}, ErrMsg:{}, RequestId:{}&quot;, e.getErrCode(), e.getErrMsg(), e.getRequestId()); } return labels; } labels; } 上面的代码实现了标签提取,并加入了链表. 其他部分的业务代码大多类似雷同,不再赘述","link":"/2020/06/06/aliyunAiDayThree/"},{"title":"风越过山丘与我相会","text":"七月总是跌宕 还记得去年七月，初了是在六月末的动车上，惊奇也好，无感也好，都敌不过不能吹着风的失望。窗外迤逦的风景，与我毫不相干。 说来也是有趣，在车上接到邀约，邀我一起去川地旅游，诚然，我在那时确实很喜欢那位女孩子，喜欢到哪怕是过后找了女友也会偶尔想起，但自这场川蜀游结束后却让我明白朋友才是最终的归途吧。 毫不害臊的说，七月令我印象深刻的原因往往是我的生日，因而我对这个月份灌注极多的期待，过去这几年有快活的，也有不快活的，有失望落空，自怨自艾，也有心满意足的，总归一句话：花钱。 今年，七月初便经历了一场分别，她说祝我有一个崭新的七月，我对情感的思考从未像今年一般，有那么的深刻。我究竟在为什么生活，又究竟是为了什么而去寻觅一段与人亲密的关系，我又究竟在渴求什么。 结束后的反思 现在结束了，但远远没有想明白，而且，这答案也不是永远一成不变的，虽然很多时候我会认为我的观点自相矛盾，但是这并不影响我有一个我自己都未正确认知的固有人格。 做很多事情的时候还是会带有之前与人相处而得来的习惯，我很少影响到别人的习惯，我总是那个被影响的，这些潜意识的习惯里，藏着每一分眷恋吧。 下笔前总是认为自己能写很多，但是实际上并没有那么多思绪给我抒发，原因大概是这个博客一般而言只有我一个人在写在看。 顺其自然就像是懦夫对无奈生活的叹息 但有些事情终归是 意难平 我有一壶酒，独酌无相亲 祝所有人安好","link":"/2019/07/25/%E9%A3%8E%E8%B6%8A%E8%BF%87%E5%B1%B1%E4%B8%98%E4%B8%8E%E6%88%91%E7%9B%B8%E4%BC%9A/"},{"title":"阿里云Ai训练营DayOne","text":"视觉生产生产是输入输出的过程 给予一定的生产素材 然后通过视觉生产基础框架对素材，需求进行一定的语义分析理解 再经过视觉生产模型产出对应的产品。 生产的难点生产的难点在于对视觉输入素材的准确理解。 与一般性输入不同，大多数的视觉生产的输入参数是包含难以语义化的图片，是机器无法直接理解处理的流，因此在开始对应的生产服务之前需要对图片进行分割精细理解。 知道是什么 人的识别 车的识别 知道识别对象的位置 找到缺陷的位置 画面中多对象的识别 知道每一个像素是什么","link":"/2020/06/04/aliyunAiDayOne/"},{"title":"骂得开心，活得尽兴","text":"长时间远离微博的我也是真的越来越不暴躁了，虽然看到逼乎上各种带着有色眼镜的回答时还是会有一些受感染，不过我也确实是这样的人。 越来越不在意手机的电量了，以前每每到二十以下就已经慌得不行不行的了，现在呢，随他去吧，反正也无人要紧地找我聊天。 这两天也总是被我爸/我爷爷/我妈从睡梦中叫醒，谁能想到我现在天天八点半就醒来了呢？？？？我一点都不想啊。早上的日子大多是在肮脏的车间帮忙里度过的，其实呢，也并没有特别的忙碌，就是热了点，其他的也不是不能忍受，日子还是在正常的过着嘛。 爷爷老是来问我什么时候回学校，这才有些明了竟然还有二十天，我才回来了十天？？但我还是没有吃到糯米饭，因为无人值得我早期跑到hq/yq去吃一顿早点，毕竟太热了是吧... 昨夜又梦见了她，真的很烦噢。在一起的时候梦到的次数都没有这段时间多，每次醒来的失落感真的是令人沮丧，我有点烦躁。 其实我还是挺在意lqy这个逼的关系的？不过该骂还是要骂，该口嗨的时候不能打住。不过这个逼不欢迎老子去昆明真的有点烦哦，管他呢，吃饭要紧。 开开心心骂人 冷静想想，绝大多数事情你自己不说出口压根没有人会想到你这个逼竟然是这么想的，说多惹人烦是矫情做作，不说憋得慌是自作自受，自我摧残，还不如该口嗨口嗨，该骂人骂人，活得尽兴不比窝窝囊囊过日子舒服? 老子再也不跟这个杂那个杂对线了，骂又骂不过还惹得老子自己心慌，nmd，还是敲代码有意思，还不用跟这个傻逼那个傻逼沟通，自己智障了也不会有人跳出来跟个猴子一样嘲讽。 骂的真爽//昨天球打了身上可真他娘的疼。","link":"/2019/07/27/%E9%AA%82%E5%BE%97%E5%BC%80%E5%BF%83-%E6%B4%BB%E5%BE%97%E5%B0%BD%E5%85%B4/"}],"tags":[{"name":"垃圾生活","slug":"垃圾生活","link":"/tags/%E5%9E%83%E5%9C%BE%E7%94%9F%E6%B4%BB/"},{"name":"杂记","slug":"杂记","link":"/tags/%E6%9D%82%E8%AE%B0/"},{"name":"生活","slug":"生活","link":"/tags/%E7%94%9F%E6%B4%BB/"},{"name":"随想","slug":"随想","link":"/tags/%E9%9A%8F%E6%83%B3/"},{"name":"影评","slug":"影评","link":"/tags/%E5%BD%B1%E8%AF%84/"},{"name":"科幻","slug":"科幻","link":"/tags/%E7%A7%91%E5%B9%BB/"},{"name":"网站","slug":"网站","link":"/tags/%E7%BD%91%E7%AB%99/"},{"name":"服务器","slug":"服务器","link":"/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"日记","slug":"日记","link":"/tags/%E6%97%A5%E8%AE%B0/"},{"name":"meting","slug":"meting","link":"/tags/meting/"},{"name":"netease","slug":"netease","link":"/tags/netease/"},{"name":"type","slug":"type","link":"/tags/type/"},{"name":"server","slug":"server","link":"/tags/server/"},{"name":"操作","slug":"操作","link":"/tags/%E6%93%8D%E4%BD%9C/"},{"name":"时候","slug":"时候","link":"/tags/%E6%97%B6%E5%80%99/"},{"name":"flag","slug":"flag","link":"/tags/flag/"},{"name":"anyway","slug":"anyway","link":"/tags/anyway/"},{"name":"记忆","slug":"记忆","link":"/tags/%E8%AE%B0%E5%BF%86/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"汇编","slug":"汇编","link":"/tags/%E6%B1%87%E7%BC%96/"},{"name":"钢琴师","slug":"钢琴师","link":"/tags/%E9%92%A2%E7%90%B4%E5%B8%88/"},{"name":"悬梯","slug":"悬梯","link":"/tags/%E6%82%AC%E6%A2%AF/"},{"name":"regulation","slug":"regulation","link":"/tags/regulation/"},{"name":"钢琴","slug":"钢琴","link":"/tags/%E9%92%A2%E7%90%B4/"},{"name":"fuck","slug":"fuck","link":"/tags/fuck/"},{"name":"宝塔","slug":"宝塔","link":"/tags/%E5%AE%9D%E5%A1%94/"},{"name":"文件","slug":"文件","link":"/tags/%E6%96%87%E4%BB%B6/"},{"name":"ssl","slug":"ssl","link":"/tags/ssl/"},{"name":"域名","slug":"域名","link":"/tags/%E5%9F%9F%E5%90%8D/"},{"name":"地址","slug":"地址","link":"/tags/%E5%9C%B0%E5%9D%80/"},{"name":"gitea","slug":"gitea","link":"/tags/gitea/"},{"name":"gogs","slug":"gogs","link":"/tags/gogs/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"安装","slug":"安装","link":"/tags/%E5%AE%89%E8%A3%85/"},{"name":"插件","slug":"插件","link":"/tags/%E6%8F%92%E4%BB%B6/"},{"name":"字数","slug":"字数","link":"/tags/%E5%AD%97%E6%95%B0/"},{"name":"解析","slug":"解析","link":"/tags/%E8%A7%A3%E6%9E%90/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"douban","slug":"douban","link":"/tags/douban/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"创建","slug":"创建","link":"/tags/%E5%88%9B%E5%BB%BA/"},{"name":"scode","slug":"scode","link":"/tags/scode/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"类型","slug":"类型","link":"/tags/%E7%B1%BB%E5%9E%8B/"},{"name":"任务","slug":"任务","link":"/tags/%E4%BB%BB%E5%8A%A1/"},{"name":"新建","slug":"新建","link":"/tags/%E6%96%B0%E5%BB%BA/"},{"name":"按钮","slug":"按钮","link":"/tags/%E6%8C%89%E9%92%AE/"},{"name":"窗口","slug":"窗口","link":"/tags/%E7%AA%97%E5%8F%A3/"},{"name":"abc","slug":"abc","link":"/tags/abc/"},{"name":"string","slug":"string","link":"/tags/string/"},{"name":"对象","slug":"对象","link":"/tags/%E5%AF%B9%E8%B1%A1/"},{"name":"button","slug":"button","link":"/tags/button/"},{"name":"图床","slug":"图床","link":"/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"云协","slug":"云协","link":"/tags/%E4%BA%91%E5%8D%8F/"},{"name":"electron","slug":"electron","link":"/tags/electron/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"length","slug":"length","link":"/tags/length/"},{"name":"列表","slug":"列表","link":"/tags/%E5%88%97%E8%A1%A8/"},{"name":"node","slug":"node","link":"/tags/node/"},{"name":"neeto","slug":"neeto","link":"/tags/neeto/"},{"name":"file","slug":"file","link":"/tags/file/"},{"name":"typora","slug":"typora","link":"/tags/typora/"},{"name":"图片","slug":"图片","link":"/tags/%E5%9B%BE%E7%89%87/"},{"name":"参数","slug":"参数","link":"/tags/%E5%8F%82%E6%95%B0/"},{"name":"linecount","slug":"linecount","link":"/tags/linecount/"},{"name":"echo","slug":"echo","link":"/tags/echo/"},{"name":"bin","slug":"bin","link":"/tags/bin/"},{"name":"行计数器","slug":"行计数器","link":"/tags/%E8%A1%8C%E8%AE%A1%E6%95%B0%E5%99%A8/"},{"name":"line","slug":"line","link":"/tags/line/"},{"name":"年度","slug":"年度","link":"/tags/%E5%B9%B4%E5%BA%A6/"},{"name":"红包","slug":"红包","link":"/tags/%E7%BA%A2%E5%8C%85/"},{"name":"抽奖","slug":"抽奖","link":"/tags/%E6%8A%BD%E5%A5%96/"},{"name":"wordpress","slug":"wordpress","link":"/tags/wordpress/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"option_id","slug":"option-id","link":"/tags/option-id/"},{"name":"wp_options","slug":"wp-options","link":"/tags/wp-options/"},{"name":"where","slug":"where","link":"/tags/where/"},{"name":"select","slug":"select","link":"/tags/select/"},{"name":"重启","slug":"重启","link":"/tags/%E9%87%8D%E5%90%AF/"},{"name":"lib","slug":"lib","link":"/tags/lib/"},{"name":"疫情","slug":"疫情","link":"/tags/%E7%96%AB%E6%83%85/"},{"name":"逼逼","slug":"逼逼","link":"/tags/%E9%80%BC%E9%80%BC/"},{"name":"addtime","slug":"addtime","link":"/tags/addtime/"},{"name":"curedcount","slug":"curedcount","link":"/tags/curedcount/"},{"name":"deadcount","slug":"deadcount","link":"/tags/deadcount/"},{"name":"cityname","slug":"cityname","link":"/tags/cityname/"},{"name":"每月纪","slug":"每月纪","link":"/tags/%E6%AF%8F%E6%9C%88%E7%BA%AA/"},{"name":"o","slug":"o","link":"/tags/o/"},{"name":"网课","slug":"网课","link":"/tags/%E7%BD%91%E8%AF%BE/"},{"name":"外村","slug":"外村","link":"/tags/%E5%A4%96%E6%9D%91/"},{"name":"kfc","slug":"kfc","link":"/tags/kfc/"},{"name":"滴滴","slug":"滴滴","link":"/tags/%E6%BB%B4%E6%BB%B4/"},{"name":"字符","slug":"字符","link":"/tags/%E5%AD%97%E7%AC%A6/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据","slug":"数据","link":"/tags/%E6%95%B0%E6%8D%AE/"},{"name":"dom","slug":"dom","link":"/tags/dom/"},{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"},{"name":"文疏","slug":"文疏","link":"/tags/%E6%96%87%E7%96%8F/"},{"name":"实现","slug":"实现","link":"/tags/%E5%AE%9E%E7%8E%B0/"},{"name":"着笔","slug":"着笔","link":"/tags/%E7%9D%80%E7%AC%94/"},{"name":"垃圾文章","slug":"垃圾文章","link":"/tags/%E5%9E%83%E5%9C%BE%E6%96%87%E7%AB%A0/"},{"name":"typecho","slug":"typecho","link":"/tags/typecho/"},{"name":"查询","slug":"查询","link":"/tags/%E6%9F%A5%E8%AF%A2/"},{"name":"phpadmin","slug":"phpadmin","link":"/tags/phpadmin/"},{"name":"冬至","slug":"冬至","link":"/tags/%E5%86%AC%E8%87%B3/"},{"name":"立冬","slug":"立冬","link":"/tags/%E7%AB%8B%E5%86%AC/"},{"name":"归程","slug":"归程","link":"/tags/%E5%BD%92%E7%A8%8B/"},{"name":"惭愧","slug":"惭愧","link":"/tags/%E6%83%AD%E6%84%A7/"},{"name":"叛徒","slug":"叛徒","link":"/tags/%E5%8F%9B%E5%BE%92/"},{"name":"effect","slug":"effect","link":"/tags/effect/"},{"name":"暴力","slug":"暴力","link":"/tags/%E6%9A%B4%E5%8A%9B/"},{"name":"言论","slug":"言论","link":"/tags/%E8%A8%80%E8%AE%BA/"},{"name":"keep","slug":"keep","link":"/tags/keep/"},{"name":"节点","slug":"节点","link":"/tags/%E8%8A%82%E7%82%B9/"},{"name":"img_src","slug":"img-src","link":"/tags/img-src/"},{"name":"thumburl","slug":"thumburl","link":"/tags/thumburl/"},{"name":"缩略图","slug":"缩略图","link":"/tags/%E7%BC%A9%E7%95%A5%E5%9B%BE/"},{"name":"函数","slug":"函数","link":"/tags/%E5%87%BD%E6%95%B0/"},{"name":"typecho_db","slug":"typecho-db","link":"/tags/typecho-db/"},{"name":"页面","slug":"页面","link":"/tags/%E9%A1%B5%E9%9D%A2/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"base64","slug":"base64","link":"/tags/base64/"},{"name":"网页","slug":"网页","link":"/tags/%E7%BD%91%E9%A1%B5/"},{"name":"Qt","slug":"Qt","link":"/tags/Qt/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"项目软件","slug":"项目软件","link":"/tags/%E9%A1%B9%E7%9B%AE%E8%BD%AF%E4%BB%B6/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"origin","slug":"origin","link":"/tags/origin/"},{"name":"碎碎念","slug":"碎碎念","link":"/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"name":"int","slug":"int","link":"/tags/int/"},{"name":"temp","slug":"temp","link":"/tags/temp/"},{"name":"变量","slug":"变量","link":"/tags/%E5%8F%98%E9%87%8F/"},{"name":"tree-","slug":"tree","link":"/tags/tree/"},{"name":"leftchild","slug":"leftchild","link":"/tags/leftchild/"},{"name":"谁来救救我","slug":"谁来救救我","link":"/tags/%E8%B0%81%E6%9D%A5%E6%95%91%E6%95%91%E6%88%91/"},{"name":"graph","slug":"graph","link":"/tags/graph/"},{"name":"pic","slug":"pic","link":"/tags/pic/"},{"name":"people","slug":"people","link":"/tags/people/"},{"name":"查找","slug":"查找","link":"/tags/%E6%9F%A5%E6%89%BE/"},{"name":"右子树","slug":"右子树","link":"/tags/%E5%8F%B3%E5%AD%90%E6%A0%91/"},{"name":"二叉树","slug":"二叉树","link":"/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"左子树","slug":"左子树","link":"/tags/%E5%B7%A6%E5%AD%90%E6%A0%91/"},{"name":"修复","slug":"修复","link":"/tags/%E4%BF%AE%E5%A4%8D/"},{"name":"文章","slug":"文章","link":"/tags/%E6%96%87%E7%AB%A0/"},{"name":"添加","slug":"添加","link":"/tags/%E6%B7%BB%E5%8A%A0/"},{"name":"评论区","slug":"评论区","link":"/tags/%E8%AF%84%E8%AE%BA%E5%8C%BA/"},{"name":"splity","slug":"splity","link":"/tags/splity/"},{"name":"arr","slug":"arr","link":"/tags/arr/"},{"name":"SS","slug":"SS","link":"/tags/SS/"},{"name":"mov","slug":"mov","link":"/tags/mov/"},{"name":"寄存器","slug":"寄存器","link":"/tags/%E5%AF%84%E5%AD%98%E5%99%A8/"},{"name":"存储器","slug":"存储器","link":"/tags/%E5%AD%98%E5%82%A8%E5%99%A8/"},{"name":"字节","slug":"字节","link":"/tags/%E5%AD%97%E8%8A%82/"},{"name":"偏移","slug":"偏移","link":"/tags/%E5%81%8F%E7%A7%BB/"},{"name":"标号","slug":"标号","link":"/tags/%E6%A0%87%E5%8F%B7/"},{"name":"算符","slug":"算符","link":"/tags/%E7%AE%97%E7%AC%A6/"},{"name":"cmp","slug":"cmp","link":"/tags/cmp/"},{"name":"inc","slug":"inc","link":"/tags/inc/"},{"name":"jmp","slug":"jmp","link":"/tags/jmp/"},{"name":"杂技","slug":"杂技","link":"/tags/%E6%9D%82%E6%8A%80/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"noti","slug":"noti","link":"/tags/noti/"},{"name":"this","slug":"this","link":"/tags/this/"},{"name":"return","slug":"return","link":"/tags/return/"},{"name":"public","slug":"public","link":"/tags/public/"},{"name":"integer","slug":"integer","link":"/tags/integer/"},{"name":"new","slug":"new","link":"/tags/new/"},{"name":"edge","slug":"edge","link":"/tags/edge/"},{"name":"vertex","slug":"vertex","link":"/tags/vertex/"},{"name":"dist","slug":"dist","link":"/tags/dist/"},{"name":"trix","slug":"trix","link":"/tags/trix/"},{"name":"matrix","slug":"matrix","link":"/tags/matrix/"},{"name":"dots","slug":"dots","link":"/tags/dots/"},{"name":"线性回归","slug":"线性回归","link":"/tags/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"},{"name":"neural network","slug":"neural-network","link":"/tags/neural-network/"},{"name":"machine learning","slug":"machine-learning","link":"/tags/machine-learning/"},{"name":"webdav","slug":"webdav","link":"/tags/webdav/"},{"name":"cloudreve","slug":"cloudreve","link":"/tags/cloudreve/"},{"name":"thinkphp","slug":"thinkphp","link":"/tags/thinkphp/"},{"name":"10秒","slug":"10秒","link":"/tags/10%E7%A7%92/"},{"name":"随笔","slug":"随笔","link":"/tags/%E9%9A%8F%E7%AC%94/"},{"name":"code","slug":"code","link":"/tags/code/"},{"name":"ai","slug":"ai","link":"/tags/ai/"},{"name":"aliyun","slug":"aliyun","link":"/tags/aliyun/"}],"categories":[{"name":"Caprice","slug":"Caprice","link":"/categories/Caprice/"},{"name":"Code","slug":"Code","link":"/categories/Code/"},{"name":"Month","slug":"Month","link":"/categories/Month/"},{"name":"AiLearning","slug":"AiLearning","link":"/categories/AiLearning/"}]}